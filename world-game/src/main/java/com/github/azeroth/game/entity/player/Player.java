package com.github.azeroth.game.entity.player;


import com.github.azeroth.dbc.defines.Difficulty;
import com.github.azeroth.dbc.defines.DifficultyFlag;
import com.github.azeroth.dbc.domain.MapEntry;
import com.github.azeroth.defines.Team;
import com.github.azeroth.defines.TeamId;
import com.github.azeroth.game.*;
import com.github.azeroth.game.achievement.CriteriaManager;
import com.github.azeroth.game.achievement.PlayerAchievementMgr;
import com.github.azeroth.game.ai.IUnitAI;
import com.github.azeroth.game.ai.PlayerAI;
import com.github.azeroth.game.battleground.Battleground;
import com.github.azeroth.game.battleground.BattlegroundQueueTypeId;
import com.github.azeroth.game.battlepet.BattlePet;
import com.github.azeroth.game.chat.Channel;
import com.github.azeroth.game.chat.ChannelManager;
import com.github.azeroth.game.chat.CustomChatTextBuilder;
import com.github.azeroth.game.domain.quest.QuestStatusData;
import com.github.azeroth.game.entity.corpse.Corpse;
import com.github.azeroth.game.entity.creature.Creature;
import com.github.azeroth.game.domain.creature.CreatureTemplate;
import com.github.azeroth.game.entity.gobject.GameObject;
import com.github.azeroth.game.entity.gobject.Transport;
import com.github.azeroth.game.entity.item.*;
import com.github.azeroth.game.entity.object.GenericObject;
import com.github.azeroth.game.entity.object.ObjectGuid;
import com.github.azeroth.game.entity.object.WorldLocation;
import com.github.azeroth.game.entity.object.WorldObject;
import com.github.azeroth.game.entity.player.enums.PlayerFlag;
import com.github.azeroth.game.entity.player.enums.PlayerFlagEx;
import com.github.azeroth.game.entity.player.enums.QuestSaveType;
import com.github.azeroth.game.entity.player.enums.SpellModType;
import com.github.azeroth.game.entity.player.model.*;
import com.github.azeroth.game.entity.scene.SceneMgr;
import com.github.azeroth.game.entity.unit.DamageInfo;
import com.github.azeroth.game.entity.unit.DeclinedName;
import com.github.azeroth.game.entity.unit.Unit;
import com.github.azeroth.game.entity.unit.UnitActionBarEntry;
import com.github.azeroth.game.garrison.Garrison;
import com.github.azeroth.game.globals.ObjectManager;
import com.github.azeroth.game.group.GroupReference;
import com.github.azeroth.game.group.PlayerGroup;
import com.github.azeroth.game.guild.Guild;
import com.github.azeroth.game.loot.*;
import com.github.azeroth.game.mail.Mail;
import com.github.azeroth.game.mail.MailDraft;
import com.github.azeroth.game.mail.MailReceiver;
import com.github.azeroth.game.mail.MailSender;
import com.github.azeroth.game.map.*;
import com.github.azeroth.game.map.grid.Cell;
import com.github.azeroth.game.map.grid.GridObject;
import com.github.azeroth.game.map.grid.GridReference;
import com.github.azeroth.game.misc.PlayerMenu;
import com.github.azeroth.game.movement.model.MovementInfo;
import com.github.azeroth.game.networking.WorldPacket;
import com.github.azeroth.game.networking.opcode.ServerOpCode;
import com.github.azeroth.game.networking.packet.quest.DisplayPlayerChoice;
import com.github.azeroth.game.networking.packet.spell.SetSpellModifier;
import com.github.azeroth.game.networking.packet.spell.SpellModifierInfo;
import com.github.azeroth.game.pvp.OutdoorPvP;
import com.github.azeroth.game.quest.QuestObjectiveCriteriaManager;
import com.github.azeroth.game.domain.quest.QuestStatus;
import com.github.azeroth.game.reputation.ReputationMgr;
import com.github.azeroth.game.scripting.ScriptManager;
import com.github.azeroth.game.scripting.interfaces.iitem.IItemOnCastItemCombatSpell;
import com.github.azeroth.game.scripting.interfaces.iitem.IItemOnQuestAccept;
import com.github.azeroth.game.scripting.interfaces.iitem.IItemOnRemove;
import com.github.azeroth.game.scripting.interfaces.iplayer.*;
import com.github.azeroth.game.scripting.interfaces.iquest.IQuestOnQuestObjectiveChange;
import com.github.azeroth.game.scripting.interfaces.iquest.IQuestOnQuestStatusChange;
import com.github.azeroth.game.domain.player.PlayerLoginQueryLoad;
import com.github.azeroth.game.domain.quest.QuestObjectiveType;
import com.github.azeroth.game.spell.*;
import com.github.azeroth.game.spell.enums.SpellModOp;
import com.github.azeroth.utils.MathUtil;
import game.*;
import game.WorldSession;
import lombok.Getter;

import java.io.IOException;
import java.util.*;

import static com.github.azeroth.game.entity.object.update.ObjectFields.*;
import static com.github.azeroth.game.entity.player.PlayerDefine.PLAYER_BYTES_4_OFFSET_ARENA_FACTION;
import static com.github.azeroth.game.entity.player.PlayerDefine.PLAYER_BYTES_4_OFFSET_PVP_TITLE;


public class Player extends Unit implements GridObject<Player> {

    @Getter
    private final GridReference<Player> gridReference = new GridReference<>();
    private final ArrayList<Channel> channels = new ArrayList<>();
    private final ArrayList<ObjectGuid> whisperList = new ArrayList<>();
    //Inventory
    private final HashMap<Long, EquipmentSetInfo> equipmentSets = new HashMap<Long, EquipmentSetInfo>();
    private final ArrayList<EnchantDuration> enchantDurations = new ArrayList<>();
    private final ArrayList<Item> itemDuration = new ArrayList<>();
    private final ArrayList<ObjectGuid> itemSoulboundTradeable = new ArrayList<>();
    private final ArrayList<ObjectGuid> refundableItems = new ArrayList<>();
    private final VoidStorageItem[] voidStorageItems = new VoidStorageItem[SharedConst.VoidStorageMaxSlot];
    private final Item[] items = new Item[PlayerSlot.count.getValue()];
    //PVP
    private final BgBattlegroundQueueIdRec[] battlegroundQueueIdRecs = new BgBattlegroundQueueIdRec[SharedConst.MaxPlayerBGQueues];
    private final BgData bgData;
    //Groups/Raids
    private final GroupReference group = new GroupReference();
    private final GroupReference originalGroup = new GroupReference();
    private final GroupUpdateCounter[] groupUpdateSequences = new GroupUpdateCounter[2];

    private final HashMap<Integer, Integer> recentInstances = new HashMap<Integer, Integer>();

    private final HashMap<Integer, Long> instanceResetTimes = new HashMap<Integer, Long>();
    //Spell
    private final HashMap<Integer, PlayerSpell> spells = new HashMap<Integer, PlayerSpell>();

    private final HashMap<Integer, SkillStatusData> skillStatus = new HashMap<Integer, SkillStatusData>();

    private final HashMap<Integer, PlayerCurrency> currencyStorage = new HashMap<Integer, PlayerCurrency>();
    private final ArrayList<SpellModifier>[][] spellModifiers = new ArrayList<SpellModifier>[SpellModOp.values().length][];

    private final MultiMap<Integer, Integer> overrideSpells = new MultiMap<Integer, Integer>();

    private final HashMap<Integer, StoredAuraTeleportLocation> storedAuraTeleportLocations = new HashMap<Integer, StoredAuraTeleportLocation>();
    //Mail
    private final ArrayList<MAIL> mail = new ArrayList<>();

    private final HashMap<Long, Item> mailItems = new HashMap<>();
    private final RestMgr restMgr;
    //Combat
    private final int[] baseRatingValue = new int[CombatRating.max.getValue()];
    private final double[] auraBaseFlatMod = new double[BaseModGroup.End.getValue()];
    private final double[] auraBasePctMod = new double[BaseModGroup.End.getValue()];
    //Quest
    private final ArrayList<Integer> timedquests = new ArrayList<>();

    private final ArrayList<Integer> weeklyquests = new ArrayList<>();

    private final ArrayList<Integer> monthlyquests = new ArrayList<>();

    private final HashMap<Integer, HashMap<Integer, Long>> seasonalquests = new HashMap<Integer, HashMap<Integer, Long>>();

    private final HashMap<Integer, QuestStatusData> mQuestStatus = new HashMap<Integer, QuestStatusData>();

    private final HashMap<Integer, QuestSaveType> questStatusSave = new HashMap<Integer, QuestSaveType>();

    private final ArrayList<Integer> dfQuests = new ArrayList<>();

    private final ArrayList<Integer> rewardedQuests = new ArrayList<>();

    private final HashMap<Integer, QuestSaveType> rewardedQuestsSave = new HashMap<Integer, QuestSaveType>();
    private final CinematicManager cinematicMgr;
    //Core
    private final WorldSession session;
    private final QuestObjectiveCriteriaManager questObjectiveCriteriaManager;
    private final WorldLocation homeBind = new WorldLocation();
    private final SceneMgr sceneMgr;
    private final HashMap<ObjectGuid, loot> aeLootView = new HashMap<ObjectGuid, loot>();
    private final ArrayList<LootRoll> lootRolls = new ArrayList<>(); // loot rolls waiting for answer
    private final CufProfile[] cufProfiles = new CufProfile[PlayerConst.MaxCUFProfiles];
    private final double[] powerFraction = new double[PowerType.MaxPerClass.getValue()];
    private final int[] mirrorTimer = new int[3];
    private final TimeTracker groupUpdateTimer;
    private final long logintime;
    private final HashMap<Integer, PlayerSpellState> traitConfigStates = new HashMap<Integer, PlayerSpellState>();

    private final HashMap<Byte, ActionButton> actionButtons = new HashMap<Byte, ActionButton>();
    private final ArrayList<ItemSetEffect> itemSetEff = new ArrayList<>();
    private final ArrayList<Item> itemUpdateQueue = new ArrayList<>();
    private final float[] parry_cap = {65.631440f, 65.631440f, 145.560408f, 145.560408f, 0.0f, 65.631440f, 145.560408f, 0.0f, 0.0f, 90.6425f, 0.0f, 65.631440f, 0.0f, 0.0f};
    private final float[] dodge_cap = {65.631440f, 65.631440f, 145.560408f, 145.560408f, 150.375940f, 65.631440f, 145.560408f, 150.375940f, 150.375940f, 145.560408f, 116.890707f, 145.560408f, 145.560408f, 0.0f};
    public PvpInfo pvpInfo = new PvpInfo();
    QuestObjectiveType Type;
    int ObjectID;
    private PlayerSocial social;

    private int weaponProficiency;

    private int armorProficiency;

    private int currentBuybackSlot;
    private TradeData trade;
    private boolean isBgRandomWinner;

    private int arenaTeamIdInvited;
    private long lastHonorUpdateTime;

    private int contestedPvPTimer;
    private boolean usePvpItemLevels;
    private PlayerGroup groupInvite;
    private GroupUpdateFlags groupUpdateFlags = GroupUpdateFlags.values()[0];
    private boolean bPassOnGroupLoot;

    private int pendingBindId;

    private int pendingBindTimer;
    private Difficulty dungeonDifficulty = Difficulty.values()[0];
    private Difficulty raidDifficulty = Difficulty.values()[0];
    private Difficulty legacyRaidDifficulty = Difficulty.values()[0];

    private int lastFallTime;
    private float lastFallZ;
    private WorldLocation teleportDest;

    private Integer teleportInstanceId = null;
    private TeleportToOptions teleportOptions = TeleportToOptions.values()[0];
    private boolean semaphoreTeleportNear;
    private boolean semaphoreTeleportFar;
    private PlayerDelayedOperations delayedOperations = PlayerDelayedOperations.values()[0];
    private boolean canDelayTeleport;
    private boolean hasDelayedTeleport;
    private PlayerUnderwaterState mirrorTimerFlags = PlayerUnderwaterState.values()[0];
    private PlayerUnderwaterState mirrorTimerFlagsLast = PlayerUnderwaterState.values()[0];
    //Stats
    private int baseSpellPower;

    private int baseManaRegen;

    private int baseHealthRegen;
    private int spellPenetrationItemMod;

    private int lastPotionId;

    private int oldpetspell;
    private long nextMailDelivereTime;
    //Pets
    private PetStable petStable;

    private int temporaryUnsummonedPetNumber;

    private int lastpetnumber;
    // Player summoning
    private long summonExpire;
    private WorldLocation summonLocation;

    private int summonInstanceId;
    private boolean canParry;
    private boolean canBlock;
    private boolean canTitanGrip;

    private int titanGripPenaltySpellId;

    private int deathTimer;
    private long deathExpireTime;

    private byte swingErrorMsg;

    private int combatExitTime;

    private int regenTimerCount;

    private int foodEmoteTimerCount;

    private int weaponChangeTimer;
    private boolean dailyQuestChanged;
    private boolean weeklyQuestChanged;
    private boolean monthlyQuestChanged;
    private boolean seasonalQuestChanged;
    private long lastDailyQuestTime;
    private Garrison garrison;
    // variables to save health and mana before duel and restore them after duel
    private long healthBeforeDuel;

    private int manaBeforeDuel;
    private boolean advancedCombatLoggingEnabled;
    private WorldLocation corpseLocation;
    private long createTime;
    private PlayerCreateMode createMode = PlayerCreateMode.values()[0];

    private int nextSave;

    private byte cinematic;

    private int movie;
    private boolean customizationsChanged;
    private SpecializationInfo specializationInfo;
    private Team team = Team.values()[0];
    private ReputationMgr reputationMgr;
    private PlayerExtraFlags extraFlags = PlayerExtraFlags.values()[0];

    private int zoneUpdateId;

    private int areaUpdateId;

    private int zoneUpdateTimer;

    private int championingFaction;

    private byte fishingSteps;
    // Recall position
    private WorldLocation recallLocation;

    private int recallInstanceId;

    private int homebindAreaId;

    private int homebindTimer;
    private ResurrectionData resurrectionData;
    private PlayerAchievementMgr _AchievementSys;

    private long guildIdInvited;
    private DeclinedName declinedname;
    private runes runes = new runes();

    private int hostileReferenceCheckTimer;

    private int drunkTimer;
    private long lastTick;

    private int playedTimeTotal;

    private int playedTimeLevel;
    private ObjectGuid playerSharingQuest = ObjectGuid.EMPTY;

    private int sharedQuestId;

    private int ingametime;
    private PlayerCommandStates activeCheats = PlayerCommandStates.values()[0];
    private boolean autoAcceptQuickJoin;
    private boolean overrideScreenFlash;
    //Gossip
    private PlayerMenu playerTalkClass;
    private String autoReplyMsg;
    private boolean instanceValid;
    //Movement
    private Playertaxi taxi = new playerTaxi();

    private byte[] forcedSpeedChanges = new byte[UnitMoveType.max.getValue()];

    private byte movementForceModMagnitudeChanges;
    private Spell spellModTakingSpell;
    private float empoweredSpellMinHoldPct;

    private byte unReadMails;
    private boolean mailsUpdated;
    private ArrayList<PetAura> petAuras = new ArrayList<>();
    private DuelInfo duel;
    private PlayerData playerData;
    private activePlayerData activePlayerData;
    private ArrayList<ObjectGuid> clientGuiDs = new ArrayList<>();
    private ArrayList<ObjectGuid> visibleTransports = new ArrayList<>();
    private WorldObject seerView;
    private AtloginFlags loginFlags = AtLoginFlags.values()[0];
    private boolean itemUpdateQueueBlocked;
    private boolean isDebugAreaTriggers;

    public Player(WorldSession session) {
        super(true);
        setObjectTypeMask(TypeMask.forValue(getObjectTypeMask().getValue() | TypeMask.player.getValue()));
        setObjectTypeId(TypeId.PLAYER);

        setPlayerData(new playerData());
        setActivePlayerData(new activePlayerData());

        session = session;

        // players always accept
        if (!getSession().hasPermission(RBACPermissions.CanFilterWhispers)) {
            setAcceptWhispers(true);
        }

        zoneUpdateId = (int) 0xffffffff;
        nextSave = WorldConfig.getUIntValue(WorldCfg.IntervalSave);
        customizationsChanged = false;

        setGroupInvite(null);

        setLoginFlags(AtLoginFlags.NONE);
        setPlayerTalkClass(new PlayerMenu(session));
        currentBuybackSlot = InventorySlots.BuyBackStart;

        for (byte i = 0; i < MirrorTimerType.max.getValue(); i++) {
            _mirrorTimer[i] = -1;
        }

        logintime = gameTime.GetGameTime();
        lastTick = logintime;

        dungeonDifficulty = Difficulty.NORMAL;
        raidDifficulty = Difficulty.NormalRaid;
        legacyRaidDifficulty = Difficulty.Raid10N;
        setInstanceValid(true);

        specializationInfo = new SpecializationInfo();

        for (byte i = 0; i < (byte) BaseModGroup.End.getValue(); ++i) {
            _auraBaseFlatMod[i] = 0.0f;
            _auraBasePctMod[i] = 1.0f;
        }

        for (var i = 0; i < SpellModOp.max.getValue(); ++i) {
            spellModifiers[i] = new ArrayList<SpellModifier>[SpellModType.End.getValue()];

            for (var c = 0; c < SpellModType.End.getValue(); ++c) {
                spellModifiers[i][c] = new ArrayList<>();
            }
        }

        // Honor System
        lastHonorUpdateTime = gameTime.GetGameTime();

        setUnitMovedByMe(this);
        setPlayerMovingMe(this);
        setSeerView(this);

        m_isActive = true;
        setControlledByPlayer(true);

        global.getWorldMgr().increasePlayerCount();

        cinematicMgr = new CinematicManager(this);

        _AchievementSys = new PlayerAchievementMgr(this);
        reputationMgr = new ReputationMgr(this);
        questObjectiveCriteriaManager = new QuestObjectiveCriteriaManager(this);
        sceneMgr = new SceneMgr(this);

        _battlegroundQueueIdRecs[0] = new BgBattlegroundQueueIdRec();
        _battlegroundQueueIdRecs[1] = new BgBattlegroundQueueIdRec();

        bgData = new BgData();

        restMgr = new RestMgr(this);

        groupUpdateTimer = new timeTracker(5000);

        applyCustomConfigs();

        setObjectScale(1);
    }


    public static int getDefaultGossipMenuForSource(WorldObject source) {
        switch (source.getTypeId()) {
            case Unit:
                return source.toCreature().getGossipMenuId();
            case GameObject:
                return source.toGameObject().getGossipMenuId();
            default:
                break;
        }

        return 0;
    }


    public static byte getFactionGroupForRace(Race race) {
        var rEntry = CliDB.ChrRacesStorage.get((int) race.getValue());

        if (rEntry != null) {
            var faction = CliDB.FactionTemplateStorage.get(rEntry.factionID);

            if (faction != null) {
                return faction.factionGroup;
            }
        }

        return 1;
    }

    public static boolean isValidGender(Gender gender) {
        return gender.getValue() <= getGender().getValue().Female;
    }

    public static boolean isValidClass(PlayerClass _class) {
        return (boolean) ((1 << (_class.getValue() - 1)) & playerClass.ClassMaskAllPlayable.getValue());
    }

    public static boolean isValidRace(Race _race) {
        return (boolean) ((long) SharedConst.GetMaskForRace(_race) & SharedConst.RaceMaskAllPlayable);
    }

    public static void offlineResurrect(ObjectGuid guid, SQLTransaction trans) {
        Corpse.deleteFromDB(guid, trans);
        var stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_ADD_AT_LOGIN_FLAG);
        stmt.AddValue(0, (short) AtLoginFlags.Resurrect.getValue());
        stmt.AddValue(1, guid.getCounter());
        DB.characters.ExecuteOrAppend(trans, stmt);
    }

    //Team
    public static Team teamForRace(Race race) {
        switch (teamIdForRace(race)) {
            case 0:
                return Team.ALLIANCE;
            case 1:
                return Team.Horde;
        }

        return Team.ALLIANCE;
    }


    public static int teamIdForRace(Race race) {
        var rEntry = CliDB.ChrRacesStorage.get((byte) race.getValue());

        if (rEntry != null) {
            return (int) rEntry.Alliance;
        }

        Log.outError(LogFilter.player, "Race ({0}) not found in DBC: wrong DBC files?", race);

        return TeamIds.Neutral;
    }


    public static DrunkenState getDrunkenstateByValue(byte value) {
        if (value >= 90) {
            return DrunkenState.Smashed;
        }

        if (value >= 50) {
            return DrunkenState.drunk;
        }

        if (value != 0) {
            return DrunkenState.Tipsy;
        }

        return DrunkenState.Sober;
    }


    public static WeaponAttackType getAttackBySlot(byte slot, InventoryType inventoryType) {
        return switch (slot) {
            case EquipmentSlot.MainHand ->
                    inventoryType.getValue() != inventoryType.Ranged && inventoryType != inventoryType.RangedRight ? WeaponAttackType.BaseAttack :
                            WeaponAttackType.RangedAttack;
            case EquipmentSlot.OffHand -> WeaponAttackType.OffAttack.getValue();
            default -> WeaponAttackType.max.getValue();
        };
    }


    public static void savePlayerCustomizations(SQLTransaction trans, long guid, ArrayList<ChrCustomizationChoice> customizations) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_CUSTOMIZATIONS);
        stmt.AddValue(0, guid);
        trans.append(stmt);

        for (var customization : customizations) {
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_CUSTOMIZATION);
            stmt.AddValue(0, guid);
            stmt.AddValue(1, customization.chrCustomizationOptionID);
            stmt.AddValue(2, customization.chrCustomizationChoiceID);
            trans.append(stmt);
        }
    }


    public static void saveCustomizations(SQLTransaction trans, long guid, ArrayList<ChrCustomizationChoice> customizations) {
        savePlayerCustomizations(trans, guid, customizations);
    }


    public static int getZoneIdFromDB(ObjectGuid guid) {
        var guidLow = guid.getCounter();
        var stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_ZONE);
        stmt.AddValue(0, guidLow);
        var result = DB.characters.query(stmt);

        if (result.isEmpty()) {
            return 0;
        }

        int zone = result.<SHORT>Read(0);

        if (zone == 0) {
            // stored zone is zero, use generic and slow zone detection
            stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_POSITION_XYZ);
            stmt.AddValue(0, guidLow);
            result = DB.characters.query(stmt);

            if (result.isEmpty()) {
                return 0;
            }

            int map = result.<SHORT>Read(0);
            var posx = result.<Float>Read(1);
            var posy = result.<Float>Read(2);
            var posz = result.<Float>Read(3);

            if (!CliDB.MapStorage.containsKey(map)) {
                return 0;
            }

            zone = global.getTerrainMgr().getZoneId(PhasingHandler.EMPTY_PHASE_SHIFT, map, posx, posy, posz);

            if (zone > 0) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_ZONE);

                stmt.AddValue(0, zone);
                stmt.AddValue(1, guidLow);

                DB.characters.execute(stmt);
            }
        }

        return zone;
    }

    public static void removePetitionsAndSigns(ObjectGuid guid) {
        global.getPetitionMgr().removeSignaturesBySigner(guid);
        global.getPetitionMgr().removePetitionsByOwner(guid);
    }

    public static void deleteFromDB(ObjectGuid playerGuid, int accountId, boolean updateRealmChars) {
        deleteFromDB(playerGuid, accountId, updateRealmChars, false);
    }

    public static void deleteFromDB(ObjectGuid playerGuid, int accountId) {
        deleteFromDB(playerGuid, accountId, true, false);
    }

    public static void deleteFromDB(ObjectGuid playerGuid, int accountId, boolean updateRealmChars, boolean deleteFinally) {
        // Avoid realm-update for non-existing account
        if (accountId == 0) {
            updateRealmChars = false;
        }

        // Convert guid to low GUID for CharacterNameData, but also other methods on success
        var guid = playerGuid.getCounter();
        var charDelete_method = CharDeleteMethod.forValue(WorldConfig.getIntValue(WorldCfg.ChardeleteMethod));
        var characterInfo = global.getCharacterCacheStorage().getCharacterCacheByGuid(playerGuid);
        var name = "<unknown>";

        if (characterInfo != null) {
            name = characterInfo.name;
        }

        if (deleteFinally) {
            charDelete_method = CharDeleteMethod.Remove;
        } else if (characterInfo != null) // To avoid a Select, we select loaded data. If it doesn't exist, return.
        {
            // Define the required variables
            int charDeleteMinLvl;

            if (characterInfo.classId == playerClass.Deathknight) {
                charDeleteMinLvl = WorldConfig.getUIntValue(WorldCfg.ChardeleteDeathKnightMinLevel);
            } else if (characterInfo.classId == playerClass.DemonHunter) {
                charDeleteMinLvl = WorldConfig.getUIntValue(WorldCfg.ChardeleteDemonHunterMinLevel);
            } else {
                charDeleteMinLvl = WorldConfig.getUIntValue(WorldCfg.ChardeleteMinLevel);
            }

            // if we want to finalize the character removal or the character does not meet the level requirement of either heroic or non-heroic settings,
            // we set it to mode CHAR_DELETE_REMOVE
            if (characterInfo.level < charDeleteMinLvl) {
                charDelete_method = CharDeleteMethod.Remove;
            }
        }

        SQLTransaction trans = new SQLTransaction();
        SQLTransaction loginTransaction = new SQLTransaction();

        var guildId = global.getCharacterCacheStorage().getCharacterGuildIdByGuid(playerGuid);

        if (guildId != 0) {
            var guild = global.getGuildMgr().getGuildById(guildId);

            if (guild) {
                guild.deleteMember(trans, playerGuid, false, false, true);
            }
        }

        // remove from arena teams
        leaveAllArenaTeams(playerGuid);

        // the player was uninvited already on logout so just remove from group
        var stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_GROUP_MEMBER);
        stmt.AddValue(0, guid);
        var resultGroup = DB.characters.query(stmt);

        if (!resultGroup.isEmpty()) {
            var group = global.getGroupMgr().getGroupByDbStoreId(resultGroup.<Integer>Read(0));

            if (group) {
                removeFromGroup(group, playerGuid);
            }
        }

        // Remove signs from petitions (also remove petitions if owner);
        removePetitionsAndSigns(playerGuid);

        switch (charDelete_method) {
            // Completely remove from the database
            case Remove: {
                stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_COD_ITEM_MAIL);
                stmt.AddValue(0, guid);
                var resultMail = DB.characters.query(stmt);

                if (!resultMail.isEmpty()) {
                    MultiMap<Long, item> itemsByMail = new MultiMap<Long, item>();

                    stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_MAILITEMS);
                    stmt.AddValue(0, guid);
                    var resultItems = DB.characters.query(stmt);

                    if (!resultItems.isEmpty()) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_MAILITEMS_ARTIFACT);
                        stmt.AddValue(0, guid);
                        var artifactResult = DB.characters.query(stmt);

                        stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_MAILITEMS_AZERITE);
                        stmt.AddValue(0, guid);
                        var azeriteResult = DB.characters.query(stmt);

                        stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_MAILITEMS_AZERITE_MILESTONE_POWER);
                        stmt.AddValue(0, guid);
                        var azeriteItemMilestonePowersResult = DB.characters.query(stmt);

                        stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_MAILITEMS_AZERITE_UNLOCKED_ESSENCE);
                        stmt.AddValue(0, guid);
                        var azeriteItemUnlockedEssencesResult = DB.characters.query(stmt);

                        stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_MAILITEMS_AZERITE_EMPOWERED);
                        stmt.AddValue(0, guid);
                        var azeriteEmpoweredItemResult = DB.characters.query(stmt);

                        HashMap<Long, ItemAdditionalLoadInfo> additionalData = new HashMap<Long, ItemAdditionalLoadInfo>();
                        ItemAdditionalLoadInfo.init(additionalData, artifactResult, azeriteResult, azeriteItemMilestonePowersResult, azeriteItemUnlockedEssencesResult, azeriteEmpoweredItemResult);

                        do {
                            var mailId = resultItems.<Long>Read(52);
                            var mailItem = _LoadMailedItem(playerGuid, null, mailId, null, resultItems.GetFields(), additionalData.get(resultItems.<Long>Read(0)));

                            if (mailItem != null) {
                                itemsByMail.add(mailId, mailItem);
                            }
                        } while (resultItems.NextRow());
                    }

                    do {
                        var mail_id = resultMail.<Long>Read(0);
                        var mailType = MailMessageType.forValue(resultMail.<Byte>Read(1));
                        var mailTemplateId = resultMail.<SHORT>Read(2);
                        var sender = resultMail.<Integer>Read(3);
                        var subject = resultMail.<String>Read(4);
                        var body = resultMail.<String>Read(5);
                        var money = resultMail.<Long>Read(6);
                        var has_items = resultMail.<Boolean>Read(7);

                        // We can return mail now
                        // So firstly delete the old one
                        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_BY_ID);
                        stmt.AddValue(0, mail_id);
                        trans.append(stmt);

                        // Mail is not from player
                        if (mailType != MailMessageType.NORMAL) {
                            if (has_items) {
                                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_ITEM_BY_ID);
                                stmt.AddValue(0, mail_id);
                                trans.append(stmt);
                            }

                            continue;
                        }

                        MailDraft draft = new MailDraft(subject, body);

                        if (mailTemplateId != 0) {
                            draft = new MailDraft(mailTemplateId, false); // items are already included
                        }

                        var itemsList = itemsByMail.get(mail_id);

                        if (itemsList != null) {
                            for (var item : itemsList) {
                                draft.addItem(item);
                            }

                            itemsByMail.remove(mail_id);
                        }

                        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_ITEM_BY_ID);
                        stmt.AddValue(0, mail_id);
                        trans.append(stmt);

                        var pl_account = global.getCharacterCacheStorage().getCharacterAccountIdByGuid(ObjectGuid.create(HighGuid.Player, guid));

                        draft.addMoney(money).sendReturnToSender(pl_account, guid, sender, trans);
                    } while (resultMail.NextRow());

                    // Free remaining items
                    for (var pair : itemsByMail.KeyValueList) {
                        pair.value.dispose();
                    }
                }

                // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
                // NOW we can finally clear other DB data related to character
                stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_PET_IDS);
                stmt.AddValue(0, guid);
                var resultPets = DB.characters.query(stmt);

                if (!resultPets.isEmpty()) {
                    do {
                        var petguidlow = resultPets.<Integer>Read(0);
                        pet.deleteFromDB(petguidlow);
                    } while (resultPets.NextRow());
                }

                // Delete char from social list of online chars
                stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_SOCIAL);
                stmt.AddValue(0, guid);
                var resultFriends = DB.characters.query(stmt);

                if (!resultFriends.isEmpty()) {
                    do {
                        var playerFriend = global.getObjAccessor().findPlayer(ObjectGuid.create(HighGuid.Player, resultFriends.<Long>Read(0)));

                        if (playerFriend) {
                            playerFriend.getSocial().removeFromSocialList(playerGuid, SocialFlag.All);
                            global.getSocialMgr().sendFriendStatus(playerFriend, FriendsResult.removed, playerGuid);
                        }
                    } while (resultFriends.NextRow());
                }

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_CUSTOMIZATIONS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_PLAYER_ACCOUNT_DATA);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_DECLINED_NAME);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_ACTION);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_ARENA_STATS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_AURA_EFFECT);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_AURA);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_PLAYER_BGDATA);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_BATTLEGROUND_RANDOM);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_CUF_PROFILES);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_PLAYER_CURRENCY);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_GIFT);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_PLAYER_HOMEBIND);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_INSTANCE_LOCK_BY_GUID);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_INVENTORY);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS_OBJECTIVES);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS_REWARDED);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_REPUTATION);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SPELL);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SPELL_COOLDOWNS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_GEMS_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_TRANSMOG_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_ARTIFACT_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_ARTIFACT_POWERS_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_MODIFIERS_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_AZERITE_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_AZERITE_MILESTONE_POWER_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_AZERITE_UNLOCKED_ESSENCE_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_AZERITE_EMPOWERED_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_INSTANCE_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SOCIAL_BY_FRIEND);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SOCIAL_BY_GUID);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_ITEMS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_PET_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_ACHIEVEMENTS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_ACHIEVEMENT_PROGRESS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_EQUIPMENTSETS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRANSMOG_OUTFITS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_GUILD_EVENTLOG_BY_PLAYER);
                stmt.AddValue(0, guid);
                stmt.AddValue(1, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_GLYPHS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_DAILY);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_WEEKLY);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_MONTHLY);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_SEASONAL);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TALENT);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SKILLS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_STATS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_VOID_STORAGE_ITEM_BY_CHAR_GUID);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_FISHINGSTEPS);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_FAVORITE_AUCTIONS_BY_CHAR);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_AURA_STORED_LOCATIONS_BY_GUID);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.Login.GetPreparedStatement(LoginStatements.DEL_BATTLE_PET_DECLINED_NAME_BY_OWNER);
                stmt.AddValue(0, guid);
                stmt.AddValue(1, global.getWorldMgr().getRealmId().index);
                loginTransaction.append(stmt);

                stmt = DB.Login.GetPreparedStatement(LoginStatements.DEL_BATTLE_PETS_BY_OWNER);
                stmt.AddValue(0, guid);
                stmt.AddValue(1, global.getWorldMgr().getRealmId().index);
                loginTransaction.append(stmt);

                Corpse.deleteFromDB(playerGuid, trans);

                Garrison.deleteFromDB(guid, trans);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRAIT_ENTRIES_BY_CHAR);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRAIT_CONFIGS_BY_CHAR);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                global.getCharacterCacheStorage().deleteCharacterCacheEntry(playerGuid, name);

                break;
            }
            // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
            case Unlink: {
                stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_DELETE_INFO);
                stmt.AddValue(0, guid);
                trans.append(stmt);

                global.getCharacterCacheStorage().updateCharacterInfoDeleted(playerGuid, true);

                break;
            }
            default:
                Log.outError(LogFilter.player, "Player:DeleteFromDB: Unsupported delete method: {0}.", charDelete_method);

                if (trans.commands.count > 0) {
                    DB.characters.CommitTransaction(trans);
                }

                return;
        }

        DB.Login.CommitTransaction(loginTransaction);
        DB.characters.CommitTransaction(trans);

        if (updateRealmChars) {
            global.getWorldMgr().updateRealmCharCount(accountId);
        }
    }

    public static void deleteOldCharacters() {
        var keepDays = WorldConfig.getIntValue(WorldCfg.ChardeleteKeepDays);

        if (keepDays == 0) {
            return;
        }

        deleteOldCharacters(keepDays);
    }

    public static void deleteOldCharacters(int keepDays) {
        Log.outInfo(LogFilter.player, "Player:DeleteOldChars: Deleting all character which have been deleted {0} days before...", keepDays);

        var stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_OLD_CHARS);
        stmt.AddValue(0, (int) (gameTime.GetGameTime() - keepDays * time.Day));
        var result = DB.characters.query(stmt);

        if (!result.isEmpty()) {
            var count = 0;

            do {
                deleteFromDB(ObjectGuid.create(HighGuid.Player, result.<Long>Read(0)), result.<Integer>Read(1), true, true);
                count++;
            } while (result.NextRow());

            Log.outDebug(LogFilter.player, "Player:DeleteOldChars: Deleted {0} character(s)", count);
        }
    }

    public static void savePositionInDB(WorldLocation loc, int zoneId, ObjectGuid guid) {
        savePositionInDB(loc, zoneId, guid, null);
    }

    public static void savePositionInDB(WorldLocation loc, int zoneId, ObjectGuid guid, SQLTransaction trans) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_CHARACTER_POSITION);
        stmt.AddValue(0, loc.getX());
        stmt.AddValue(1, loc.getY());
        stmt.AddValue(2, loc.getZ());
        stmt.AddValue(3, loc.getO());
        stmt.AddValue(4, (short) loc.getMapId());
        stmt.AddValue(5, zoneId);
        stmt.AddValue(6, guid.getCounter());

        DB.characters.ExecuteOrAppend(trans, stmt);
    }

    public static boolean loadPositionFromDB(tangible.OutObject<WorldLocation> loc, tangible.OutObject<Boolean> inFlight, ObjectGuid guid) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHAR_POSITION);
        stmt.AddValue(0, guid.getCounter());
        var result = DB.characters.query(stmt);

        loc.outArgValue = new worldLocation();
        inFlight.outArgValue = false;

        if (result.isEmpty()) {
            return false;
        }

        loc.outArgValue.setX(result.<Float>Read(0));
        loc.outArgValue.setY(result.<Float>Read(1));
        loc.outArgValue.setZ(result.<Float>Read(2));
        loc.outArgValue.setO(result.<Float>Read(3));
        loc.outArgValue.setMapId(result.<SHORT>Read(4));
        inFlight.outArgValue = !StringUtil.isEmpty(result.<String>Read(5));

        return true;
    }


    private static Item _LoadMailedItem(ObjectGuid playerGuid, Player player, long mailId, Mail mail, SQLFields fields, ItemAdditionalLoadInfo addionalData) {
        var itemGuid = fields.<Long>Read(0);
        var itemEntry = fields.<Integer>Read(1);

        var proto = global.getObjectMgr().getItemTemplate(itemEntry);

        if (proto == null) {
            Log.outError(LogFilter.player, String.format("Player %1$s (%2$s) has unknown item in mailed items (GUID: %3$s template: %4$s) in mail (%5$s), deleted.", (player != null ? player.getName() : "<unknown>"), playerGuid, itemGuid, itemEntry, mailId));

            SQLTransaction trans = new SQLTransaction();

            var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_INVALID_MAIL_ITEM);
            stmt.AddValue(0, itemGuid);
            trans.append(stmt);

            item.deleteFromDB(trans, itemGuid);
            azeriteItem.deleteFromDB(trans, itemGuid);
            azeriteEmpoweredItem.deleteFromDB(trans, itemGuid);

            DB.characters.CommitTransaction(trans);

            return null;
        }

        var item = item.newItemOrBag(proto);
        var ownerGuid = fields.<Long>Read(51) != 0 ? ObjectGuid.create(HighGuid.Player, fields.<Long>Read(51)) : ObjectGuid.Empty;

        if (!item.loadFromDB(itemGuid, ownerGuid, fields, itemEntry)) {
            Log.outError(LogFilter.player, String.format("Player._LoadMailedItems: item (GUID: %1$s) in mail (%2$s) doesn't exist, deleted from mail.", itemGuid, mailId));

            var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_ITEM);
            stmt.AddValue(0, itemGuid);
            DB.characters.execute(stmt);

            item.FSetState(ItemUpdateState.removed);

            item.saveToDB(null); // it also deletes item object !

            return null;
        }

        if (addionalData != null) {
            if (item.getTemplate().getArtifactID() != 0 && addionalData.artifact != null) {
                item.loadArtifactData(player, addionalData.artifact.xp, addionalData.artifact.artifactAppearanceId, addionalData.artifact.artifactTierId, addionalData.artifact.artifactPowers);
            }

            if (addionalData.azeriteItem != null) {
                var azeriteItem = item.getAsAzeriteItem();

                if (azeriteItem != null) {
                    azeriteItem.LoadAzeriteItemData(player, addionalData.azeriteItem);
                }
            }

            if (addionalData.azeriteEmpoweredItem != null) {
                var azeriteEmpoweredItem = item.getAsAzeriteEmpoweredItem();

                if (azeriteEmpoweredItem != null) {
                    azeriteEmpoweredItem.LoadAzeriteEmpoweredItemData(player, addionalData.azeriteEmpoweredItem);
                }
            }
        }

        if (mail != null) {
            mail.addItem(itemGuid, itemEntry);
        }

        if (player != null) {
            player.addMItem(item);
        }

        return item;
    }

    public static void removeFromGroup(PlayerGroup group, ObjectGuid guid, RemoveMethod method, ObjectGuid kicker) {
        removeFromGroup(group, guid, method, kicker, null);
    }

    public static void removeFromGroup(PlayerGroup group, ObjectGuid guid, RemoveMethod method) {
        removeFromGroup(group, guid, method, null, null);
    }

    public static void removeFromGroup(PlayerGroup group, ObjectGuid guid) {
        removeFromGroup(group, guid, RemoveMethod.Default, null, null);
    }

    public static void removeFromGroup(PlayerGroup group, ObjectGuid guid, RemoveMethod method, ObjectGuid kicker, String reason) {
        if (!group) {
            return;
        }

        group.removeMember(guid, method, kicker, reason);
    }


    public static boolean isChildEquipmentPos(byte bag, byte slot) {
        return bag == InventorySlots.Bag0 && (slot >= InventorySlots.ChildEquipmentStart && slot < InventorySlots.ChildEquipmentEnd);
    }


    public static boolean isInventoryPos(byte bag, byte slot) {
        if (bag == InventorySlots.Bag0 && slot == ItemConst.NullSlot) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ItemStart && slot < InventorySlots.ItemEnd)) {
            return true;
        }

        if (bag >= InventorySlots.BagStart && bag < InventorySlots.BagEnd) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ReagentStart && slot < InventorySlots.ReagentEnd)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ChildEquipmentStart && slot < InventorySlots.ChildEquipmentEnd)) {
            return true;
        }

        return false;
    }

    //Bank
    public static boolean isBankPos(short pos) {
        return isBankPos((byte) (pos >>> 8), (byte) (pos & 255));
    }


    public static boolean isBankPos(byte bag, byte slot) {
        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.BankItemStart && slot < InventorySlots.BankItemEnd)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.BankBagStart && slot < InventorySlots.BankBagEnd)) {
            return true;
        }

        if (bag >= InventorySlots.BankBagStart && bag < InventorySlots.BankBagEnd) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ReagentStart && slot < InventorySlots.ReagentEnd)) {
            return true;
        }

        return false;
    }

    //Reagent
    public static boolean isReagentBankPos(short pos) {
        return isReagentBankPos((byte) (pos >>> 8), (byte) (pos & 255));
    }


    public static boolean isReagentBankPos(byte bag, byte slot) {
        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ReagentStart && slot < InventorySlots.ReagentEnd)) {
            return true;
        }

        return false;
    }


    public static boolean isBagPos(short pos) {
        var bag = (byte) (pos >>> 8);
        var slot = (byte) (pos & 255);

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.BagStart && slot < InventorySlots.BagEnd)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.BankBagStart && slot < InventorySlots.BankBagEnd)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ReagentBagStart && slot < InventorySlots.ReagentBagEnd)) {
            return true;
        }

        return false;
    }

    //Equipment
    public static boolean isEquipmentPos(short pos) {
        return isEquipmentPos((byte) (pos >>> 8), (byte) (pos & 255));
    }


    public static boolean isEquipmentPos(byte bag, byte slot) {
        if (bag == InventorySlots.Bag0 && (slot < EquipmentSlot.End)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= ProfessionSlots.start && slot < ProfessionSlots.End)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.BagStart && slot < InventorySlots.BagEnd)) {
            return true;
        }

        if (bag == InventorySlots.Bag0 && (slot >= InventorySlots.ReagentBagStart && slot < InventorySlots.ReagentBagEnd)) {
            return true;
        }

        return false;
    }

    //Child
    public static boolean isChildEquipmentPos(short pos) {
        return isChildEquipmentPos((byte) (pos >>> 8), (byte) (pos & 255));
    }

    public static Difficulty checkLoadedDungeonDifficultyId(Difficulty difficulty) {
        var difficultyEntry = CliDB.DifficultyStorage.get(difficulty);

        if (difficultyEntry == null) {
            return Difficulty.NORMAL;
        }

        if (difficultyEntry.instanceType != MapTypes.instance) {
            return Difficulty.NORMAL;
        }

        if (!difficultyEntry.flags.hasFlag(DifficultyFlags.CanSelect)) {
            return Difficulty.NORMAL;
        }

        return difficulty;
    }

    //Repitation

    public static Difficulty checkLoadedRaidDifficultyId(Difficulty difficulty) {
        var difficultyEntry = CliDB.DifficultyStorage.get(difficulty);

        if (difficultyEntry == null) {
            return Difficulty.NormalRaid;
        }

        if (difficultyEntry.instanceType != MapTypes.raid) {
            return Difficulty.NormalRaid;
        }

        if (!difficultyEntry.flags.hasFlag(DifficultyFlags.CanSelect) || difficultyEntry.flags.hasFlag(DifficultyFlags.legacy)) {
            return Difficulty.NormalRaid;
        }

        return difficulty;
    }

    public static Difficulty checkLoadedLegacyRaidDifficultyId(Difficulty difficulty) {
        var difficultyEntry = CliDB.DifficultyStorage.get(difficulty);

        if (difficultyEntry == null) {
            return Difficulty.Raid10N;
        }

        if (difficultyEntry.instanceType != MapTypes.raid) {
            return Difficulty.Raid10N;
        }

        if (!difficultyEntry.flags.hasFlag(DifficultyFlags.CanSelect) || !difficultyEntry.flags.hasFlag(DifficultyFlags.legacy)) {
            return Difficulty.Raid10N;
        }

        return difficulty;
    }

    public static void leaveAllArenaTeams(ObjectGuid guid) {
        var characterInfo = global.getCharacterCacheStorage().getCharacterCacheByGuid(guid);

        if (characterInfo == null) {
            return;
        }

        for (byte i = 0; i < SharedConst.MaxArenaSlot; ++i) {
            var arenaTeamId = characterInfo.ArenaTeamId[i];

            if (arenaTeamId != 0) {
                var arenaTeam = global.getArenaTeamMgr().getArenaTeamById(arenaTeamId);

                if (arenaTeam != null) {
                    arenaTeam.delMember(guid, true);
                }
            }
        }
    }


    public final int getAchievementPoints() {
        return _AchievementSys.getAchievementPoints();
    }


    public final Collection<Integer> getCompletedAchievementIds() {
        return _AchievementSys.getCompletedAchievementIds();
    }

    public final void resetAchievements() {
        _AchievementSys.reset();
    }

    public final void sendRespondInspectAchievements(Player player) {
        _AchievementSys.sendAchievementInfo(player);
    }


    public final boolean hasAchieved(int achievementId) {
        return _AchievementSys.hasAchieved(achievementId);
    }

    public final void startCriteriaTimer(CriteriaStartEvent startEvent, int entry) {
        startCriteriaTimer(startEvent, entry, 0);
    }

    public final void startCriteriaTimer(CriteriaStartEvent startEvent, int entry, int timeLost) {
        _AchievementSys.startCriteriaTimer(startEvent, entry, timeLost);
    }


    public final void removeCriteriaTimer(CriteriaStartEvent startEvent, int entry) {
        _AchievementSys.removeCriteriaTimer(startEvent, entry);
    }

    public final void resetCriteria(CriteriaFailEvent failEvent, int failAsset) {
        resetCriteria(failEvent, failAsset, false);
    }

    public final void resetCriteria(CriteriaFailEvent failEvent, int failAsset, boolean evenIfCriteriaComplete) {
        _AchievementSys.resetCriteria(failEvent, failAsset, evenIfCriteriaComplete);
        questObjectiveCriteriaManager.resetCriteria(failEvent, failAsset, evenIfCriteriaComplete);
    }

    public final void updateCriteria(CriteriaType type, double miscValue1, double miscValue2, double miscValue3) {
        updateCriteria(type, miscValue1, miscValue2, miscValue3, null);
    }

    public final void updateCriteria(CriteriaType type, double miscValue1, double miscValue2) {
        updateCriteria(type, miscValue1, miscValue2, 0, null);
    }

    public final void updateCriteria(CriteriaType type, double miscValue1) {
        updateCriteria(type, miscValue1, 0, 0, null);
    }

    public final void updateCriteria(CriteriaType type, double miscValue1, double miscValue2, double miscValue3, WorldObject refe) {
        updateCriteria(type, (long) miscValue1, (long) miscValue2, (long) miscValue3, refe);
    }

    public final void updateCriteria(CriteriaType type, long miscValue1, long miscValue2, long miscValue3) {
        updateCriteria(type, miscValue1, miscValue2, miscValue3, null);
    }

    public final void updateCriteria(CriteriaType type, long miscValue1, long miscValue2) {
        updateCriteria(type, miscValue1, miscValue2, 0, null);
    }

    public final void updateCriteria(CriteriaType type, long miscValue1) {
        updateCriteria(type, miscValue1, 0, 0, null);
    }

    public final void updateCriteria(CriteriaType type) {
        updateCriteria(type, 0, 0, 0, null);
    }

    public final void updateCriteria(CriteriaType type, long miscValue1, long miscValue2, long miscValue3, WorldObject refe) {
        _AchievementSys.updateCriteria(type, miscValue1, miscValue2, miscValue3, refe, this);
        questObjectiveCriteriaManager.updateCriteria(type, miscValue1, miscValue2, miscValue3, refe, this);

        // Update only individual achievement criteria here, otherwise we may get multiple updates
        // from a single boss kill
        if (CriteriaManager.isGroupCriteriaType(type)) {
            return;
        }

        var scenario = getScenario();

        if (scenario != null) {
            scenario.updateCriteria(type, miscValue1, miscValue2, miscValue3, refe, this);
        }

        var guild = global.getGuildMgr().getGuildById(getGuildId());

        if (guild) {
            guild.updateCriteria(type, miscValue1, miscValue2, miscValue3, refe, this);
        }
    }

    public final void completedAchievement(AchievementRecord entry) {
        _AchievementSys.completedAchievement(entry, this);
    }


    public final boolean modifierTreeSatisfied(int modifierTreeId) {
        return _AchievementSys.modifierTreeSatisfied(modifierTreeId);
    }


    public final void rewardPlayerAndGroupAtEvent(int creature_id, WorldObject pRewardSource) {
        if (pRewardSource == null) {
            return;
        }

        var creature_guid = pRewardSource.isTypeId(TypeId.UNIT) ? pRewardSource.getGUID() : ObjectGuid.Empty;

        // prepare data for near group iteration
        var group = getGroup();

        if (group) {
            for (var refe = group.getFirstMember(); refe != null; refe = refe.next()) {
                var player = refe.getSource();

                if (!player) {
                    continue;
                }

                if (!player.isAtGroupRewardDistance(pRewardSource)) {
                    continue; // member (alive or dead) or his corpse at req. distance
                }

                // quest objectives updated only for alive group member or dead but with not released body
                if (player.isAlive() || !player.getCorpse()) {
                    player.killedMonsterCredit(creature_id, creature_guid);
                }
            }
        } else {
            killedMonsterCredit(creature_id, creature_guid);
        }
    }


    public final void addWeaponProficiency(int newflag) {
        weaponProficiency |= newflag;
    }


    public final void addArmorProficiency(int newflag) {
        armorProficiency |= newflag;
    }


    public final int getWeaponProficiency() {
        return weaponProficiency;
    }

    //Chat - Text - Channel


    public final int getArmorProficiency() {
        return armorProficiency;
    }


    public final void sendProficiency(ItemClass itemClass, int itemSubclassMask) {
        SetProficiency packet = new SetProficiency();
        packet.proficiencyMask = itemSubclassMask;
        packet.proficiencyClass = (byte) itemClass.getValue();
        sendPacket(packet);
    }

    public final double getRatingBonusValue(CombatRating cr) {
        var baseResult = applyRatingDiminishing(cr, getActivePlayerData().combatRatings.get(cr.getValue()) * getRatingMultiplier(cr));

        if (cr != CombatRating.ResiliencePlayerDamage) {
            return baseResult;
        }

        return (1.0f - Math.pow(0.99f, baseResult)) * 100.0f;
    }

    public final float getExpertiseDodgeOrParryReduction(WeaponAttackType attType) {
        var baseExpertise = 7.5f;

        switch (attType) {
            case BaseAttack:
                return baseExpertise + getActivePlayerData().MainhandExpertise / 4.0f;
            case OffAttack:
                return baseExpertise + getActivePlayerData().OffhandExpertise / 4.0f;
            default:
                break;
        }

        return 0.0f;
    }

    public final boolean isUseEquipedWeapon(boolean mainhand) {
        // disarm applied only to mainhand weapon
        return !isInFeralForm() && (!mainhand || !hasUnitFlag(UnitFlag.Disarmed));
    }

    public final void setCanTitanGrip(boolean value) {
        setCanTitanGrip(value, 0);
    }

    public final void setCanTitanGrip(boolean value, int penaltySpellId) {
        if (value == canTitanGrip) {
            return;
        }

        canTitanGrip = value;
        titanGripPenaltySpellId = penaltySpellId;
    }


    public final void _ApplyWeaponDamage(byte slot, Item item, boolean apply) {
        var proto = item.getTemplate();
        var attType = getAttackBySlot(slot, proto.getInventoryType());

        if (!isInFeralForm() && apply && !canUseAttackType(attType)) {
            return;
        }

        var damage = 0.0f;
        var itemLevel = item.getItemLevel(this);
        float minDamage;
        tangible.OutObject<Float> tempOut_minDamage = new tangible.OutObject<Float>();
        float maxDamage;
        tangible.OutObject<Float> tempOut_maxDamage = new tangible.OutObject<Float>();
        proto.getDamage(itemLevel, tempOut_minDamage, tempOut_maxDamage);
        maxDamage = tempOut_maxDamage.outArgValue;
        minDamage = tempOut_minDamage.outArgValue;

        if (minDamage > 0) {
            damage = apply ? minDamage : SharedConst.BaseMinDamage;
            setBaseWeaponDamage(attType, WeaponDamageRange.minDamage, damage);
        }

        if (maxDamage > 0) {
            damage = apply ? maxDamage : SharedConst.BaseMaxDamage;
            setBaseWeaponDamage(attType, WeaponDamageRange.maxDamage, damage);
        }

        var shapeshift = CliDB.SpellShapeshiftFormStorage.get(getShapeshiftForm());

        if (proto.getDelay() != 0 && !(shapeshift != null && shapeshift.CombatRoundTime != 0)) {
            setBaseAttackTime(attType, apply ? proto.getDelay() : SharedConst.baseAttackTime);
        }

        var weaponBasedAttackPower = apply ? (int) (proto.getDPS(itemLevel) * 6.0f) : 0;

        switch (attType) {
            case BaseAttack:
                setMainHandWeaponAttackPower(weaponBasedAttackPower);

                break;
            case OffAttack:
                setOffHandWeaponAttackPower(weaponBasedAttackPower);

                break;
            case RangedAttack:
                setRangedWeaponAttackPower(weaponBasedAttackPower);

                break;
        }

        if (canModifyStats() && (damage != 0 || proto.getDelay() != 0)) {
            updateDamagePhysical(attType);
        }
    }

    @Override
    public void atEnterCombat() {
        super.atEnterCombat();

        if (getCombatManager().hasPvPCombat()) {
            enablePvpRules(true);
        }
    }

    @Override
    public void atExitCombat() {
        super.atExitCombat();
        updatePotionCooldown();
        combatExitTime = System.currentTimeMillis();
    }


    @Override
    public float getBlockPercent(int attackerLevel) {
        var blockArmor = (float) getActivePlayerData().shieldBlock;
        var armorConstant = global.getDB2Mgr().EvaluateExpectedStat(ExpectedStatType.ArmorConstant, attackerLevel, -2, 0, playerClass.NONE);

        if ((blockArmor + armorConstant) == 0) {
            return 0;
        }

        return Math.min(blockArmor / (blockArmor + armorConstant), 0.85f);
    }

    // duel health and mana reset methods
    public final void saveHealthBeforeDuel() {
        healthBeforeDuel = (int) getHealth();
    }

    public final void saveManaBeforeDuel() {
        manaBeforeDuel = (int) getPower(powerType.mana);
    }

    public final void restoreHealthAfterDuel() {
        setHealth(healthBeforeDuel);
    }

    public final void restoreManaAfterDuel() {
        setPower(powerType.mana, (int) manaBeforeDuel);
    }

    public final void duelComplete(DuelCompleteType type) {
        // duel not requested
        if (getDuel() == null) {
            return;
        }

        // Check if duelComplete() has been called already up in the stack and in that case don't do anything else here
        if (getDuel().getState() == DuelState.completed) {
            return;
        }

        var opponent = getDuel().getOpponent();
        getDuel().setState(DuelState.completed);
        opponent.getDuel().setState(DuelState.completed);

        Log.outDebug(LogFilter.player, String.format("Duel Complete %1$s %2$s", getName(), opponent.getName()));

        DuelComplete duelCompleted = new duelComplete();
        duelCompleted.started = type != DuelCompleteType.Interrupted;
        sendPacket(duelCompleted);

        if (opponent.getSession() != null) {
            opponent.sendPacket(duelCompleted);
        }

        if (type != DuelCompleteType.Interrupted) {
            DuelWinner duelWinner = new DuelWinner();
            duelWinner.beatenName = (type == DuelCompleteType.Won ? opponent.getName() : getName());
            duelWinner.winnerName = (type == DuelCompleteType.Won ? getName() : opponent.getName());
            duelWinner.beatenVirtualRealmAddress = global.getWorldMgr().getVirtualRealmAddress();
            duelWinner.winnerVirtualRealmAddress = global.getWorldMgr().getVirtualRealmAddress();
            duelWinner.fled = type != DuelCompleteType.Won;

            sendMessageToSet(duelWinner, true);
        }

        opponent.disablePvpRules();
        disablePvpRules();

        global.getScriptMgr().<IPlayerOnDuelEnd>ForEach(p -> p.OnDuelEnd(type == DuelCompleteType.Won ? this : opponent, type == DuelCompleteType.Won ? opponent : this, type));

        switch (type) {
            case Fled:
                // if initiator and opponent are on the same team
                // or initiator and opponent are not PvP enabled, forcibly stop attacking
                if (getTeam() == opponent.getTeam()) {
                    attackStop();
                    opponent.attackStop();
                } else {
                    if (!isPvP()) {
                        attackStop();
                    }

                    if (!opponent.isPvP()) {
                        opponent.attackStop();
                    }
                }

                break;
            case Won:
                updateCriteria(CriteriaType.LoseDuel, 1);
                opponent.updateCriteria(CriteriaType.WinDuel, 1);

                // Credit for quest Death's Challenge
                if (getClass() == playerClass.Deathknight && opponent.getQuestStatus(12733) == QuestStatus.INCOMPLETE) {
                    opponent.castSpell(getDuel().getOpponent(), 52994, true);
                }

                // Honor points after duel (the winner) - ImpConfig
                var amount = WorldConfig.getIntValue(WorldCfg.HonorAfterDuel);

                if (amount != 0) {
                    opponent.rewardHonor(null, 1, amount);
                }

                break;
        }

        // Victory emote spell
        if (type != DuelCompleteType.Interrupted) {
            opponent.castSpell(getDuel().getOpponent(), 52852, true);
        }

        //Remove Duel Flag object
        var obj = getMap().getGameObject(getPlayerData().duelArbiter);

        if (obj) {
            getDuel().getInitiator().removeGameObject(obj, true);
        }

        //remove auras
        opponent.getAppliedAurasQuery().hasCasterGuid(getGUID()).isPositive(false).alsoMatches(appAur -> appAur.base.applyTime >= getDuel().getStartTime()).execute(this::RemoveAura);
        getAppliedAurasQuery().hasCasterGuid(opponent.getGUID()).isPositive(false).alsoMatches(appAur -> appAur.base.applyTime >= getDuel().getStartTime()).execute(this::RemoveAura);

        // cleanup combo points
        clearComboPoints();
        opponent.clearComboPoints();

        //cleanups
        setDuelArbiter(ObjectGuid.Empty);
        setDuelTeam(0);
        opponent.setDuelArbiter(ObjectGuid.Empty);
        opponent.setDuelTeam(0);

        opponent.setDuel(null);
        setDuel(null);
    }

    public final void setDuelArbiter(ObjectGuid guid) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().duelArbiter), guid);
    }

    //PVP
    public final void setPvPDeath(boolean on) {
        if (on) {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.PVPDeath.getValue());
        } else {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() & ~PlayerExtraFlags.PVPDeath.getValue());
        }
    }

    public final void setContestedPvPTimer(int newTime) {
        contestedPvPTimer = newTime;
    }

    public final void resetContestedPvP() {
        clearUnitState(UnitState.AttackPlayer);
        removePlayerFlag(playerFlags.ContestedPVP);
        contestedPvPTimer = 0;
    }

    public final void setContestedPvP() {
        setContestedPvP(null);
    }

    public final void setContestedPvP(Player attackedPlayer) {
        if (attackedPlayer != null && (attackedPlayer == this || (getDuel() != null && getDuel().getOpponent() == attackedPlayer))) {
            return;
        }

        setContestedPvPTimer(30000);

        if (!hasUnitState(UnitState.AttackPlayer)) {
            addUnitState(UnitState.AttackPlayer);
            setPlayerFlag(playerFlags.ContestedPVP);
            // call MoveInLineOfSight for nearby contested guards
            AIRelocationNotifier notifier = new AIRelocationNotifier(this, gridType.World);
            Cell.visitGrid(this, notifier, getVisibilityRange());
        }

        for (var unit : getControlled()) {
            if (!unit.hasUnitState(UnitState.AttackPlayer)) {
                unit.addUnitState(UnitState.AttackPlayer);
                AIRelocationNotifier notifier = new AIRelocationNotifier(unit, gridType.World);
                Cell.visitGrid(this, notifier, getVisibilityRange());
            }
        }
    }

    public final void updateContestedPvP(int diff) {
        if (contestedPvPTimer == 0 || isInCombat()) {
            return;
        }

        if (contestedPvPTimer <= diff) {
            resetContestedPvP();
        } else {
            _contestedPvPTimer -= diff;
        }
    }

    public final void updatePvPFlag(long currTime) {
        if (!isPvP()) {
            return;
        }

        if (pvpInfo.endTimer == 0 || (currTime < pvpInfo.endTimer + 300) || pvpInfo.isHostile) {
            return;
        }

        if (pvpInfo.endTimer <= currTime) {
            pvpInfo.endTimer = 0;
            removePlayerFlag(playerFlags.PVPTimer);
        }

        updatePvP(false);
    }

    public final void updatePvP(boolean state) {
        updatePvP(state, false);
    }

    public final void updatePvP(boolean state, boolean override) {
        if (!state || override) {
            setPvP(state);
            pvpInfo.endTimer = 0;
        } else {
            pvpInfo.endTimer = gameTime.GetGameTime();
            setPvP(state);
        }
    }

    public final void updatePvPState() {
        updatePvPState(false);
    }

    public final void updatePvPState(boolean onlyFfa) {
        // @todo should we always synchronize UNIT_FIELD_BYTES_2, 1 of controller and controlled?
        // no, we shouldn't, those are checked for affecting player by client
        if (!pvpInfo.isInNoPvPArea && !isGameMaster() && (pvpInfo.isInFfaPvPArea || global.getWorldMgr().isFFAPvPRealm() || hasAuraType(AuraType.SetFFAPvp))) {
            if (!isFFAPvP()) {
                setPvpFlag(UnitPVPStateFlags.FFAPvp);

                for (var unit : getControlled()) {
                    unit.setPvpFlag(UnitPVPStateFlags.FFAPvp);
                }
            }
        } else if (isFFAPvP()) {
            removePvpFlag(UnitPVPStateFlags.FFAPvp);

            for (var unit : getControlled()) {
                unit.removePvpFlag(UnitPVPStateFlags.FFAPvp);
            }
        }

        if (onlyFfa) {
            return;
        }

        if (pvpInfo.isHostile) // in hostile area
        {
            if (!isPvP() || pvpInfo.endTimer != 0) {
                updatePvP(true, true);
            }
        } else // in friendly area
        {
            if (isPvP() && !hasPlayerFlag(playerFlags.InPVP) && pvpInfo.endTimer == 0) {
                pvpInfo.endTimer = gameTime.GetGameTime(); // start toggle-off
            }
        }
    }

    @Override
    public void setPvP(boolean state) {
        super.setPvP(state);

        for (var unit : getControlled()) {
            unit.setPvP(state);
        }
    }

    private void setRegularAttackTime() {
        for (WeaponAttackType weaponAttackType = 0; weaponAttackType.getValue() < WeaponAttackType.max.getValue(); ++weaponAttackType) {
            var tmpitem = getWeaponForAttack(weaponAttackType, true);

            if (tmpitem != null && !tmpitem.isBroken()) {
                var proto = tmpitem.getTemplate();

                if (proto.getDelay() != 0) {
                    setBaseAttackTime(weaponAttackType, proto.getDelay());
                }
            } else {
                setBaseAttackTime(weaponAttackType, SharedConst.baseAttackTime); // If there is no weapon reset attack time to base (might have been changed from forms)
            }
        }
    }

    private boolean canTitanGrip() {
        return canTitanGrip;
    }

    private float getRatingMultiplier(CombatRating cr) {
        var rating = CliDB.CombatRatingsGameTable.GetRow(getLevel());

        if (rating == null) {
            return 1.0f;
        }

        var value = getGameTableColumnForCombatRating(rating, cr);

        if (value == 0) {
            return 1.0f; // By default use minimum coefficient (not must be called)
        }

        return 1.0f / value;
    }

    private void getDodgeFromAgility(double diminishing, double nondiminishing) {
		/*// Table for base dodge values
		float[] dodge_base =
		{
		    0.037580f, // Warrior
		    0.036520f, // Paladin
		    -0.054500f, // Hunter
		    -0.005900f, // Rogue
		    0.031830f, // Priest
		    0.036640f, // DK
		    0.016750f, // Shaman
		    0.034575f, // Mage
		    0.020350f, // Warlock
		    0.0f,      // ??
		    0.049510f  // Druid
		};
		// Crit/agility to dodge/agility coefficient multipliers; 3.2.0 increased required agility by 15%
		float[] crit_to_dodge =
		{
		    0.85f/1.15f,    // Warrior
		    1.00f/1.15f,    // Paladin
		    1.11f/1.15f,    // Hunter
		    2.00f/1.15f,    // Rogue
		    1.00f/1.15f,    // Priest
		    0.85f/1.15f,    // DK
		    1.60f/1.15f,    // Shaman
		    1.00f/1.15f,    // Mage
		    0.97f/1.15f,    // Warlock (?)
		    0.0f,           // ??
		    2.00f/1.15f     // Druid
		};

		uint level = getLevel();
		uint pclass = (uint)getClass();

		if (level > CliDB.GtChanceToMeleeCritStorage.GetTableRowCount())
		    level = CliDB.GtChanceToMeleeCritStorage.GetTableRowCount() - 1;

		// Dodge per agility is proportional to crit per agility, which is available from DBC files
		var dodgeRatio = CliDB.GtChanceToMeleeCritStorage.EvaluateTable(level - 1, pclass - 1);
		if (dodgeRatio == null || pclass > (int)class.max)
		    return;

		// @todo research if talents/effects that increase total agility by x% should increase non-diminishing part
		float base_agility = getCreateStat(stats.Agility) * getPctModifierValue(UnitMods(UNIT_MOD_STAT_START + STAT_AGILITY), BASE_PCT);
		float bonus_agility = getStat(stats.Agility) - base_agility;

		// calculate diminishing (green in char screen) and non-diminishing (white) contribution
		diminishing = 100.0f * bonus_agility * dodgeRatio.Value * crit_to_dodge[(int)pclass - 1];
		nondiminishing = 100.0f * (dodge_base[(int)pclass - 1] + base_agility * dodgeRatio.Value * crit_to_dodge[pclass - 1]);
		*/
    }

    private double applyRatingDiminishing(CombatRating cr, double bonusValue) {
        int diminishingCurveId = 0;

        switch (cr) {
            case Dodge:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.DodgeDiminishing);

                break;
            case Parry:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.ParryDiminishing);

                break;
            case Block:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.BlockDiminishing);

                break;
            case CritMelee:
            case CritRanged:
            case CritSpell:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.CritDiminishing);

                break;
            case Speed:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.SpeedDiminishing);

                break;
            case Lifesteal:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.LifestealDiminishing);

                break;
            case HasteMelee:
            case HasteRanged:
            case HasteSpell:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.HasteDiminishing);

                break;
            case Avoidance:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.AvoidanceDiminishing);

                break;
            case Mastery:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.MasteryDiminishing);

                break;
            case VersatilityDamageDone:
            case VersatilityHealingDone:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.VersatilityDoneDiminishing);

                break;
            case VersatilityDamageTaken:
                diminishingCurveId = global.getDB2Mgr().GetGlobalCurveId(GlobalCurve.VersatilityTakenDiminishing);

                break;
        }

        if (diminishingCurveId != 0) {
            return global.getDB2Mgr().GetCurveValueAt(diminishingCurveId, (float) bonusValue);
        }

        return bonusValue;
    }

    private void checkTitanGripPenalty() {
        if (!canTitanGrip()) {
            return;
        }

        var apply = isUsingTwoHandedWeaponInOneHand();

        if (apply) {
            if (!hasAura(titanGripPenaltySpellId)) {
                castSpell((unit) null, titanGripPenaltySpellId, true);
            }
        } else {
            removeAura(titanGripPenaltySpellId);
        }
    }

    private boolean isTwoHandUsed() {
        var mainItem = getItemByPos(InventorySlots.Bag0, EquipmentSlot.MainHand);

        if (!mainItem) {
            return false;
        }

        var itemTemplate = mainItem.getTemplate();

        return (itemTemplate.getInventoryType() == inventoryType.Weapon2Hand && !canTitanGrip()) || itemTemplate.getInventoryType() == inventoryType.Ranged || (itemTemplate.getInventoryType() == inventoryType.RangedRight && itemTemplate.getClass() == itemClass.Weapon && itemTemplate.getSubClass() != ItemSubClassWeapon.wand.getValue());
    }

    private boolean isUsingTwoHandedWeaponInOneHand() {
        var offItem = getItemByPos(InventorySlots.Bag0, EquipmentSlot.OffHand);

        if (offItem && offItem.getTemplate().getInventoryType() == inventoryType.Weapon2Hand) {
            return true;
        }

        var mainItem = getItemByPos(InventorySlots.Bag0, EquipmentSlot.MainHand);

        if (!mainItem || mainItem.getTemplate().getInventoryType() == inventoryType.Weapon2Hand) {
            return false;
        }

        if (!offItem) {
            return false;
        }

        return true;
    }

    private void updateDuelFlag(long currTime) {
        if (getDuel() != null && getDuel().getState() == DuelState.countdown && getDuel().getStartTime() <= currTime) {
            global.getScriptMgr().<IPlayerOnDuelStart>ForEach(p -> p.OnDuelStart(this, getDuel().getOpponent()));

            setDuelTeam(1);
            getDuel().getOpponent().setDuelTeam(2);

            getDuel().setState(DuelState.inProgress);
            getDuel().getOpponent().getDuel().setState(DuelState.inProgress);
        }
    }

    private void checkDuelDistance(long currTime) {
        if (getDuel() == null) {
            return;
        }

        ObjectGuid duelFlagGuid = getPlayerData().duelArbiter;
        var obj = getMap().getGameObject(duelFlagGuid);

        if (!obj) {
            return;
        }

        if (getDuel().getOutOfBoundsTime() == 0) {
            if (!isWithinDistInMap(obj, 50)) {
                getDuel().setOutOfBoundsTime(currTime + 10);
                sendPacket(new DuelOutOfBounds());
            }
        } else {
            if (isWithinDistInMap(obj, 40)) {
                getDuel().setOutOfBoundsTime(0);
                sendPacket(new DuelInBounds());
            } else if (currTime >= getDuel().getOutOfBoundsTime()) {
                duelComplete(DuelCompleteType.fled);
            }
        }
    }

    private void setDuelTeam(int duelTeam) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().duelTeam), duelTeam);
    }

    private void updateAfkReport(long currTime) {
        if (bgData.getBgAfkReportedTimer() <= currTime) {
            bgData.setBgAfkReportedCount(0);
            bgData.setBgAfkReportedTimer(currTime + 5 * time.Minute);
        }
    }

    private void initPvP() {
        // pvp flag should stay after relog
        if (hasPlayerFlag(playerFlags.InPVP)) {
            updatePvP(true, true);
        }
    }

    @Override
    public boolean isLoading() {
        return getSession().getPlayerLoading();
    }

    public final DeclinedName getDeclinedNames() {
        return declinedname;
    }

    public final Garrison getGarrison() {
        return garrison;
    }

    public final SceneMgr getSceneMgr() {
        return sceneMgr;
    }

    public final RestMgr getRestMgr() {
        return restMgr;
    }

    public final boolean isAdvancedCombatLoggingEnabled() {
        return advancedCombatLoggingEnabled;
    }

    @Override
    public float getObjectScale() {
        return super.getObjectScale();
    }

    @Override
    public void setObjectScale(float value) {
        super.setObjectScale(value);

        setBoundingRadius(value * SharedConst.DefaultPlayerBoundingRadius);
        setCombatReach(value * SharedConst.DefaultPlayerCombatReach);

        if (isInWorld()) {
            sendMovementSetCollisionHeight(getCollisionHeight(), UpdateCollisionHeightReason.scale);
        }
    }

    public final PetStable getPetStable() {
        if (petStable == null) {
            petStable = new PetStable();
        }

        return petStable;
    }

    public final byte getCUFProfilesCount() {
        return (byte) cufProfiles.count(p -> p != null);
    }

    public final boolean getHasSummonPending() {
        return summonExpire >= gameTime.GetGameTime();
    }

    //GM
    public final boolean isDeveloper() {
        return hasPlayerFlag(playerFlags.Developer);
    }

    public final void setDeveloper(boolean on) {
        if (on) {
            setPlayerFlag(playerFlags.Developer);
        } else {
            removePlayerFlag(playerFlags.Developer);
        }
    }

    public final boolean isAcceptWhispers() {
        return extraFlags.hasFlag(PlayerExtraFlags.AcceptWhispers);
    }

    public final void setAcceptWhispers(boolean on) {
        if (on) {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.AcceptWhispers.getValue());
        } else {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() & ~PlayerExtraFlags.AcceptWhispers.getValue());
        }
    }

    public final boolean isGameMaster() {
        return extraFlags.hasFlag(PlayerExtraFlags.GMOn);
    }

    public final void setGameMaster(boolean on) {
        if (on) {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.GMOn.getValue());
            setFaction(35);
            setPlayerFlag(playerFlags.GM);
            setUnitFlag2(UnitFlag2.AllowCheatSpells);

            var pet = getCurrentPet();

            if (pet != null) {
                pet.setFaction(35);
            }

            removePvpFlag(UnitPVPStateFlags.FFAPvp);
            resetContestedPvP();

            combatStopWithPets();

            PhasingHandler.setAlwaysVisible(this, true, false);
            getServerSideVisibilityDetect().setValue(ServerSideVisibilityType.GM, getSession().getSecurity());
        } else {
            PhasingHandler.setAlwaysVisible(this, hasAuraType(AuraType.PhaseAlwaysVisible), false);

            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() & ~PlayerExtraFlags.GMOn.getValue());
            restoreFaction();
            removePlayerFlag(playerFlags.GM);
            removeUnitFlag2(UnitFlag2.AllowCheatSpells);

            var pet = getCurrentPet();

            if (pet != null) {
                pet.setFaction(getFaction());
            }

            // restore FFA PvP Server state
            if (global.getWorldMgr().isFFAPvPRealm()) {
                setPvpFlag(UnitPVPStateFlags.FFAPvp);
            }

            // restore FFA PvP area state, remove not allowed for GM mounts
            updateArea(areaUpdateId);

            getServerSideVisibilityDetect().setValue(ServerSideVisibilityType.GM, AccountTypes.player);
        }

        updateObjectVisibility();
    }

    public final boolean isGameMasterAcceptingWhispers() {
        return isGameMaster() && isAcceptWhispers();
    }

    public final boolean getCanBeGameMaster() {
        return getSession().hasPermission(RBACPermissions.CommandGm);
    }

    public final boolean isGMChat() {
        return extraFlags.hasFlag(PlayerExtraFlags.GMChat);
    }

    public final void setGMChat(boolean on) {
        if (on) {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.GMChat.getValue());
        } else {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() & ~PlayerExtraFlags.GMChat.getValue());
        }
    }

    public final boolean isTaxiCheater() {
        return extraFlags.hasFlag(PlayerExtraFlags.TaxiCheat);
    }

    public final void setTaxiCheater(boolean on) {
        if (on) {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.TaxiCheat.getValue());
        } else {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() & ~PlayerExtraFlags.TaxiCheat.getValue());
        }
    }

    public final boolean isGMVisible() {
        return !extraFlags.hasFlag(PlayerExtraFlags.GMInvisible);
    }

    public final void setGMVisible(boolean on) {
        if (on) {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() & ~PlayerExtraFlags.GMInvisible.getValue()); //remove flag
            getServerSideVisibility().setValue(ServerSideVisibilityType.GM, AccountTypes.player);
        } else {
            extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.GMInvisible.getValue()); //add flag

            setAcceptWhispers(false);
            setGameMaster(true);

            getServerSideVisibility().setValue(ServerSideVisibilityType.GM, getSession().getSecurity());
        }

        for (var channel : channels) {
            channel.setInvisible(this, !on);
        }
    }

    public final ArrayList<channel> getJoinedChannels() {
        return channels;
    }

    public final ArrayList<MAIL> getMails() {
        return mail;
    }

    public final int getMailSize() {
        return (int) mail.size();
    }

    //Binds
    public final boolean getHasPendingBind() {
        return pendingBindId > 0;
    }

    //Misc
    public final int getTotalPlayedTime() {
        return playedTimeTotal;
    }

    public final int getLevelPlayedTime() {
        return playedTimeLevel;
    }

    public final CinematicManager getCinematicMgr() {
        return cinematicMgr;
    }

    public final boolean getHasCorpse() {
        return corpseLocation != null && corpseLocation.getMapId() != 0xFFFFFFFF;
    }

    public final WorldLocation getCorpseLocation() {
        return corpseLocation;
    }

    @Override
    public boolean getCanFly() {
        return getMovementInfo().hasMovementFlag(MovementFlag.CanFly);
    }

    @Override
    public boolean getCanEnterWater() {
        return true;
    }

    public final boolean getInArena() {
        var bg = getBattleground();

        if (!bg || !bg.isArena()) {
            return false;
        }

        return true;
    }

    public final boolean isWarModeLocalActive() {
        return hasPlayerLocalFlag(PlayerLocalFlags.WarMode);
    }

    public final Team getTeam() {
        return team;
    }

    public final TeamId getTeamId() {
        return team == Team.ALLIANCE ? TeamId.ALLIANCE : TeamId.HORDE;
    }

    public final Team getEffectiveTeam() {
        return hasPlayerFlagEx(playerFlagsEx.MercenaryMode) ? (getTeam() == Team.ALLIANCE ? Team.HORDE : Team.ALLIANCE) : getTeam();
    }

    public final TeamId getEffectiveTeamId() {
        return getEffectiveTeam() == Team.ALLIANCE ? TeamId.ALLIANCE : TeamId.HORDE;
    }

    //Money
    public final long getMoney() {
        return getActivePlayerData().coinage;
    }

    public final void setMoney(long value) {
        var loading = getSession().getPlayerLoading();

        if (!loading) {
            moneyChanged((int) value);
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().coinage), value);

        if (!loading) {
            updateCriteria(CriteriaType.MostMoneyOwned);
        }
    }

    public final int getGuildRank() {
        return getPlayerData().guildRankID;
    }

    public final void setGuildRank(byte rankId) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().guildRankID), rankId);
    }

    public final int getGuildLevel() {
        return getPlayerData().guildLevel;
    }

    public final void setGuildLevel(int value) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().guildLevel), value);
    }

    public final long getGuildId() {
        return ((ObjectGuid) getUnitData().guildGUID).getCounter();
    }

    public final Guild getGuild() {
        var guildId = getGuildId();

        return guildId != 0 ? global.getGuildMgr().getGuildById(guildId) : null;
    }

    public final long getGuildIdInvited() {
        return guildIdInvited;
    }

    public final void setGuildIdInvited(long value) {
        guildIdInvited = value;
    }

    public final String getGuildName() {
        return getGuildId() != 0 ? global.getGuildMgr().getGuildById(getGuildId()).getName() : "";
    }

    public final boolean getCanParry() {
        return canParry;
    }

    public final void setCanParry(boolean value) {
        if (canParry == value) {
            return;
        }

        canParry = value;
        updateParryPercentage();
    }

    public final boolean getCanBlock() {
        return canBlock;
    }

    public final void setCanBlock(boolean value) {
        if (canBlock == value) {
            return;
        }

        canBlock = value;
        updateBlockPercentage();
    }

    public final boolean isAFK() {
        return hasPlayerFlag(playerFlags.AFK);
    }

    public final boolean isDND() {
        return hasPlayerFlag(playerFlags.DND);
    }

    public final boolean isMaxLevel() {
        if (ConfigMgr.GetDefaultValue("character.MaxLevelDeterminedByConfig", false)) {
            return getLevel() >= WorldConfig.getIntValue(WorldCfg.MaxPlayerLevel);
        }

        return getLevel() >= getActivePlayerData().maxLevel;
    }

    public final ChatFlags getChatFlags() {
        var tag = ChatFlags.NONE;

        if (isGMChat()) {
            tag = ChatFlags.forValue(tag.getValue() | ChatFlags.GM.getValue());
        }

        if (isDND()) {
            tag = ChatFlags.forValue(tag.getValue() | ChatFlags.DND.getValue());
        }

        if (isAFK()) {
            tag = ChatFlags.forValue(tag.getValue() | ChatFlags.AFK.getValue());
        }

        if (isDeveloper()) {
            tag = ChatFlags.forValue(tag.getValue() | ChatFlags.Dev.getValue());
        }

        return tag;
    }

    public final int getSaveTimer() {
        return nextSave;
    }

    private void setSaveTimer(int value) {
        nextSave = value;
    }

    public final ReputationMgr getReputationMgr() {
        return reputationMgr;
    }

    public final PlayerCreateMode getCreateMode() {
        return createMode;
    }

    public final byte getCinematic() {
        return cinematic;
    }

    public final void setCinematic(byte value) {
        cinematic = value;
    }

    public final int getMovie() {
        return movie;
    }

    public final void setMovie(int value) {
        movie = value;
    }

    public final int getXP() {
        return getActivePlayerData().XP;
    }

    public final void setXP(int value) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().XP), value);

        var playerLevelDelta = 0;

        // If XP < 50%, player should see scaling creature with -1 level except for level max
        if (getLevel() < SharedConst.maxLevel && value < (getActivePlayerData().NextLevelXP / 2)) {
            playerLevelDelta = -1;
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().scalingPlayerLevelDelta), playerLevelDelta);
    }

    public final int getXPForNextLevel() {
        return getActivePlayerData().nextLevelXP;
    }

    public final byte getDrunkValue() {
        return getPlayerData().inebriation;
    }

    public final void setDrunkValue(byte newDrunkValue) {
        setDrunkValue(newDrunkValue, 0);
    }

    public final int getDeathTimer() {
        return deathTimer;
    }

    public final TeleportToOptions getTeleportOptions() {
        return teleportOptions;
    }

    public final boolean isBeingTeleported() {
        return semaphoreTeleportNear || semaphoreTeleportFar;
    }

    public final boolean isBeingTeleportedNear() {
        return semaphoreTeleportNear;
    }

    public final boolean isBeingTeleportedFar() {
        return semaphoreTeleportFar;
    }

    public final boolean isBeingTeleportedSeamlessly() {
        return isBeingTeleportedFar() && teleportOptions.hasFlag(TeleportToOptions.Seamless);
    }

    public final boolean isReagentBankUnlocked() {
        return hasPlayerFlagEx(playerFlagsEx.ReagentBankUnlocked);
    }

    public final int getFreePrimaryProfessionPoints() {
        return getActivePlayerData().characterPoints;
    }

    public final WorldObject getViewpoint() {
        ObjectGuid guid = getActivePlayerData().farsightObject;

        if (!guid.isEmpty()) {
            return global.getObjAccessor().GetObjectByTypeMask(this, guid, TypeMask.Seer);
        }

        return null;
    }

    public final WorldLocation getTeleportDest() {
        return teleportDest;
    }

    public final Integer getTeleportDestInstanceId() {
        return teleportInstanceId;
    }

    public final WorldLocation getHomeBind() {
        return homeBind;
    }

    public final WorldLocation getRecall1() {
        return recallLocation;
    }

    @Override
    public Gender getNativeGender() {
        return gender.forValue((byte) ((byte) getPlayerData().nativeSex));
    }

    @Override
    public void setNativeGender(Gender value) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().nativeSex), (byte) value.getValue());
    }

    public final ObjectGuid getSummonedBattlePetGUID() {
        return getActivePlayerData().summonedBattlePetGUID;
    }

    public final void setSummonedBattlePetGUID(ObjectGuid guid) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().summonedBattlePetGUID), guid);
    }

    public final byte getNumRespecs() {
        return getActivePlayerData().numRespecs;
    }

    public final void setNumRespecs(byte numRespecs) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().numRespecs), numRespecs);
    }

    public final boolean getCanTameExoticPets() {
        return isGameMaster() || hasAuraType(AuraType.AllowTamePetType);
    }

    //Movement
    private boolean isCanDelayTeleport() {
        return canDelayTeleport;
    }

    private void setCanDelayTeleport(boolean setting) {
        canDelayTeleport = setting;
    }

    private boolean isHasDelayedTeleport() {
        return hasDelayedTeleport;
    }

    private boolean isTotalImmune() {
        var immune = getAuraEffectsByType(AuraType.SchoolImmunity);

        var immuneMask = 0;

        for (var eff : immune) {
            immuneMask |= eff.getMiscValue();

            if ((boolean) (immuneMask & spellSchoolMask.All.getValue())) // total immunity
            {
                return true;
            }
        }

        return false;
    }

    private boolean isInFriendlyArea() {
        var areaEntry = CliDB.AreaTableStorage.get(getArea());

        if (areaEntry != null) {
            return isFriendlyArea(areaEntry);
        }

        return false;
    }

    private boolean isWarModeDesired() {
        return hasPlayerFlag(playerFlags.WarModeDesired);
    }

    public final void setWarModeDesired(boolean enabled) {
        // Only allow to toggle on when in stormwind/orgrimmar, and to toggle off in any rested place.
        // Also disallow when in combat
        if ((enabled == isWarModeDesired()) || isInCombat() || !hasPlayerFlag(playerFlags.Resting)) {
            return;
        }

        if (enabled && !canEnableWarModeInArea()) {
            return;
        }

        // Don't allow to chang when aura SPELL_PVP_RULES_ENABLED is on
        if (hasAura(PlayerConst.SpellPvpRulesEnabled)) {
            return;
        }

        if (enabled) {
            setPlayerFlag(playerFlags.WarModeDesired);
            setPvP(true);
        } else {
            removePlayerFlag(playerFlags.WarModeDesired);
            setPvP(false);
        }

        updateWarModeAuras();
    }

    private boolean isWarModeActive() {
        return hasPlayerFlag(playerFlags.WarModeActive);
    }

    //Pet - Summons - Vehicles
    public final PetStable getPetStable1() {
        return petStable;
    }

    // last used pet number (for BG's)
    public final int getLastPetNumber() {
        return lastpetnumber;
    }

    public final void setLastPetNumber(int value) {
        lastpetnumber = value;
    }

    public final int getTemporaryUnsummonedPetNumber() {
        return temporaryUnsummonedPetNumber;
    }

    public final void setTemporaryUnsummonedPetNumber(int value) {
        temporaryUnsummonedPetNumber = value;
    }

    public final boolean isResurrectRequested() {
        return resurrectionData != null;
    }

    public final Unit getSelectedUnit() {
        var selectionGUID = getTarget();

        if (!selectionGUID.isEmpty()) {
            return global.getObjAccessor().GetUnit(this, selectionGUID);
        }

        return null;
    }

    public final Player getSelectedPlayer() {
        var selectionGUID = getTarget();

        if (!selectionGUID.isEmpty()) {
            return global.getObjAccessor().getPlayer(this, selectionGUID);
        }

        return null;
    }

    public final Pet getCurrentPet() {
        var petGuid = getPetGUID();

        if (!petGuid.isEmpty()) {
            if (!petGuid.isPet()) {
                return null;
            }

            var pet = ObjectAccessor.getPet(this, petGuid);

            if (pet == null) {
                return null;
            }

            if (isInWorld()) {
                return pet;
            }
        }

        return null;
    }

    @Override
    public PlayerAI getAI() {
        IUnitAI tempVar = getAi();
        return tempVar instanceof PlayerAI ? (PlayerAI) tempVar : null;
    }

    @Override
    public void close() throws IOException {
        // Note: buy back item already deleted from DB when player was saved
        for (byte i = 0; i < PlayerSlot.count.getValue(); ++i) {
            if (_items[i] != null) {
                _items[i].close();
            }
        }

        spells.clear();
        specializationInfo = null;
        mail.clear();

        for (var item : mailItems.values()) {
            item.dispose();
        }

        getPlayerTalkClass().clearMenus();
        getItemSetEff().clear();

        declinedname = null;
        runes = null;
        _AchievementSys = null;
        reputationMgr = null;

        cinematicMgr.close();

        for (byte i = 0; i < SharedConst.VoidStorageMaxSlot; ++i) {
            _voidStorageItems[i] = null;
        }

        clearResurrectRequestData();

        global.getWorldMgr().decreasePlayerCount();

        super.close();
    }

    //Core
    public final boolean create(long guidlow, CharacterCreateInfo createInfo) {
        create(ObjectGuid.create(HighGuid.Player, guidlow));

        setName(createInfo.name);

        var info = global.getObjectMgr().getPlayerInfo(createInfo.raceId, createInfo.classId);

        if (info == null) {
            Log.outError(LogFilter.player, "PlayerCreate: Possible hacking-attempt: Account {0} tried creating a character named '{1}' with an invalid race/class pair ({2}/{3}) - refusing to do so.", getSession().getAccountId(), getName(), createInfo.raceId, createInfo.classId);

            return false;
        }

        var cEntry = CliDB.ChrClassesStorage.get(createInfo.classId);

        if (cEntry == null) {
            Log.outError(LogFilter.player, "PlayerCreate: Possible hacking-attempt: Account {0} tried creating a character named '{1}' with an invalid character class ({2}) - refusing to do so (wrong DBC-files?)", getSession().getAccountId(), getName(), createInfo.classId);

            return false;
        }

        if (!getSession().validateAppearance(createInfo.raceId, createInfo.classId, createInfo.sex, createInfo.customizations)) {
            Log.outError(LogFilter.player, "Player.Create: Possible hacking-attempt: Account {0} tried creating a character named '{1}' with invalid appearance attributes - refusing to do so", getSession().getAccountId(), getName());

            return false;
        }

        var position = createInfo.useNPE && info.createPositionNpe != null ? info.createPositionNpe.getValue() : info.createPosition;

        createTime = gameTime.GetGameTime();
        createMode = createInfo.useNPE && info.createPositionNpe != null ? PlayerCreateMode.NPE : PlayerCreateMode.NORMAL;

        getLocation().relocate(position.loc);

        setMap(global.getMapMgr().CreateMap(position.loc.mapId, this));

        if (position.transportGuid.HasValue) {
            var transport = ObjectAccessor.getTransport(this, ObjectGuid.create(HighGuid.Transport, position.transportGuid.value));

            if (transport != null) {
                transport.addPassenger(this);
                getMovementInfo().transport.pos.relocate(position.loc);
                var transportPos = position.loc.Copy();
                transport.calculatePassengerPosition(transportPos);
                getLocation().relocate(transportPos);
            }
        }

        // set initial homebind position
        setHomebind(getLocation(), getArea());

        var powertype = cEntry.displayPower;

        setObjectScale(1.0f);

        setFactionForRace(createInfo.raceId);

        if (!isValidGender(createInfo.sex)) {
            Log.outError(LogFilter.player, "Player:Create: Possible hacking-attempt: Account {0} tried creating a character named '{1}' with an invalid gender ({2}) - refusing to do so", getSession().getAccountId(), getName(), createInfo.sex);

            return false;
        }

        setRace(createInfo.raceId);
        setClass(createInfo.classId);
        setGender(createInfo.sex);
        setPowerType(powertype, false);
        initDisplayIds();

        if (RealmType.forValue(WorldConfig.getIntValue(WorldCfg.GameType)) == RealmType.PVP || WorldConfig.getIntValue(WorldCfg.GameType) == RealmType.RPPVP.getValue()) {
            setPvpFlag(UnitPVPStateFlags.pvP);
            setUnitFlag(UnitFlag.PlayerControlled);
        }

        setUnitFlag2(UnitFlag2.RegeneratePower);
        setHoverHeight(1.0f); // default for players in 3.0.3

        setWatchedFactionIndex((int) 0xFFFFFFFF);

        setCustomizations(createInfo.customizations);
        setRestState(RestTypes.XP, ((getSession().isARecruiter() || getSession().getRecruiterId() != 0) ? PlayerRestState.RAFLinked : PlayerRestState.NORMAL));
        setRestState(RestTypes.honor, PlayerRestState.NORMAL);
        setNativeGender(createInfo.sex);
        setInventorySlotCount(InventorySlots.DefaultSize);

        // set starting level
        setLevel(getStartLevel(createInfo.raceId, createInfo.classId, createInfo.templateSet));

        initRunes();

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().coinage), (long) WorldConfig.getIntValue(WorldCfg.StartPlayerMoney));

        // Played time
        lastTick = gameTime.GetGameTime();
        playedTimeTotal = 0;
        playedTimeLevel = 0;

        // base stats and related field values
        initStatsForLevel();
        initTaxiNodesForLevel();
        initTalentForLevel();
        initializeSkillFields();
        initPrimaryProfessions(); // to max set before any spell added

        // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
        updateMaxHealth(); // Update max health (for add bonus from stamina)
        setFullHealth();
        setFullPower(powerType.mana);

        // original spells
        learnDefaultSkills();
        learnCustomSpells();

        // Original action bar. Do not use player.AddActionButton because we do not have skill spells loaded at this time
        // but checks will still be performed later when loading character from db in player._LoadActions
        for (var action : info.getActions()) {
            // create new button
            ActionButton ab = new ActionButton();

            // set data
            ab.setActionAndType(action.getAction(), ActionButtonType.forValue(action.getType()));

            actionButtons.put(action.getButton(), ab);
        }

        // original items
        for (var initialItem : info.getItems()) {
            storeNewItemInBestSlots(initialItem.getItemId(), initialItem.getAmount(), info.getItemContext());
        }

        // bags and main-hand weapon must equipped at this moment
        // now second pass for not equipped (offhand weapon/shield if it attempt equipped before main-hand weapon)
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem != null) {
                // equip offhand weapon/shield if it attempt equipped before main-hand weapon
                short eDest;
                tangible.OutObject<SHORT> tempOut_eDest = new tangible.OutObject<SHORT>();
                var msg = canEquipItem(ItemConst.NullSlot, tempOut_eDest, pItem, false);
                eDest = tempOut_eDest.outArgValue;

                if (msg == InventoryResult.Ok) {
                    removeItem(InventorySlots.Bag0, i, true);
                    equipItem(eDest, pItem, true);
                }
                // move other items to more appropriate slots
                else {
                    ArrayList<ItemPosCount> sDest = new ArrayList<>();
                    msg = canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, sDest, pItem, false);

                    if (msg == InventoryResult.Ok) {
                        removeItem(InventorySlots.Bag0, i, true);
                        storeItem(sDest, pItem, true);
                    }
                }
            }
        }
        // all item positions resolved

        var defaultSpec = global.getDB2Mgr().GetDefaultChrSpecializationForClass(getClass());

        if (defaultSpec != null) {
            setActiveTalentGroup(defaultSpec.orderIndex);
            setPrimarySpecialization(defaultSpec.id);
        }

        getThreatManager().initialize();

        applyCustomConfigs();

        return true;
    }

    @Override
    public void update(int diff) {
        if (!isInWorld()) {
            return;
        }

        // undelivered mail
        if (nextMailDelivereTime != 0 && nextMailDelivereTime <= gameTime.GetGameTime()) {
            sendNewMail();
            setUnReadMails(getUnReadMails() + 1);

            // It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
            nextMailDelivereTime = 0;
        }

        // Update cinematic location, if 500ms have passed and we're doing a cinematic now.
        cinematicMgr.setCinematicDiff(cinematicMgr.getCinematicDiff() + diff);

        if (cinematicMgr.getCinematicCamera() != null && cinematicMgr.getActiveCinematic() != null && time.GetMSTimeDiffToNow(cinematicMgr.getLastCinematicCheck()) > 500) {
            cinematicMgr.setLastCinematicCheck(gameTime.GetGameTimeMS());
            cinematicMgr.updateCinematicLocation(diff);
        }

        //used to implement delayed far teleports
        setCanDelayTeleport(true);
        super.update(diff);
        setCanDelayTeleport(false);

        var now = gameTime.GetGameTime();

        updatePvPFlag(now);

        updateContestedPvP(diff);

        updateDuelFlag(now);

        checkDuelDistance(now);

        updateAfkReport(now);

        if (getCombatManager().hasPvPCombat()) // Only set when in pvp combat
        {
            var aura = getAura(PlayerConst.SpellPvpRulesEnabled);

            if (aura != null) {
                if (!aura.isPermanent()) {
                    aura.setDuration(aura.getSpellInfo().getMaxDuration());
                }
            }
        }

        AIUpdateTick(diff);

        // Update items that have just a limited lifetime
        if (now > lastTick) {
            updateItemDuration((int) (now - lastTick));
        }

        // check every second
        if (now > lastTick + 1) {
            updateSoulboundTradeItems();
        }

        // If mute expired, remove it from the DB
        if (getSession().muteTime != 0 && getSession().muteTime < now) {
            getSession().muteTime = 0;
            var stmt = DB.Login.GetPreparedStatement(LoginStatements.UPD_MUTE_TIME);
            stmt.AddValue(0, 0); // Set the mute time to 0
            stmt.AddValue(1, "");
            stmt.AddValue(2, "");
            stmt.AddValue(3, getSession().getAccountId());
            DB.Login.execute(stmt);
        }

        if (!timedquests.isEmpty()) {
            for (var id : timedquests) {
                var q_status = mQuestStatus.get(id);

                if (q_status.timer <= diff) {
                    failQuest(id);
                } else {
                    q_status.Timer -= diff;
                    questStatusSave.put(id, QuestSaveType.Default);
                }
            }
        }

        _AchievementSys.updateTimedCriteria(diff);

        if (hasUnitState(UnitState.MeleeAttacking) && !hasUnitState(UnitState.Casting.getValue() | UnitState.Charging.getValue())) {
            var victim = getVictim();

            if (victim != null) {
                // default combat reach 10
                // TODO add weapon, skill check

                if (isAttackReady(WeaponAttackType.BaseAttack)) {
                    if (!isWithinMeleeRange(victim)) {
                        setAttackTimer(WeaponAttackType.BaseAttack, 100);

                        if (swingErrorMsg != 1) // send single time (client auto repeat)
                        {
                            sendAttackSwingNotInRange();
                            swingErrorMsg = 1;
                        }
                    }
                    //120 degrees of radiant range, if player is not in boundary radius
                    else if (!isWithinBoundaryRadius(victim) && !getLocation().hasInArc(2 * MathUtil.PI / 3, victim.getLocation())) {
                        setAttackTimer(WeaponAttackType.BaseAttack, 100);

                        if (swingErrorMsg != 2) // send single time (client auto repeat)
                        {
                            sendAttackSwingBadFacingAttack();
                            swingErrorMsg = 2;
                        }
                    } else {
                        swingErrorMsg = 0; // reset swing error state

                        // prevent base and off attack in same time, delay attack at 0.2 sec
                        if (haveOffhandWeapon()) {
                            if (getAttackTimer(WeaponAttackType.OffAttack) < SharedConst.AttackDisplayDelay) {
                                setAttackTimer(WeaponAttackType.OffAttack, SharedConst.AttackDisplayDelay);
                            }
                        }

                        // do attack
                        attackerStateUpdate(victim, WeaponAttackType.BaseAttack);
                        resetAttackTimer(WeaponAttackType.BaseAttack);
                    }
                }

                if (!isInFeralForm() && haveOffhandWeapon() && isAttackReady(WeaponAttackType.OffAttack)) {
                    if (!isWithinMeleeRange(victim)) {
                        setAttackTimer(WeaponAttackType.OffAttack, 100);
                    } else if (!isWithinBoundaryRadius(victim) && !getLocation().hasInArc(2 * MathUtil.PI / 3, victim.getLocation())) {
                        setAttackTimer(WeaponAttackType.BaseAttack, 100);
                    } else {
                        // prevent base and off attack in same time, delay attack at 0.2 sec
                        if (getAttackTimer(WeaponAttackType.BaseAttack) < SharedConst.AttackDisplayDelay) {
                            setAttackTimer(WeaponAttackType.BaseAttack, SharedConst.AttackDisplayDelay);
                        }

                        // do attack
                        attackerStateUpdate(victim, WeaponAttackType.OffAttack);
                        resetAttackTimer(WeaponAttackType.OffAttack);
                    }
                }
            }
        }

        if (hasPlayerFlag(playerFlags.Resting)) {
            restMgr.update(diff);
        }

        if (weaponChangeTimer > 0) {
            if (diff >= weaponChangeTimer) {
                weaponChangeTimer = 0;
            } else {
                _weaponChangeTimer -= diff;
            }
        }

        if (zoneUpdateTimer > 0) {
            if (diff >= zoneUpdateTimer) {
                // On zone update tick check if we are still in an inn if we are supposed to be in one
                if (restMgr.hasRestFlag(RestFlag.Tavern)) {
                    var atEntry = CliDB.AreaTriggerStorage.get(restMgr.getInnTriggerId());

                    if (atEntry == null || !isInAreaTriggerRadius(atEntry)) {
                        restMgr.removeRestFlag(RestFlag.Tavern);
                    }
                }

                int newzone;
                tangible.OutObject<Integer> tempOut_newzone = new tangible.OutObject<Integer>();
                int newarea;
                tangible.OutObject<Integer> tempOut_newarea = new tangible.OutObject<Integer>();
                getZoneAndAreaId(tempOut_newzone, tempOut_newarea);
                newarea = tempOut_newarea.outArgValue;
                newzone = tempOut_newzone.outArgValue;

                if (zoneUpdateId != newzone) {
                    updateZone(newzone, newarea); // also update area
                } else {
                    // use area updates as well
                    // needed for free far all arenas for example
                    if (areaUpdateId != newarea) {
                        updateArea(newarea);
                    }

                    zoneUpdateTimer = 1 * time.InMilliseconds;
                }
            } else {
                _zoneUpdateTimer -= diff;
            }
        }

        if (isAlive()) {
            setRegenTimer(getRegenTimer() + diff);
            regenerateAll();
        }

        if (getDeathState() == deathState.JustDied) {
            killPlayer();
        }

        if (nextSave > 0) {
            if (diff >= nextSave) {
                // m_nextSave reset in SaveToDB call
                global.getScriptMgr().<IPlayerOnSave>ForEach(p -> p.OnSave(this));
                saveToDB();
                Log.outDebug(LogFilter.player, "Player '{0}' (GUID: {1}) saved", getName(), getGUID().toString());
            } else {
                _nextSave -= diff;
            }
        }

        //Handle Water/drowning
        handleDrowning(diff);

        // Played time
        if (now > lastTick) {
            var elapsed = (int) (now - lastTick);
            playedTimeTotal += elapsed;
            playedTimeLevel += elapsed;
            lastTick = now;
        }

        if (getDrunkValue() != 0) {
            drunkTimer += diff;

            if (drunkTimer > 9 * time.InMilliseconds) {
                handleSobering();
            }
        }

        if (getHasPendingBind()) {
            if (pendingBindTimer <= diff) {
                // Player left the instance
                if (pendingBindId == getInstanceId()) {
                    confirmPendingBind();
                }

                setPendingBind(0, 0);
            } else {
                _pendingBindTimer -= diff;
            }
        }

        // not auto-free ghost from body in instances
        if (deathTimer > 0 && !getMap().isInstanceable() && !hasAuraType(AuraType.PreventResurrection)) {
            if (diff >= deathTimer) {
                deathTimer = 0;
                buildPlayerRepop();
                repopAtGraveyard();
            } else {
                _deathTimer -= diff;
            }
        }

        updateEnchantTime(diff);
        updateHomebindTime(diff);

        if (!instanceResetTimes.isEmpty()) {
            for (var instance : instanceResetTimes.ToList()) {
                if (instance.value < now) {
                    instanceResetTimes.remove(instance.key);
                }
            }
        }

        // group update
        groupUpdateTimer.update(diff);

        if (groupUpdateTimer.Passed) {
            sendUpdateToOutOfRangeGroupMembers();
            groupUpdateTimer.reset(5000);
        }

        var pet = getCurrentPet();

        if (pet != null && !pet.isWithinDistInMap(this, getMap().getVisibilityRange()) && !pet.isPossessed()) {
            removePet(pet, PetSaveMode.NotInSlot, true);
        }

        if (isAlive()) {
            if (hostileReferenceCheckTimer <= diff) {
                hostileReferenceCheckTimer = 15 * time.InMilliseconds;

                if (!getMap().isDungeon()) {
                    getCombatManager().endCombatBeyondRange(getVisibilityRange(), true);
                }
            } else {
                _hostileReferenceCheckTimer -= diff;
            }
        }

        //we should execute delayed teleports only for alive(!) players
        //because we don't want player's ghost teleported from graveyard
        if (isHasDelayedTeleport() && isAlive()) {
            teleportTo(teleportDest, teleportOptions);
        }
    }

    @Override
    public void setDeathState(DeathState s) {
        var oldIsAlive = isAlive();

        if (s == deathState.JustDied) {
            if (!oldIsAlive) {
                Log.outError(LogFilter.player, "Player.setDeathState: Attempted to kill a dead player '{0}' ({1})", getName(), getGUID().toString());

                return;
            }

            // drunken state is cleared on death
            setDrunkValue((byte) 0);
            // lost combo points at any target (targeted combo points clear in Unit::setDeathState)
            clearComboPoints();

            clearResurrectRequestData();

            //FIXME: is pet dismissed at dying or releasing spirit? if second, add setDeathState(DEAD) to HandleRepopRequestOpcode and define pet unsummon here with (s == DEAD)
            removePet(null, PetSaveMode.NotInSlot, true);

            initializeSelfResurrectionSpells();

            updateCriteria(CriteriaType.DieOnMap, 1);
            updateCriteria(CriteriaType.DieAnywhere, 1);
            updateCriteria(CriteriaType.DieInInstance, 1);

            // reset all death criterias
            resetCriteria(CriteriaFailEvent.Death, 0);
        }

        super.setDeathState(s);

        if (isAlive() && !oldIsAlive) {
            //clear aura case after resurrection by another way (spells will be applied before next death)
            clearSelfResSpell();
        }
    }

    @Override
    public void destroyForPlayer(Player target) {
        super.destroyForPlayer(target);

        if (target == this) {
            for (var i = EquipmentSlot.start; i < InventorySlots.BankBagEnd; ++i) {
                if (_items[i] == null) {
                    continue;
                }

                _items[i].destroyForPlayer(target);
            }

            for (var i = InventorySlots.ReagentStart; i < InventorySlots.ChildEquipmentEnd; ++i) {
                if (_items[i] == null) {
                    continue;
                }

                _items[i].destroyForPlayer(target);
            }
        }
    }

    @Override
    public void cleanupsBeforeDelete() {
        cleanupsBeforeDelete(true);
    }

    @Override
    public void cleanupsBeforeDelete(boolean finalCleanup) {
        tradeCancel(false);
        duelComplete(DuelCompleteType.Interrupted);

        super.cleanupsBeforeDelete(finalCleanup);
    }

    @Override
    public void addToWorld() {
        // Do not add/remove the player from the object storage
        // It will crash when updating the ObjectAccessor
        // The player should only be added when logging in
        super.addToWorld();

        for (byte i = PlayerSlot.start.getValue(); i < PlayerSlot.End.getValue(); ++i) {
            if (_items[i] != null) {
                _items[i].addToWorld();
            }
        }
    }

    @Override
    public void removeFromWorld() {
        // cleanup
        if (isInWorld()) {
            // Release charmed creatures, unsummon totems and remove pets/guardians
            stopCastingCharm();
            stopCastingBindSight();
            unsummonPetTemporaryIfAny();
            clearComboPoints();
            getSession().doLootReleaseAll();
            lootRolls.clear();
            global.getOutdoorPvPMgr().handlePlayerLeaveZone(this, zoneUpdateId);
            global.getBattleFieldMgr().handlePlayerLeaveZone(this, zoneUpdateId);
        }

        // Remove items from world before self - player must be found in item.RemoveFromObjectUpdate
        for (byte i = PlayerSlot.start.getValue(); i < PlayerSlot.End.getValue(); ++i) {
            if (_items[i] != null) {
                _items[i].removeFromWorld();
            }
        }

        // Do not add/remove the player from the object storage
        // It will crash when updating the ObjectAccessor
        // The player should only be removed when logging out
        super.removeFromWorld();

        var viewpoint = getViewpoint();

        if (viewpoint != null) {
            Log.outError(LogFilter.player, "Player {0} has viewpoint {1} {2} when removed from world", getName(), viewpoint.getEntry(), viewpoint.getTypeId());

            setViewpoint(viewpoint, false);
        }

        removePlayerLocalFlag(PlayerLocalFlags.OverrideTransportServerTime);
        setTransportServerTime(0);
    }

    public final void processDelayedOperations() {
        if (delayedOperations == 0) {
            return;
        }

        if (delayedOperations.hasFlag(PlayerDelayedOperations.ResurrectPlayer)) {
            resurrectUsingRequestDataImpl();
        }

        if (delayedOperations.hasFlag(PlayerDelayedOperations.SavePlayer)) {
            saveToDB();
        }

        if (delayedOperations.hasFlag(PlayerDelayedOperations.SpellCastDeserter)) {
            castSpell(this, 26013, true); // Deserter
        }

        if (delayedOperations.hasFlag(PlayerDelayedOperations.BGMountRestore)) {
            if (bgData.getMountSpell() != 0) {
                castSpell(this, bgData.getMountSpell(), true);
                bgData.setMountSpell(0);
            }
        }

        if (delayedOperations.hasFlag(PlayerDelayedOperations.BGTaxiRestore)) {
            if (bgData.hasTaxiPath()) {
                getTaxi().addTaxiDestination(bgData.getTaxiPath()[0]);
                getTaxi().addTaxiDestination(bgData.getTaxiPath()[1]);
                bgData.clearTaxiPath();

                continueTaxiFlight();
            }
        }

        if (delayedOperations.hasFlag(PlayerDelayedOperations.BGGroupRestore)) {
            var g = getGroup();

            if (g != null) {
                g.sendUpdateToPlayer(getGUID());
            }
        }

        //we have executed ALL delayed ops, so clear the flag
        delayedOperations = PlayerDelayedOperations.forValue(0);
    }

    //Network
    public final void sendPacket(WorldPacket packet) {
        session.sendPacket(data);
    }

    public final void createGarrison(int garrSiteId) {
        garrison = new Garrison(this);

        if (!garrison.create(garrSiteId)) {
            garrison = null;
        }
    }

    public final void setAdvancedCombatLogging(boolean enabled) {
        advancedCombatLoggingEnabled = enabled;
    }

    public final void setInvSlot(int slot, ObjectGuid guid) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().invSlots, (int) slot), guid);
    }

    //Taxi
    public final void initTaxiNodesForLevel() {
        getTaxi().initTaxiNodesForLevel(getRace(), getClass(), getLevel());
    }

    //Cheat Commands
    public final boolean getCommandStatus(PlayerCommandStates command) {
        return (activeCheats.getValue() & command.getValue()) != 0;
    }

    public final void setCommandStatusOn(PlayerCommandStates command) {
        activeCheats = PlayerCommandStates.forValue(activeCheats.getValue() | command.getValue());
    }

    public final void setCommandStatusOff(PlayerCommandStates command) {
        activeCheats = PlayerCommandStates.forValue(activeCheats.getValue() & ~command.getValue());
    }

    public final void unsummonPetTemporaryIfAny() {
        var pet = getCurrentPet();

        if (!pet) {
            return;
        }

        if (temporaryUnsummonedPetNumber == 0 && pet.isControlled() && !pet.isTemporarySummoned()) {
            temporaryUnsummonedPetNumber = pet.getCharmInfo().getPetNumber();
            oldpetspell = pet.getUnitData().createdBySpell;
        }

        removePet(pet, PetSaveMode.AsCurrent);
    }

    public final void resummonPetTemporaryUnSummonedIfAny() {
        if (temporaryUnsummonedPetNumber == 0) {
            return;
        }

        // not resummon in not appropriate state
        if (isPetNeedBeTemporaryUnsummoned()) {
            return;
        }

        if (!getPetGUID().isEmpty()) {
            return;
        }

        Pet NewPet = new pet(this);
        NewPet.LoadPetFromDB(this, 0, temporaryUnsummonedPetNumber, true);

        temporaryUnsummonedPetNumber = 0;
    }

    public final boolean isPetNeedBeTemporaryUnsummoned() {
        return !isInWorld() || !isAlive() || isMounted();
    }

    public final void sendRemoveControlBar() {
        sendPacket(new PetSpells());
    }

    public final Creature getSummonedBattlePet() {
        var summonedBattlePet = ObjectAccessor.GetCreatureOrPetOrVehicle(this, getCritterGUID());

        if (summonedBattlePet != null) {
            if (!getSummonedBattlePetGUID().isEmpty() && Objects.equals(getSummonedBattlePetGUID(), summonedBattlePet.getBattlePetCompanionGUID())) {
                return summonedBattlePet;
            }
        }

        return null;
    }

    public final void setBattlePetData() {
        setBattlePetData(null);
    }

    public final void setBattlePetData(BattlePet pet) {
        if (pet != null) {
            setSummonedBattlePetGUID(pet.packetInfo.guid);
            setCurrentBattlePetBreedQuality(pet.packetInfo.quality);
            setBattlePetCompanionExperience(pet.packetInfo.exp);
            setWildBattlePetLevel(pet.packetInfo.level);
        } else {
            setSummonedBattlePetGUID(ObjectGuid.Empty);
            setCurrentBattlePetBreedQuality((byte) battlePetBreedQuality.Poor.getValue());
            setBattlePetCompanionExperience(0);
            setWildBattlePetLevel(0);
        }
    }

    public final void stopCastingCharm() {
        var charm = getCharmed();

        if (!charm) {
            return;
        }

        if (charm.isTypeId(TypeId.UNIT)) {
            if (charm.toCreature().hasUnitTypeMask(UnitTypeMask.Puppet)) {
                ((Puppet) charm).unSummon();
            } else if (charm.isVehicle()) {
                exitVehicle();

                // Temporary for issue https://github.com/TrinityCore/TrinityCore/issues/24876
                if (!getCharmedGUID().isEmpty() && !charm.hasAuraTypeWithCaster(AuraType.ControlVehicle, getGUID())) {
                    Log.outFatal(LogFilter.player, String.format("Player::StopCastingCharm Player '%1$s' (%2$s) is not able to uncharm vehicle (%3$s) because of missing SPELL_AURA_CONTROL_VEHICLE", getName(), getGUID(), getCharmedGUID()));

                    // attempt to recover from missing HandleAuraControlVehicle unapply handling
                    // THIS IS A HACK, NEED TO FIND HOW IS IT EVEN POSSBLE TO NOT HAVE THE AURA
                    _ExitVehicle();
                }
            }
        }

        if (!getCharmedGUID().isEmpty()) {
            charm.removeCharmAuras();
        }

        if (!getCharmedGUID().isEmpty()) {
            Log.outFatal(LogFilter.player, "Player {0} (GUID: {1} is not able to uncharm unit (GUID: {2} Entry: {3}, Type: {4})", getName(), getGUID(), getCharmedGUID(), charm.getEntry(), charm.getTypeId());

            if (!charm.getCharmerGUID().isEmpty()) {
                Log.outFatal(LogFilter.player, String.format("Player::StopCastingCharm: Charmed unit has charmer %1$s\nPlayer debug info: %2$s\nCharm debug info: %3$s", charm.getCharmerGUID(), getDebugInfo(), charm.getDebugInfo()));
            } else {
                setCharm(charm, false);
            }
        }
    }

    public final void charmSpellInitialize() {
        var charm = getFirstControlled();

        if (!charm) {
            return;
        }

        var charmInfo = charm.getCharmInfo();

        if (charmInfo == null) {
            Log.outError(LogFilter.player, "Player:CharmSpellInitialize(): the player's charm ({0}) has no charminfo!", charm.getGUID());

            return;
        }

        PetSpells petSpells = new PetSpells();
        petSpells.petGUID = charm.getGUID();

        if (charm.isTypeId(TypeId.UNIT)) {
            petSpells.reactState = charm.toCreature().getReactState();
            petSpells.commandState = charmInfo.getCommandState();
        }

        for (byte i = 0; i < SharedConst.ActionBarIndexMax; ++i) {
            petSpells.ActionButtons[i] = charmInfo.getActionBarEntry(i).packedData;
        }

        for (byte i = 0; i < SharedConst.MaxSpellCharm; ++i) {
            var cspell = charmInfo.getCharmSpell(i);

            if (cspell.getAction() != 0) {
                petSpells.actions.add(cspell.packedData);
            }
        }

        // Cooldowns
        if (!charm.isTypeId(TypeId.PLAYER)) {
            charm.getSpellHistory().writePacket(petSpells);
        }

        sendPacket(petSpells);
    }

    public final void possessSpellInitialize() {
        var charm = getCharmed();

        if (!charm) {
            return;
        }

        var charmInfo = charm.getCharmInfo();

        if (charmInfo == null) {
            Log.outError(LogFilter.player, "Player:PossessSpellInitialize(): charm ({0}) has no charminfo!", charm.getGUID());

            return;
        }

        PetSpells petSpellsPacket = new PetSpells();
        petSpellsPacket.petGUID = charm.getGUID();

        for (byte i = 0; i < SharedConst.ActionBarIndexMax; ++i) {
            petSpellsPacket.ActionButtons[i] = charmInfo.getActionBarEntry(i).packedData;
        }

        // Cooldowns
        charm.getSpellHistory().writePacket(petSpellsPacket);

        sendPacket(petSpellsPacket);
    }

    public final void vehicleSpellInitialize() {
        var vehicle = getVehicleCreatureBase();

        if (!vehicle) {
            return;
        }

        PetSpells petSpells = new PetSpells();
        petSpells.petGUID = vehicle.getGUID();
        petSpells.creatureFamily = 0; // Pet family (0 for all vehicles)
        petSpells.specialization = 0;
        petSpells.timeLimit = vehicle.isSummon() ? vehicle.toTempSummon().getTimer() : 0;
        petSpells.reactState = vehicle.getReactState();
        petSpells.commandState = CommandStates.Follow;
        petSpells.flag = 0x8;

        for (int i = 0; i < SharedConst.MaxSpellControlBar; ++i) {
            petSpells.ActionButtons[i] = UnitActionBarEntry.MAKE_UNIT_ACTION_BUTTON(0, i + 8);
        }

        for (int i = 0; i < SharedConst.MaxCreatureSpells; ++i) {
            var spellId = vehicle.getSpells()[i];
            var spellInfo = global.getSpellMgr().getSpellInfo(spellId, getMap().getDifficultyID());

            if (spellInfo == null) {
                continue;
            }

            if (spellInfo.hasAttribute(SpellAttr5.NotAvailableWhileCharmed)) {
                continue;
            }

            if (!global.getConditionMgr().isObjectMeetingVehicleSpellConditions(vehicle.getEntry(), spellId, this, vehicle)) {
                Log.outDebug(LogFilter.condition, "VehicleSpellInitialize: conditions not met for Vehicle entry {0} spell {1}", vehicle.toCreature().getEntry(), spellId);

                continue;
            }

            if (spellInfo.isPassive()) {
                vehicle.castSpell(vehicle, spellInfo.getId(), true);
            }

            petSpells.ActionButtons[i] = UnitActionBarEntry.MAKE_UNIT_ACTION_BUTTON(spellId, i + 8);
        }

        // Cooldowns
        vehicle.getSpellHistory().writePacket(petSpells);

        sendPacket(petSpells);
    }

    public final void modifyCurrency(int id, int amount, CurrencyGainSource gainSource) {
        modifyCurrency(id, amount, gainSource, CurrencyDestroyReason.Cheat);
    }

    public final void modifyCurrency(int id, int amount) {
        modifyCurrency(id, amount, CurrencyGainSource.Cheat, CurrencyDestroyReason.Cheat);
    }

    public final void modifyCurrency(int id, int amount, CurrencyGainSource gainSource, CurrencyDestroyReason destroyReason) {
        if (amount == 0) {
            return;
        }

        var currency = CliDB.CurrencyTypesStorage.get(id);

        // Check faction
        if ((currency.IsAlliance() && getTeam() != Team.ALLIANCE) || (currency.IsHorde() && getTeam() != Team.Horde)) {
            return;
        }

        // Check award condition
        if (currency.AwardConditionID != 0) {
            var playerCondition = CliDB.PlayerConditionStorage.get(currency.AwardConditionID);

            if (playerCondition != null && !ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                return;
            }
        }

        var isGainOnRefund = false;

        if (gainSource == CurrencyGainSource.ItemRefund || gainSource == CurrencyGainSource.GarrisonBuildingRefund || gainSource == CurrencyGainSource.PlayerTraitRefund) {
            isGainOnRefund = true;
        }

        if (amount > 0 && !isGainOnRefund && gainSource != CurrencyGainSource.vendor) {
            amount = (int) (amount * getTotalAuraMultiplierByMiscValue(AuraType.ModCurrencyGain, (int) id));
            amount = (int) (amount * getTotalAuraMultiplierByMiscValue(AuraType.ModCurrencyCategoryGainPct, currency.categoryID));
        }

        var scaler = currency.GetScaler();

        // Currency that is immediately converted into reputation with that faction instead
        var factionEntry = CliDB.FactionStorage.get(currency.factionID);

        if (factionEntry != null) {
            amount /= scaler;
            getReputationMgr().modifyReputation(factionEntry, amount, false, true);

            return;
        }

        // Azerite
        if (id == (int) CurrencyTypes.Azerite.getValue()) {
            if (amount > 0) {
                var heartOfAzeroth = getItemByEntry(PlayerConst.ItemIdHeartOfAzeroth, ItemSearchLocation.Everywhere);

                if (heartOfAzeroth != null) {
                    heartOfAzeroth.getAsAzeriteItem().giveXP((long) amount);
                }
            }

            return;
        }

        var playerCurrency = currencyStorage.get(id);

        if (playerCurrency == null) {
            playerCurrency = new PlayerCurrency();
            playerCurrency.state = PlayerCurrencyState.New;
            currencyStorage.put(id, playerCurrency);
        }

        // Weekly cap
        var weeklyCap = getCurrencyWeeklyCap(currency);

        if (weeklyCap != 0 && amount > 0 && (playerCurrency.weeklyQuantity + amount) > weeklyCap) {
            if (!isGainOnRefund) // Ignore weekly cap for refund
            {
                amount = (int) (weeklyCap - playerCurrency.weeklyQuantity);
            }
        }

        // Max cap
        var maxCap = getCurrencyMaxQuantity(currency, false, gainSource == CurrencyGainSource.UpdatingVersion);

        if (maxCap != 0 && amount > 0 && (playerCurrency.quantity + amount) > maxCap) {
            amount = (int) (maxCap - playerCurrency.quantity);
        }

        // Underflow protection
        if (amount < 0 && Math.abs(amount) > playerCurrency.quantity) {
            amount = (int) (playerCurrency.Quantity * -1);
        }

        if (amount == 0) {
            return;
        }

        if (playerCurrency.state != PlayerCurrencyState.New) {
            playerCurrency.state = PlayerCurrencyState.changed;
        }

        playerCurrency.quantity += (int) amount;

        if (amount > 0 && !isGainOnRefund) // Ignore total values update for refund
        {
            if (weeklyCap != 0) {
                playerCurrency.weeklyQuantity += (int) amount;
            }

            if (currency.IsTrackingQuantity()) {
                playerCurrency.trackedQuantity += (int) amount;
            }

            if (currency.HasTotalEarned()) {
                playerCurrency.earnedQuantity += (int) amount;
            }

            updateCriteria(CriteriaType.CurrencyGained, id, (long) amount);
        }

        currencyChanged(id, amount);

        SetCurrency packet = new SetCurrency();
        packet.type = currency.id;
        packet.quantity = (int) playerCurrency.quantity;
        packet.flags = CurrencyGainFlags.NONE; // TODO: Check when flags are applied

        if ((playerCurrency.WeeklyQuantity / currency.GetScaler()) > 0) {
            packet.weeklyQuantity = (int) playerCurrency.weeklyQuantity;
        }

        if (currency.HasMaxQuantity(false, gainSource == CurrencyGainSource.UpdatingVersion)) {
            packet.maxQuantity = (int) getCurrencyMaxQuantity(currency);
        }

        if (currency.HasTotalEarned()) {
            packet.totalEarned = (int) playerCurrency.earnedQuantity;
        }

        packet.suppressChatLog = currency.IsSuppressingChatLog(gainSource == CurrencyGainSource.UpdatingVersion);
        packet.quantityChange = amount;

        if (amount > 0) {
            packet.quantityGainSource = gainSource;
        } else {
            packet.quantityLostSource = destroyReason;
        }

        // TODO: firstCraftOperationID, lastSpendTime & Toasts
        sendPacket(packet);
    }

    public final void addCurrency(int id, int amount) {
        addCurrency(id, amount, CurrencyGainSource.Cheat);
    }

    public final void addCurrency(int id, int amount, CurrencyGainSource gainSource) {
        modifyCurrency(id, (int) amount, gainSource);
    }

    public final void removeCurrency(int id, int amount) {
        removeCurrency(id, amount, CurrencyDestroyReason.Cheat);
    }

    public final void removeCurrency(int id, int amount, CurrencyDestroyReason destroyReason) {
        modifyCurrency(id, -amount, null, destroyReason);
    }

    public final void increaseCurrencyCap(int id, int amount) {
        if (amount == 0) {
            return;
        }

        var currency = CliDB.CurrencyTypesStorage.get(id);

        // Check faction
        if ((currency.IsAlliance() && getTeam() != Team.ALLIANCE) || (currency.IsHorde() && getTeam() != Team.Horde)) {
            return;
        }

        // Check dynamic maximum flag
        if (!currency.getFlags().hasFlag(CurrencyTypesFlags.DynamicMaximum)) {
            return;
        }

        // Ancient mana maximum cap
        if (id == (int) CurrencyTypes.AncientMana.getValue()) {
            var maxQuantity = getCurrencyMaxQuantity(currency);

            if ((maxQuantity + amount) > PlayerConst.CurrencyMaxCapAncientMana) {
                amount = PlayerConst.CurrencyMaxCapAncientMana - maxQuantity;
            }
        }

        var playerCurrency = currencyStorage.get(id);

        if (playerCurrency == null) {
            playerCurrency = new PlayerCurrency();
            playerCurrency.state = PlayerCurrencyState.New;
            playerCurrency.increasedCapQuantity = amount;
            currencyStorage.put(id, playerCurrency);
        } else {
            playerCurrency.increasedCapQuantity += amount;
        }

        if (playerCurrency.state != PlayerCurrencyState.New) {
            playerCurrency.state = PlayerCurrencyState.changed;
        }

        SetCurrency packet = new SetCurrency();
        packet.type = currency.id;
        packet.quantity = (int) playerCurrency.quantity;
        packet.flags = CurrencyGainFlags.NONE;

        if ((playerCurrency.WeeklyQuantity / currency.GetScaler()) > 0) {
            packet.weeklyQuantity = (int) playerCurrency.weeklyQuantity;
        }

        if (currency.IsTrackingQuantity()) {
            packet.trackedQuantity = (int) playerCurrency.trackedQuantity;
        }

        packet.maxQuantity = (int) getCurrencyMaxQuantity(currency);
        packet.suppressChatLog = currency.IsSuppressingChatLog();

        sendPacket(packet);
    }

    public final int getCurrencyQuantity(int id) {
        var playerCurrency = currencyStorage.get(id);

        if (playerCurrency == null) {
            return 0;
        }

        return playerCurrency.quantity;
    }

    public final int getCurrencyWeeklyQuantity(int id) {
        var playerCurrency = currencyStorage.get(id);

        if (playerCurrency == null) {
            return 0;
        }

        return playerCurrency.weeklyQuantity;
    }

    public final int getCurrencyTrackedQuantity(int id) {
        var playerCurrency = currencyStorage.get(id);

        if (playerCurrency == null) {
            return 0;
        }

        return playerCurrency.trackedQuantity;
    }

    public final int getCurrencyMaxQuantity(CurrencyTypesRecord currency, boolean onLoad) {
        return getCurrencyMaxQuantity(currency, onLoad, false);
    }

    public final int getCurrencyMaxQuantity(CurrencyTypesRecord currency) {
        return getCurrencyMaxQuantity(currency, false, false);
    }

    public final int getCurrencyMaxQuantity(CurrencyTypesRecord currency, boolean onLoad, boolean onUpdateVersion) {
        if (!currency.HasMaxQuantity(onLoad, onUpdateVersion)) {
            return 0;
        }

        var maxQuantity = currency.MaxQty;

        if (currency.MaxQtyWorldStateID != 0) {
            maxQuantity = (int) global.getWorldStateMgr().getValue(currency.MaxQtyWorldStateID, getMap());
        }

        int increasedCap = 0;

        if (currency.getFlags().hasFlag(CurrencyTypesFlags.DynamicMaximum)) {
            increasedCap = getCurrencyIncreasedCapQuantity(currency.id);
        }

        return maxQuantity + increasedCap;
    }

    public final boolean hasCurrency(int id, int amount) {
        var playerCurrency = currencyStorage.get(id);

        return playerCurrency != null && playerCurrency.quantity >= amount;
    }

    //Action Buttons - CUF Profile
    public final void saveCUFProfile(byte id, CufProfile profile) {
        _cufProfiles[id] = profile;
    }

    public final CufProfile getCUFProfile(byte id) {
        return _cufProfiles[id];
    }

    public final void setMultiActionBars(byte mask) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().multiActionBars), mask);
    }

    public final ActionButton addActionButton(byte button, long action, int type) {
        if (!isActionButtonDataValid(button, action, type)) {
            return null;
        }

        // it create new button (NEW state) if need or return existed
        if (!actionButtons.containsKey(button)) {
            actionButtons.put(button, new ActionButton());
        }

        var ab = actionButtons.get(button);

        // set data and update to CHANGED if not NEW
        ab.setActionAndType(action, ActionButtonType.forValue(type));

        Log.outDebug(LogFilter.player, String.format("Player::AddActionButton: Player '%1$s' (%2$s) added action '%3$s' (type %4$s) to button '%5$s'", getName(), getGUID(), action, type, button));

        return ab;
    }

    public final void removeActionButton(byte _button) {
        var button = actionButtons.get(_button);

        if (button == null || button.UState == ActionButtonUpdateState.Deleted) {
            return;
        }

        if (button.UState == ActionButtonUpdateState.New) {
            actionButtons.remove(_button); // new and not saved
        } else {
            button.UState = ActionButtonUpdateState.Deleted; // saved, will deleted at next save
        }

        Log.outDebug(LogFilter.player, "Action Button '{0}' Removed from Player '{1}'", button, getGUID().toString());
    }

    public final ActionButton getActionButton(byte _button) {
        var button = actionButtons.get(_button);

        if (button == null || button.UState == ActionButtonUpdateState.Deleted) {
            return null;
        }

        return button;
    }

    public final int calculateReputationGain(ReputationSource source, int creatureOrQuestLevel, int rep, int faction) {
        return calculateReputationGain(source, creatureOrQuestLevel, rep, faction, false);
    }

    public final int calculateReputationGain(ReputationSource source, int creatureOrQuestLevel, int rep, int faction, boolean noQuestBonus) {
        var noBonuses = false;
        var factionEntry = CliDB.FactionStorage.get(faction);

        if (factionEntry != null) {
            var friendshipReputation = CliDB.FriendshipReputationStorage.get(factionEntry.FriendshipRepID);

            if (friendshipReputation != null) {
                if (friendshipReputation.flags.hasFlag(FriendshipReputationFlags.NoRepGainModifiers)) {
                    noBonuses = true;
                }
            }
        }

        double percent = 100.0f;

        if (!noBonuses) {
            var repMod = noQuestBonus ? 0.0f : getTotalAuraModifier(AuraType.ModReputationGain);

            // faction specific auras only seem to apply to kills
            if (source == ReputationSource.kill) {
                repMod += getTotalAuraModifierByMiscValue(AuraType.ModFactionReputationGain, faction);
            }

            percent += rep > 0 ? repMod : -repMod;
        }

        float rate;

        switch (source) {
            case Kill:
                rate = WorldConfig.getFloatValue(WorldCfg.RateReputationLowLevelKill);

                break;
            case Quest:
            case DailyQuest:
            case WeeklyQuest:
            case MonthlyQuest:
            case RepeatableQuest:
                rate = WorldConfig.getFloatValue(WorldCfg.RateReputationLowLevelQuest);

                break;
            case Spell:
            default:
                rate = 1.0f;

                break;
        }

        if (rate != 1.0f && creatureOrQuestLevel < Formulas.getGrayLevel(getLevel())) {
            percent *= rate;
        }

        if (percent <= 0.0f) {
            return 0;
        }

        // Multiply result with the faction specific rate
        var repData = global.getObjectMgr().getRepRewardRate((int) faction);

        if (repData != null) {
            var repRate = 0.0f;

            switch (source) {
                case Kill:
                    repRate = repData.creatureRate;

                    break;
                case Quest:
                    repRate = repData.questRate;

                    break;
                case DailyQuest:
                    repRate = repData.questDailyRate;

                    break;
                case WeeklyQuest:
                    repRate = repData.questWeeklyRate;

                    break;
                case MonthlyQuest:
                    repRate = repData.questMonthlyRate;

                    break;
                case RepeatableQuest:
                    repRate = repData.questRepeatableRate;

                    break;
                case Spell:
                    repRate = repData.spellRate;

                    break;
            }

            // for custom, a rate of 0.0 will totally disable reputation gain for this faction/type
            if (repRate <= 0.0f) {
                return 0;
            }

            percent *= repRate;
        }

        if (source != ReputationSource.spell && getsRecruitAFriendBonus(false)) {
            percent *= 1.0f + WorldConfig.getFloatValue(WorldCfg.RateReputationRecruitAFriendBonus);
        }

        return MathUtil.CalculatePct(rep, percent);
    }

    // Calculates how many reputation points player gains in victim's enemy factions
    public final void rewardReputation(Unit victim, float rate) {
        if (!victim || victim.isTypeId(TypeId.PLAYER)) {
            return;
        }

        if (victim.toCreature().isReputationGainDisabled()) {
            return;
        }

        var Rep = global.getObjectMgr().getReputationOnKilEntry(victim.toCreature().getTemplate().entry);

        if (Rep == null) {
            return;
        }

        int ChampioningFaction = 0;

        if (getChampioningFaction() != 0) {
            // support for: Championing - http://www.wowwiki.com/Championing
            var map = getMap();

            if (map.isNonRaidDungeon()) {
                var dungeon = global.getDB2Mgr().GetLfgDungeon(map.getId(), map.getDifficultyID());

                if (dungeon != null) {
                    var dungeonLevels = global.getDB2Mgr().GetContentTuningData(dungeon.contentTuningID, getPlayerData().ctrOptions.getValue().contentTuningConditionMask);

                    if (dungeonLevels != null) {
                        if (dungeonLevels.getValue().TargetLevelMax == global.getObjectMgr().getMaxLevelForExpansion(expansion.WrathOfTheLichKing)) {
                            ChampioningFaction = getChampioningFaction();
                        }
                    }
                }
            }
        }

        var team = getTeam();

        if (Rep.repFaction1 != 0 && (!Rep.teamDependent || team == Team.ALLIANCE)) {
            var donerep1 = calculateReputationGain(ReputationSource.kill, victim.getLevelForTarget(this), Rep.repValue1, (int) (ChampioningFaction != 0 ? ChampioningFaction : Rep.repFaction1));
            donerep1 = (int) (donerep1 * rate);

            var factionEntry1 = CliDB.FactionStorage.get(ChampioningFaction != 0 ? ChampioningFaction : Rep.repFaction1);
            var current_reputation_rank1 = getReputationMgr().getRank(factionEntry1);

            if (factionEntry1 != null) {
                getReputationMgr().modifyReputation(factionEntry1, donerep1, (int) current_reputation_rank1.getValue() > Rep.reputationMaxCap1);
            }
        }

        if (Rep.repFaction2 != 0 && (!Rep.teamDependent || team == Team.Horde)) {
            var donerep2 = calculateReputationGain(ReputationSource.kill, victim.getLevelForTarget(this), Rep.repValue2, (int) (ChampioningFaction != 0 ? ChampioningFaction : Rep.repFaction2));
            donerep2 = (int) (donerep2 * rate);

            var factionEntry2 = CliDB.FactionStorage.get(ChampioningFaction != 0 ? ChampioningFaction : Rep.repFaction2);
            var current_reputation_rank2 = getReputationMgr().getRank(factionEntry2);

            if (factionEntry2 != null) {
                getReputationMgr().modifyReputation(factionEntry2, donerep2, (int) current_reputation_rank2.getValue() > Rep.reputationMaxCap2);
            }
        }
    }

    public final boolean teleportTo(WorldLocation loc, TeleportToOptions options) {
        return teleportTo(loc, options, null);
    }

    public final boolean teleportTo(WorldLocation loc) {
        return teleportTo(loc, 0, null);
    }

    public final boolean teleportTo(WorldLocation loc, TeleportToOptions options, Integer instanceId) {
        return teleportTo(loc.getMapId(), loc.getX(), loc.getY(), loc.getZ(), loc.getO(), options, instanceId);
    }

    public final boolean teleportTo(int mapid, Position loc, TeleportToOptions options) {
        return teleportTo(mapid, loc, options, null);
    }

    public final boolean teleportTo(int mapid, Position loc) {
        return teleportTo(mapid, loc, 0, null);
    }

    public final boolean teleportTo(int mapid, Position loc, TeleportToOptions options, Integer instanceId) {
        return teleportTo(mapid, loc.getX(), loc.getY(), loc.getZ(), loc.getO(), options, instanceId);
    }

    public final boolean teleportTo(int mapid, float x, float y, float z, float orientation, TeleportToOptions options) {
        return teleportTo(mapid, x, y, z, orientation, options, null);
    }

    public final boolean teleportTo(int mapid, float x, float y, float z, float orientation) {
        return teleportTo(mapid, x, y, z, orientation, 0, null);
    }

    public final boolean teleportTo(int mapid, float x, float y, float z, float orientation, TeleportToOptions options, Integer instanceId) {
        if (!MapDefine.isValidMapCoordinatei(mapid, x, y, z, orientation)) {
            Logs.MAPS.error("TeleportTo: invalid map ({0}) or invalid coordinates (X: {1}, Y: {2}, Z: {3}, O: {4}) given when teleporting player (GUID: {5}, name: {6}, map: {7}, {8}).", mapid, x, y, z, orientation, getGUID().toString(), getName(), getLocation().getMapId(), getLocation().toString());

            return false;
        }

        if (!getSession().hasPermission(RBACPermissions.SkipCheckDisableMap) && global.getDisableMgr().isDisabledFor(DisableType.Map, mapid, this)) {
            Logs.MAPS.error("Player (GUID: {0}, name: {1}) tried to enter a forbidden map {2}", getGUID().toString(), getName(), mapid);
            sendTransferAborted(mapid, TransferAbortReason.MapNotAllowed);

            return false;
        }

        // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
        var pet = getCurrentPet();

        var mEntry = CliDB.MapStorage.get(mapid);

        // don't let enter Battlegrounds without assigned Battlegroundid (for example through areatrigger)...
        // don't let gm level > 1 either
        if (!getInBattleground() && mEntry.IsBattlegroundOrArena()) {
            return false;
        }

        // client without expansion support
        if (getSession().getExpansion().getValue() < mEntry.expansion()) {
            Logs.MAPS.debug("Player {0} using client without required expansion tried teleport to non accessible map {1}", getName(), mapid);

            var transport = getTransport();

            if (transport != null) {
                transport.removePassenger(this);
                repopAtGraveyard(); // teleport to near graveyard if on transport, looks blizz like :)
            }

            sendTransferAborted(mapid, TransferAbortReason.InsufExpanLvl, (byte) mEntry.expansion());

            return false; // normal client can't teleport to this map...
        } else {
            Logs.MAPS.debug("Player {0} is being teleported to map {1}", getName(), mapid);
        }

        if (getVehicle() != null) {
            exitVehicle();
        }

        // reset movement flags at teleport, because player will continue move with these flags after teleport
        setUnitMovementFlags(getUnitMovementFlags().getValue() & MovementFlag.MaskHasPlayerStatusOpcode.getValue());
        getMovementInfo().resetJump();
        disableSpline();
        getMotionMaster().remove(MovementGeneratorType.effect);

        var transport = getTransport();

        if (transport != null) {
            if (!options.hasFlag(TeleportToOptions.NotLeaveTransport)) {
                transport.removePassenger(this);
            }
        }

        // The player was ported to another map and loses the duel immediately.
        // We have to perform this check before the teleport, otherwise the
        // ObjectAccessor won't find the flag.
        if (getDuel() != null && getLocation().getMapId() != mapid && getMap().getGameObject(getPlayerData().duelArbiter)) {
            duelComplete(DuelCompleteType.fled);
        }

        if (getLocation().getMapId() == mapid && (instanceId == null || instanceId.equals(getInstanceId()))) {
            //lets reset far teleport flag if it wasn't reset during chained teleports
            setSemaphoreTeleportFar(false);
            //setup delayed teleport flag
            setDelayedTeleportFlag(isCanDelayTeleport());

            //if teleport spell is casted in unit.update() func
            //then we need to delay it until update process will be finished
            if (isHasDelayedTeleport()) {
                setSemaphoreTeleportNear(true);
                //lets save teleport destination for player
                teleportDest = new worldLocation(mapid, x, y, z, orientation);
                teleportInstanceId = null;
                teleportOptions = options;

                return true;
            }

            if (!options.hasFlag(TeleportToOptions.NotUnSummonPet)) {
                //same map, only remove pet if out of range for new Position
                if (pet && !pet.isWithinDist3d(x, y, z, getMap().getVisibilityRange())) {
                    unsummonPetTemporaryIfAny();
                }
            }

            if (!isAlive() && options.hasFlag(TeleportToOptions.ReviveAtTeleport)) {
                resurrectPlayer(0.5f);
            }

            if (!options.hasFlag(TeleportToOptions.NotLeaveCombat)) {
                combatStop();
            }

            // this will be used instead of the current location in SaveToDB
            teleportDest = new worldLocation(mapid, x, y, z, orientation);
            teleportInstanceId = null;
            teleportOptions = options;
            setFallInformation(0, getLocation().getZ());

            // code for finish transfer called in WorldSession.HandleMovementOpcodes()
            // at client packet CMSG_MOVE_TELEPORT_ACK
            setSemaphoreTeleportNear(true);

            // near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
            if (!getSession().getPlayerLogout()) {
                sendTeleportPacket(teleportDest);
            }
        } else {
            if (getClass() == playerClass.Deathknight && getLocation().getMapId() == 609 && !isGameMaster() && !hasSpell(50977)) {
                sendTransferAborted(mapid, TransferAbortReason.UniqueMessage, (byte) 1);

                return false;
            }

            // far teleport to another map
            var oldmap = isInWorld() ? getMap() : null;
            // check if we can enter before stopping combat / removing pet / totems / interrupting spells

            // Check enter rights before map getting to avoid creating instance copy for player
            // this check not dependent from map instance copy and same for all instance copies of selected map
            var abortParams = Map.playerCannotEnter(mapid, this);

            if (abortParams != null) {
                sendTransferAborted(mapid, abortParams.getReason(), abortParams.getArg(), abortParams.getMapDifficultyXConditionId());

                return false;
            }

            // Seamless teleport can happen only if cosmetic maps match
            if (!oldmap || (oldmap.getEntry().CosmeticParentMapID != mapid && getLocation().getMapId() != mEntry.CosmeticParentMapID && !((oldmap.getEntry().CosmeticParentMapID != -1) ^ (oldmap.getEntry().CosmeticParentMapID != mEntry.CosmeticParentMapID)))) {
                options = TeleportToOptions.forValue(options.getValue() & ~TeleportToOptions.Seamless.getValue());
            }

            //lets reset near teleport flag if it wasn't reset during chained teleports
            setSemaphoreTeleportNear(false);
            //setup delayed teleport flag
            setDelayedTeleportFlag(isCanDelayTeleport());

            //if teleport spell is cast in Unit::Update() func
            //then we need to delay it until update process will be finished
            if (isHasDelayedTeleport()) {
                setSemaphoreTeleportFar(true);
                //lets save teleport destination for player
                teleportDest = new worldLocation(mapid, x, y, z, orientation);
                teleportInstanceId = instanceId;
                teleportOptions = options;

                return true;
            }

            setSelection(ObjectGuid.Empty);

            combatStop();

            resetContestedPvP();

            // remove player from Battlegroundon far teleport (when changing maps)
            var bg = getBattleground();

            if (bg) {
                // Note: at Battlegroundjoin Battlegroundid set before teleport
                // and we already will found "current" Battleground
                // just need check that this is targeted map or leave
                if (bg.getMapId() != mapid) {
                    leaveBattleground(false); // don't teleport to entry point
                }
            }

            // remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
            if (mEntry.IsBattleArena() && !isGameMaster()) {
                removeArenaSpellCooldowns(true);
                removeArenaAuras();

                if (pet) {
                    pet.removeArenaAuras();
                }
            }

            // remove pet on map change
            if (pet) {
                unsummonPetTemporaryIfAny();
            }

            // remove all dyn objects
            removeAllDynObjects();

            // remove all areatriggers entities
            removeAllAreaTriggers();

            // stop spellcasting
            // not attempt interrupt teleportation spell at caster teleport
            if (!options.hasFlag(TeleportToOptions.spell)) {
                if (isNonMeleeSpellCast(true)) {
                    interruptNonMeleeSpells(true);
                }
            }

            //remove auras before removing from map...
            removeAurasWithInterruptFlags(SpellAuraInterruptFlags.Moving.getValue() | SpellAuraInterruptFlags.Turning.getValue());

            if (!getSession().getPlayerLogout() && !options.hasFlag(TeleportToOptions.Seamless)) {
                // send transfer packets
                TransferPending transferPending = new TransferPending();
                transferPending.mapID = (int) mapid;
                transferPending.oldMapPosition = getLocation();

                var transport1 = (transport) getTransport();

                if (transport1 != null) {
                    TransferPending.ShipTransferPending shipTransferPending = new TransferPending.ShipTransferPending();
                    shipTransferPending.id = transport1.getEntry();
                    shipTransferPending.originMapID = (int) getLocation().getMapId();
                    transferPending.ship = shipTransferPending;
                }

                sendPacket(transferPending);
            }

            // remove from old map now
            if (oldmap != null) {
                oldmap.removePlayerFromMap(this, false);
            }

            teleportDest = new worldLocation(mapid, x, y, z, orientation);
            teleportInstanceId = instanceId;
            teleportOptions = options;
            setFallInformation(0, getLocation().getZ());
            // if the player is saved before worldportack (at logout for example)
            // this will be used instead of the current location in SaveToDB

            if (!getSession().getPlayerLogout()) {
                SuspendToken suspendToken = new SuspendToken();
                suspendToken.sequenceIndex = getMovementCounter(); // not incrementing
                suspendToken.reason = options.hasFlag(TeleportToOptions.Seamless) ? 2 : 1;
                sendPacket(suspendToken);
            }

            // move packet sent by client always after far teleport
            // code for finish transfer to new map called in WorldSession.HandleMoveWorldportAckOpcode at client packet
            setSemaphoreTeleportFar(true);
        }

        return true;
    }

    public final boolean teleportToBGEntryPoint() {
        if (bgData.getJoinPos().getMapId() == 0xFFFFFFFF) {
            return false;
        }

        scheduleDelayedOperation(PlayerDelayedOperations.BGMountRestore);
        scheduleDelayedOperation(PlayerDelayedOperations.BGTaxiRestore);
        scheduleDelayedOperation(PlayerDelayedOperations.BGGroupRestore);

        return teleportTo(bgData.getJoinPos());
    }

    public final int getStartLevel(Race race, PlayerClass playerClass) {
        return getStartLevel(race, playerClass, null);
    }

    public final int getStartLevel(Race race, PlayerClass playerClass, Integer characterTemplateId) {
        var startLevel = WorldConfig.getUIntValue(WorldCfg.StartPlayerLevel);

        if (CliDB.ChrRacesStorage.get(race).getFlags().hasFlag(ChrRacesFlag.IsAlliedRace)) {
            startLevel = WorldConfig.getUIntValue(WorldCfg.StartAlliedRaceLevel);
        }

        if (playerClass == playerClass.Deathknight) {
            if (race == race.PandarenAlliance || race == race.PandarenHorde) {
                startLevel = Math.max(WorldConfig.getUIntValue(WorldCfg.StartAlliedRaceLevel), startLevel);
            } else {
                startLevel = Math.max(WorldConfig.getUIntValue(WorldCfg.StartDeathKnightPlayerLevel), startLevel);
            }
        } else if (playerClass == playerClass.DemonHunter) {
            startLevel = Math.max(WorldConfig.getUIntValue(WorldCfg.StartDemonHunterPlayerLevel), startLevel);
        } else if (playerClass == playerClass.Evoker) {
            startLevel = Math.max(WorldConfig.getUIntValue(WorldCfg.StartEvokerPlayerLevel), startLevel);
        }

        if (characterTemplateId != null) {
            if (getSession().hasPermission(RBACPermissions.UseCharacterTemplates)) {
                var charTemplate = global.getCharacterTemplateDataStorage().GetCharacterTemplate(characterTemplateId.intValue());

                if (charTemplate != null) {
                    startLevel = Math.max(charTemplate.level, startLevel);
                }
            } else {
                Log.outWarn(LogFilter.Cheat, String.format("Account: %1$s (IP: %2$s) tried to use a character template without given permission. Possible cheating attempt.", getSession().getAccountId(), getSession().getRemoteAddress()));
            }
        }

        if (getSession().hasPermission(RBACPermissions.UseStartGmLevel)) {
            startLevel = Math.max(WorldConfig.getUIntValue(WorldCfg.StartGmLevel), startLevel);
        }

        return startLevel;
    }

    public final void validateMovementInfo(MovementInfo mi) {
        var RemoveViolatingFlags = (boolean arg1, MovementFlag arg2) ->
        {
            if (check) {
                Log.outDebug(LogFilter.unit, "Player.ValidateMovementInfo: Violation of MovementFlags found ({0}). MovementFlags: {1}, MovementFlags2: {2} for player {3}. Mask {4} will be removed.", check, mi.getMovementFlags(), mi.getMovementFlags2(), getGUID().toString(), maskToRemove);

                mi.removeMovementFlag(maskToRemove);
            }
        };

        if (!getUnitMovedByMe().getVehicleBase() || !getUnitMovedByMe().getVehicle1().GetVehicleInfo().flags.hasFlag(VehicleFlags.FixedPosition)) {
            RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Root), MovementFlag.Root);
        }

		/*! This must be a packet spoofing attempt. MOVEMENTFLAG_ROOT sent from the client is not valid
		    in conjunction with any of the moving movement flags such as MOVEMENTFLAG_FORWARD.
		    It will freeze clients that receive this player's movement info.
		*/
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Root) && mi.hasMovementFlag(MovementFlag.MaskMoving), MovementFlag.MaskMoving);

        //! Cannot hover without SPELL_AURA_HOVER
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Hover) && !getUnitMovedByMe().hasAuraType(AuraType.Hover), MovementFlag.Hover);

        //! Cannot ascend and descend at the same time
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Ascending) && mi.hasMovementFlag(MovementFlag.Descending), MovementFlag.Ascending.getValue() | MovementFlag.Descending.getValue());

        //! Cannot move left and right at the same time
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Left) && mi.hasMovementFlag(MovementFlag.Right), MovementFlag.Left.getValue() | MovementFlag.Right.getValue());

        //! Cannot strafe left and right at the same time
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.StrafeLeft) && mi.hasMovementFlag(MovementFlag.StrafeRight), MovementFlag.StrafeLeft.getValue() | MovementFlag.StrafeRight.getValue());

        //! Cannot pitch up and down at the same time
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.PitchUp) && mi.hasMovementFlag(MovementFlag.PitchDown), MovementFlag.PitchUp.getValue() | MovementFlag.PitchDown.getValue());

        //! Cannot move forwards and backwards at the same time
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Forward) && mi.hasMovementFlag(MovementFlag.Backward), MovementFlag.Forward.getValue() | MovementFlag.Backward.getValue());

        //! Cannot walk on water without SPELL_AURA_WATER_WALK except for ghosts
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.WaterWalk) && !getUnitMovedByMe().hasAuraType(AuraType.WaterWalk) && !getUnitMovedByMe().hasAuraType(AuraType.Ghost), MovementFlag.WaterWalk);

        //! Cannot feather fall without SPELL_AURA_FEATHER_FALL
        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.FallingSlow) && !getUnitMovedByMe().hasAuraType(AuraType.FeatherFall), MovementFlag.FallingSlow);

		/*! Cannot fly if no fly auras present. Exception is being a GM.
		    Note that we check for account level instead of player.IsGameMaster() because in some
		    situations it may be feasable to use .gm fly on as a GM without having .gm on,
		    e.g. aerial combat.
		*/

        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.Flying.getValue() | MovementFlag.CanFly.getValue()) && getSession().getSecurity() == AccountTypes.player && !getUnitMovedByMe().hasAuraType(AuraType.Fly) && !getUnitMovedByMe().hasAuraType(AuraType.ModIncreaseMountedFlightSpeed), MovementFlag.Flying.getValue() | MovementFlag.CanFly.getValue());

        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.DisableGravity.getValue() | MovementFlag.CanFly.getValue()) && mi.hasMovementFlag(MovementFlag.Falling), MovementFlag.Falling);

        RemoveViolatingFlags.invoke(mi.hasMovementFlag(MovementFlag.SplineElevation) && MathUtil.fuzzyEq(mi.getStepUpStartElevation(), 0.0f), MovementFlag.SplineElevation);

        // Client first checks if spline elevation != 0, then verifies flag presence
        if (MathUtil.fuzzyNe(mi.getStepUpStartElevation(), 0.0f)) {
            mi.addMovementFlag(MovementFlag.SplineElevation);
        }
    }

    public final void handleFall(MovementInfo movementInfo) {
        // calculate total z distance of the fall
        var z_diff = _lastFallZ - movementInfo.getPos().getZ();
        Log.outDebug(LogFilter.Server, "zDiff = {0}", z_diff);

        //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
        // 14.57 can be calculated by resolving damageperc formula below to 0
        if (z_diff >= 14.57f && !isDead() && !isGameMaster() && !hasAuraType(AuraType.Hover) && !hasAuraType(AuraType.FeatherFall) && !hasAuraType(AuraType.Fly) && !isImmunedToDamage(spellSchoolMask.NORMAL)) {
            //Safe fall, fall height reduction
            var safe_fall = getTotalAuraModifier(AuraType.SafeFall);

            var damageperc = 0.018f * (z_diff - safe_fall) - 0.2426f;

            if (damageperc > 0) {
                var damage = damageperc * getMaxHealth() * WorldConfig.getFloatValue(WorldCfg.RateDamageFall);

                var height = movementInfo.getPos().getZ();
                height = updateGroundPositionZ(movementInfo.getPos().getX(), movementInfo.getPos().getY(), height);

                damage = damage * getTotalAuraMultiplier(AuraType.ModifyFallDamagePct);

                if (damage > 0) {
                    //Prevent fall damage from being more than the player maximum health
                    if (damage > getMaxHealth()) {
                        damage = getMaxHealth();
                    }

                    // Gust of Wind
                    if (hasAura(43621)) {
                        damage = getMaxHealth() / 2;
                    }

                    var original_health = getHealth();
                    var final_damage = environmentalDamage(EnviromentalDamage.Fall, damage);

                    // recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
                    if (isAlive() && final_damage < original_health) {
                        updateCriteria(CriteriaType.MaxDistFallenWithoutDying, (int) z_diff * 100);
                    }
                }

                //Z given by moveinfo, LastZ, fallTime, WaterZ, MapZ, damage, Safefall reduction
                Log.outDebug(LogFilter.player, String.format("FALLDAMAGE z=%1$s sz=%2$s pZ=%3$s fallTime=%4$s mZ=%5$s damage=%6$s SF=%7$s\nPlayer debug info:\n%8$s", movementInfo.getPos().getZ(), height, getLocation().getZ(), movementInfo.jump.fallTime, height, damage, safe_fall, getDebugInfo()));
            }
        }
    }

    public final void updateFallInformationIfNeed(MovementInfo minfo, ClientOpcodes opcode) {
        if (lastFallTime >= getMovementInfo().jump.fallTime || lastFallZ <= getMovementInfo().getPos().getZ() || opcode == ClientOpcodes.MoveFallLand) {
            setFallInformation(getMovementInfo().jump.fallTime, getMovementInfo().getPos().getZ());
        }
    }

    public final void sendSummonRequestFrom(Unit summoner) {
        if (!summoner) {
            return;
        }

        // Player already has active summon request
        if (getHasSummonPending()) {
            return;
        }

        // Evil Twin (ignore player summon, but hide this for summoner)
        if (hasAura(23445)) {
            return;
        }

        summonExpire = gameTime.GetGameTime() + PlayerConst.MaxPlayerSummonDelay;
        summonLocation = new worldLocation(summoner.getLocation());
        summonInstanceId = summoner.getInstanceId();

        SummonRequest summonRequest = new SummonRequest();
        summonRequest.summonerGUID = summoner.getGUID();
        summonRequest.summonerVirtualRealmAddress = global.getWorldMgr().getVirtualRealmAddress();
        summonRequest.areaID = (int) summoner.getZone();
        sendPacket(summonRequest);

        var group = getGroup();

        if (group != null) {
            BroadcastSummonCast summonCast = new BroadcastSummonCast();
            summonCast.target = getGUID();
            group.broadcastPacket(summonCast, false);
        }
    }

    public final boolean isInAreaTriggerRadius(AreaTriggerRecord trigger) {
        if (trigger == null) {
            return false;
        }

        if (getLocation().getMapId() != trigger.ContinentID && !getPhaseShift().hasVisibleMapId(trigger.ContinentID)) {
            return false;
        }

        if (trigger.PhaseID != 0 || trigger.PhaseGroupID != 0 || trigger.phaseUseFlags != 0) {
            if (!PhasingHandler.inDbPhaseShift(this, PhaseUseFlagsValues.forValue((byte) trigger.phaseUseFlags), trigger.PhaseID, trigger.PhaseGroupID)) {
                return false;
            }
        }

        if (trigger.radius > 0.0f) {
            // if we have radius check it
            var dist = getDistance(trigger.pos.X, trigger.pos.Y, trigger.pos.Z);

            if (dist > trigger.radius) {
                return false;
            }
        } else {
            Position center = new Position(trigger.pos.X, trigger.pos.Y, trigger.pos.Z, trigger.BoxYaw);

            if (!getLocation().isWithinBox(center, trigger.BoxLength / 2.0f, trigger.BoxWidth / 2.0f, trigger.BoxHeight / 2.0f)) {
                return false;
            }
        }

        return true;
    }

    public final void summonIfPossible(boolean agree) {
// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		void broadcastSummonResponse(bool accepted)
//			{
//				var group = group;
//
//				if (group != null)
//				{
//					BroadcastSummonResponse summonResponse = new();
//					summonResponse.target = GUID;
//					summonResponse.accepted = accepted;
//					group.broadcastPacket(summonResponse, false);
//				}
//			}

        if (!agree) {
            summonExpire = 0;
            broadcastSummonResponse(false);

            return;
        }

        // expire and auto declined
        if (summonExpire < gameTime.GetGameTime()) {
            broadcastSummonResponse(false);

            return;
        }

        // stop taxi flight at summon
        finishTaxiFlight();

        // drop flag at summon
        // this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
        var bg = getBattleground();

        if (bg) {
            bg.eventPlayerDroppedFlag(this);
        }

        summonExpire = 0;

        updateCriteria(CriteriaType.AcceptSummon, 1);
        removeAurasWithInterruptFlags(SpellAuraInterruptFlags.summon);

        teleportTo(summonLocation, 0, summonInstanceId);

        broadcastSummonResponse(true);
    }

    @Override
    public void onPhaseChange() {
        super.onPhaseChange();

        getMap().updatePersonalPhasesForPlayer(this);
    }

    public final void prepareGossipMenu(WorldObject source, int menuId) {
        prepareGossipMenu(source, menuId, false);
    }

    public final void prepareGossipMenu(WorldObject source, int menuId, boolean showQuests) {
        var menu = getPlayerTalkClass();
        menu.clearMenus();

        menu.getGossipMenu().setMenuId(menuId);

        var menuItemBounds = global.getObjectMgr().getGossipMenuItemsMapBounds(menuId);

        if (source.isTypeId(TypeId.UNIT)) {
            if (showQuests && source.toUnit().isQuestGiver()) {
                prepareQuestMenu(source.getGUID());
            }
        } else if (source.isTypeId(TypeId.gameObject)) {
            if (source.toGameObject().getGoType() == GameObjectTypes.questGiver) {
                prepareQuestMenu(source.getGUID());
            }
        }

        for (var gossipMenuItem : menuItemBounds) {
            if (!global.getConditionMgr().isObjectMeetToConditions(this, source, gossipMenuItem.getConditions())) {
                continue;
            }

            var canTalk = true;
            var go = source.toGameObject();
            var creature = source.toCreature();

            if (creature) {
                switch (gossipMenuItem.getOptionNpc()) {
                    case Taxinode:
                        if (getSession().sendLearnNewTaxiNode(creature)) {
                            return;
                        }

                        break;
                    case SpiritHealer:
                        if (!isDead()) {
                            canTalk = false;
                        }

                        break;
                    case Battlemaster:
                        if (!creature.canInteractWithBattleMaster(this, false)) {
                            canTalk = false;
                        }

                        break;
                    case TalentMaster:
                    case SpecializationMaster:
                    case GlyphMaster:
                        if (!creature.canResetTalents(this)) {
                            canTalk = false;
                        }

                        break;
                    case Stablemaster:
                    case PetSpecializationMaster:
                        if (getClass() != playerClass.Hunter) {
                            canTalk = false;
                        }

                        break;
                    case DisableXPGain:
                        if (hasPlayerFlag(playerFlags.NoXPGain) || isMaxLevel()) {
                            canTalk = false;
                        }

                        break;
                    case EnableXPGain:
                        if (!hasPlayerFlag(playerFlags.NoXPGain) || isMaxLevel()) {
                            canTalk = false;
                        }

                        break;
                    case None:
                    case Vendor:
                    case Trainer:
                    case Binder:
                    case Banker:
                    case PetitionVendor:
                    case TabardVendor:
                    case Auctioneer:
                    case Mailbox:
                    case Transmogrify:
                    case AzeriteRespec:
                        break; // No checks
                    case CemeterySelect:
                        canTalk = false; // Deprecated

                        break;
                    default:
                        if (gossipMenuItem.getOptionNpc().getValue() >= GossipOptionNpc.max.getValue()) {
                            Logs.SQL.error(String.format("Creature entry %1$s has an unknown gossip option icon %2$s for menu %3$s.", creature.getEntry(), gossipMenuItem.getOptionNpc(), gossipMenuItem.getMenuId()));
                            canTalk = false;
                        }

                        break;
                }
            } else if (go != null) {
                switch (gossipMenuItem.getOptionNpc()) {
                    case None:
                        if (go.getGoType() != GameObjectTypes.questGiver && go.getGoType() != GameObjectTypes.goober) {
                            canTalk = false;
                        }

                        break;
                    default:
                        canTalk = false;

                        break;
                }
            }

            if (canTalk) {
                menu.getGossipMenu().addMenuItem(gossipMenuItem, gossipMenuItem.getMenuId(), gossipMenuItem.getOrderIndex());
            }
        }
    }

    public final void sendPreparedGossip(WorldObject source) {
        if (!source) {
            return;
        }

        if (source.isTypeId(TypeId.UNIT) || source.isTypeId(TypeId.gameObject)) {
            if (getPlayerTalkClass().getGossipMenu().isEmpty() && !getPlayerTalkClass().getQuestMenu().isEmpty()) {
                sendPreparedQuest(source);

                return;
            }
        }

        // in case non empty gossip menu (that not included quests list size) show it
        // (quest entries from quest menu will be included in list)

        var textId = getGossipTextId(source);
        var menuId = getPlayerTalkClass().getGossipMenu().getMenuId();

        if (menuId != 0) {
            textId = getGossipTextId(menuId, source);
        }

        getPlayerTalkClass().sendGossipMenu(textId, source.getGUID());
    }

    public final void onGossipSelect(WorldObject source, int gossipOptionId, int menuId) {
        var gossipMenu = getPlayerTalkClass().getGossipMenu();

        // if not same, then something funky is going on
        if (menuId != gossipMenu.getMenuId()) {
            return;
        }

        var item = gossipMenu.getItem(gossipOptionId);

        if (item == null) {
            return;
        }

        var gossipOptionNpc = item.getOptionNpc();
        var guid = source.getGUID();

        if (source.isTypeId(TypeId.gameObject)) {
            if (gossipOptionNpc != GossipOptionNpc.NONE) {
                Log.outError(LogFilter.player, "Player guid {0} request invalid gossip option for GameObject entry {1}", getGUID().toString(), source.getEntry());

                return;
            }
        }

        long cost = item.getBoxMoney();

        if (!hasEnoughMoney(cost)) {
            sendBuyError(BuyResult.NotEnoughtMoney, null, 0);
            getPlayerTalkClass().sendCloseGossip();

            return;
        }

        if (item.getActionPoiId() != 0) {
            getPlayerTalkClass().sendPointOfInterest(item.getActionPoiId());
        }

        if (item.getActionMenuId() != 0) {
            prepareGossipMenu(source, item.getActionMenuId());
            sendPreparedGossip(source);
        }

        // types that have their dedicated open opcode dont send WorldPackets::NPC::GossipOptionNPCInteraction
        var handled = true;

        switch (gossipOptionNpc) {
            case Vendor:
                getSession().sendListInventory(guid);

                break;
            case Taxinode:
                getSession().sendTaxiMenu(source.toCreature());

                break;
            case Trainer:
                getSession().sendTrainerList(source.toCreature(), global.getObjectMgr().getCreatureTrainerForGossipOption(source.getEntry(), menuId, item.getOrderIndex()));

                break;
            case SpiritHealer:
                source.castSpell(source.toCreature(), 17251, (new CastSpellExtraArgs(TriggerCastFlags.FullMask)).setOriginalCaster(getGUID()));
                handled = false;

                break;
            case PetitionVendor:
                getPlayerTalkClass().sendCloseGossip();
                getSession().sendPetitionShowList(guid);

                break;
            case Battlemaster: {
                var bgTypeId = global.getBattlegroundMgr().getBattleMasterBG(source.getEntry());

                if (bgTypeId == BattlegroundTypeId.NONE) {
                    Log.outError(LogFilter.player, "a user (guid {0}) requested Battlegroundlist from a npc who is no battlemaster", getGUID().toString());

                    return;
                }

                global.getBattlegroundMgr().sendBattlegroundList(this, guid, bgTypeId);

                break;
            }
            case Auctioneer:
                getSession().sendAuctionHello(guid, source.toCreature());

                break;
            case TalentMaster:
                getPlayerTalkClass().sendCloseGossip();
                sendRespecWipeConfirm(guid, WorldConfig.getBoolValue(WorldCfg.NoResetTalentCost) ? 0 : getNextResetTalentsCost(), SpecResetType.talents);

                break;
            case Stablemaster:
                getSession().sendStablePet(guid);

                break;
            case PetSpecializationMaster:
                getPlayerTalkClass().sendCloseGossip();
                sendRespecWipeConfirm(guid, WorldConfig.getBoolValue(WorldCfg.NoResetTalentCost) ? 0 : getNextResetTalentsCost(), SpecResetType.PetTalents);

                break;
            case GuildBanker:
                var guild = getGuild();

                if (guild != null) {
                    guild.sendBankList(getSession(), (byte) 0, true);
                } else {
                    guild.sendCommandResult(getSession(), GuildCommandType.ViewTab, GuildCommandError.PlayerNotInGuild);
                }

                break;
            case Spellclick:
                var sourceUnit = source.toUnit();

                if (sourceUnit != null) {
                    sourceUnit.handleSpellClick(this);
                }

                break;
            case DisableXPGain:
                getPlayerTalkClass().sendCloseGossip();
                castSpell(null, PlayerConst.SpellExperienceEliminated, true);
                setPlayerFlag(playerFlags.NoXPGain);

                break;
            case EnableXPGain:
                getPlayerTalkClass().sendCloseGossip();
                removeAura(PlayerConst.SpellExperienceEliminated);
                removePlayerFlag(playerFlags.NoXPGain);

                break;
            case SpecializationMaster:
                getPlayerTalkClass().sendCloseGossip();
                sendRespecWipeConfirm(guid, 0, SpecResetType.specialization);

                break;
            case GlyphMaster:
                getPlayerTalkClass().sendCloseGossip();
                sendRespecWipeConfirm(guid, 0, SpecResetType.glyphs);

                break;
            case GarrisonTradeskillNpc: // NYI
                break;
            case GarrisonRecruitment: // NYI
                break;
            case ChromieTimeNpc: // NYI
                break;
            case RuneforgeLegendaryCrafting: // NYI
                break;
            case RuneforgeLegendaryUpgrade: // NYI
                break;
            case ProfessionsCraftingOrder: // NYI
                break;
            case ProfessionsCustomerOrder: // NYI
                break;
            case BarbersChoice: // NYI - unknown if needs sending
            default:
                handled = false;

                break;
        }

        if (!handled) {
            if (item.getGossipNpcOptionId() != null) {
                var addon = global.getObjectMgr().getGossipMenuAddon(menuId);

                GossipOptionNPCInteraction npcInteraction = new GossipOptionNPCInteraction();
                npcInteraction.gossipGUID = source.getGUID();
                npcInteraction.gossipNpcOptionID = item.getGossipNpcOptionId().intValue();

                if (addon != null && addon.friendshipFactionId != 0) {
                    npcInteraction.friendshipFactionID = addon.friendshipFactionId;
                }

                sendPacket(npcInteraction);
            } else {
                PlayerInteractionType[] GossipOptionNpcToInteractionType = {PlayerInteractionType.NONE, PlayerInteractionType.vendor, PlayerInteractionType.TaxiNode, PlayerInteractionType.Trainer, PlayerInteractionType.SpiritHealer, PlayerInteractionType.binder, PlayerInteractionType.banker, PlayerInteractionType.PetitionVendor, PlayerInteractionType.TabardVendor, PlayerInteractionType.BattleMaster, PlayerInteractionType.auctioneer, PlayerInteractionType.TalentMaster, PlayerInteractionType.stableMaster, PlayerInteractionType.NONE, PlayerInteractionType.GuildBanker, PlayerInteractionType.NONE, PlayerInteractionType.NONE, PlayerInteractionType.NONE, PlayerInteractionType.mailInfo, PlayerInteractionType.NONE, PlayerInteractionType.LFGDungeon, PlayerInteractionType.ArtifactForge, PlayerInteractionType.NONE, PlayerInteractionType.SpecializationMaster, PlayerInteractionType.NONE, PlayerInteractionType.NONE, PlayerInteractionType.GarrArchitect, PlayerInteractionType.GarrMission, PlayerInteractionType.ShipmentCrafter, PlayerInteractionType.GarrTradeskill, PlayerInteractionType.GarrRecruitment, PlayerInteractionType.AdventureMap, PlayerInteractionType.GarrTalent, PlayerInteractionType.ContributionCollector, PlayerInteractionType.Transmogrifier, PlayerInteractionType.AzeriteRespec, PlayerInteractionType.IslandQueue, PlayerInteractionType.ItemInteraction, PlayerInteractionType.WorldMap, PlayerInteractionType.Soulbind, PlayerInteractionType.chromieTime, PlayerInteractionType.CovenantPreview, PlayerInteractionType.LegendaryCrafting, PlayerInteractionType.NewPlayerGuide, PlayerInteractionType.LegendaryCrafting, PlayerInteractionType.Renown, PlayerInteractionType.BlackMarketAuctioneer, PlayerInteractionType.PerksProgramVendor, PlayerInteractionType.ProfessionsCraftingOrder, PlayerInteractionType.Professions, PlayerInteractionType.ProfessionsCustomerOrder, PlayerInteractionType.TraitSystem, PlayerInteractionType.BarbersChoice, PlayerInteractionType.MajorFactionRenown};

                var interactionType = GossipOptionNpcToInteractionType[gossipOptionNpc.getValue()];

                if (interactionType != PlayerInteractionType.NONE) {
                    NPCInteractionOpenResult npcInteraction = new NPCInteractionOpenResult();
                    npcInteraction.npc = source.getGUID();
                    npcInteraction.interactionType = interactionType;
                    npcInteraction.success = true;
                    sendPacket(npcInteraction);
                }
            }
        }

        modifyMoney(-cost);
    }

    public final int getGossipTextId(WorldObject source) {
        if (source == null) {
            return SharedConst.DefaultGossipMessage;
        }

        return getGossipTextId(getDefaultGossipMenuForSource(source), source);
    }

    public final int getGossipTextId(int menuId, WorldObject source) {
        int textId = SharedConst.DefaultGossipMessage;

        if (menuId == 0) {
            return textId;
        }

        var menuBounds = global.getObjectMgr().getGossipMenusMapBounds(menuId);

        for (var menu : menuBounds) {
            if (global.getConditionMgr().isObjectMeetToConditions(this, source, menu.getConditions())) {
                textId = menu.getTextId();
            }
        }

        return textId;
    }

    public final boolean canJoinConstantChannelInZone(ChatChannelsRecord channel, AreaTableRecord zone) {
        if (channel.flags.hasFlag(ChannelDBCFlags.ZoneDep) && zone.hasFlag(AreaFlags.ArenaInstance)) {
            return false;
        }

        if (channel.flags.hasFlag(ChannelDBCFlags.CityOnly) && !zone.hasFlag(AreaFlags.Capital)) {
            return false;
        }

        if (channel.flags.hasFlag(ChannelDBCFlags.GuildReq) && getGuildId() != 0) {
            return false;
        }

        if (channel.flags.hasFlag(ChannelDBCFlags.NoClientJoin)) {
            return false;
        }

        return true;
    }

    public final void joinedChannel(Channel c) {
        channels.add(c);
    }

    public final void leftChannel(Channel c) {
        channels.remove(c);
    }

    public final void cleanupChannels() {
        while (!channels.isEmpty()) {
            var ch = channels.FirstOrDefault();
            channels.remove(0); // remove from player's channel list
            ch.leaveChannel(this, false); // not send to client, not remove from player's channel list

            // delete channel if empty
            var cMgr = ChannelManager.forTeam(getTeam());

            if (cMgr != null) {
                if (ch.isConstant()) {
                    cMgr.leftChannel(ch.getChannelId(), ch.getZoneEntry());
                }
            }
        }

        Log.outDebug(LogFilter.ChatSystem, "Player {0}: channels cleaned up!", getName());
    }

    //Mail
    public final void addMail(Mail mail) {
        mail.add(0, mail);
    }

    public final void removeMail(long id) {
        for (var mail : mail) {
            if (mail.messageID == id) {
                //do not delete item, because player.removeMail() is called when returning mail to sender.
                mail.remove(mail);

                return;
            }
        }
    }

    public final void sendMailResult(long mailId, MailResponseType mailAction, MailResponseResult mailError, InventoryResult equipError, long itemGuid) {
        sendMailResult(mailId, mailAction, mailError, equipError, itemGuid, 0);
    }

    public final void sendMailResult(long mailId, MailResponseType mailAction, MailResponseResult mailError, InventoryResult equipError) {
        sendMailResult(mailId, mailAction, mailError, equipError, 0, 0);
    }

    public final void sendMailResult(long mailId, MailResponseType mailAction, MailResponseResult mailError) {
        sendMailResult(mailId, mailAction, mailError, 0, 0, 0);
    }

    public final void sendMailResult(long mailId, MailResponseType mailAction, MailResponseResult mailError, InventoryResult equipError, long itemGuid, int itemCount) {
        MailCommandResult result = new MailCommandResult();
        result.mailID = mailId;
        result.command = mailAction.getValue();
        result.errorCode = mailError.getValue();

        if (mailError == MailResponseResult.EquipError) {
            result.bagResult = equipError.getValue();
        } else if (mailAction == MailResponseType.ItemTaken) {
            result.attachID = itemGuid;
            result.qtyInInventory = (int) itemCount;
        }

        sendPacket(result);
    }

    public final void updateNextMailTimeAndUnreads() {
        // calculate next delivery time (min. from non-delivered mails
        // and recalculate unReadMail
        var cTime = gameTime.GetGameTime();
        nextMailDelivereTime = 0;
        setUnReadMails(0);

        for (var mail : mail) {
            if (mail.deliver_time > cTime) {
                if (nextMailDelivereTime == 0 || nextMailDelivereTime > mail.deliver_time) {
                    nextMailDelivereTime = mail.deliver_time;
                }
            } else if ((mail.checkMask.getValue() & MailCheckMask.Read.getValue()) == 0) {
                setUnReadMails(getUnReadMails() + 1);
            }
        }
    }

    public final void addNewMailDeliverTime(long deliver_time) {
        if (deliver_time <= gameTime.GetGameTime()) // ready now
        {
            setUnReadMails(getUnReadMails() + 1);
            sendNewMail();
        } else // not ready and no have ready mails
        {
            if (nextMailDelivereTime == 0 || nextMailDelivereTime > deliver_time) {
                nextMailDelivereTime = deliver_time;
            }
        }
    }

    public final void addMItem(Item it) {
        mailItems.put(it.getGUID().getCounter(), it);
    }

    public final boolean removeMItem(long id) {
        return mailItems.remove(id);
    }

    public final Item getMItem(long id) {
        return mailItems.get(id);
    }

    public final Mail getMail(long id) {
        return tangible.ListHelper.find(mail, p -> p.messageID == id);
    }

    public final void setHomebind(WorldLocation loc, int areaId) {
        homeBind.WorldRelocate(loc);
        homebindAreaId = areaId;

        // update sql homebind
        var stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_PLAYER_HOMEBIND);
        stmt.AddValue(0, homeBind.getMapId());
        stmt.AddValue(1, homebindAreaId);
        stmt.AddValue(2, homeBind.getX());
        stmt.AddValue(3, homeBind.getY());
        stmt.AddValue(4, homeBind.getZ());
        stmt.AddValue(5, homeBind.getO());
        stmt.AddValue(6, getGUID().getCounter());
        DB.characters.execute(stmt);
    }

    public final void setBindPoint(ObjectGuid guid) {
        NPCInteractionOpenResult npcInteraction = new NPCInteractionOpenResult();
        npcInteraction.npc = guid;
        npcInteraction.interactionType = PlayerInteractionType.binder;
        npcInteraction.success = true;
        sendPacket(npcInteraction);
    }

    public final void sendBindPointUpdate() {
        BindPointUpdate packet = new BindPointUpdate();
        packet.bindPosition = new Vector3(homeBind.getX(), homeBind.getY(), homeBind.getZ());
        packet.bindMapID = homeBind.getMapId();
        packet.bindAreaID = homebindAreaId;
        sendPacket(packet);
    }

    public final void sendPlayerBound(ObjectGuid binderGuid, int areaId) {
        PlayerBound packet = new PlayerBound(binderGuid, areaId);
        sendPacket(packet);
    }

    public final void sendUpdateWorldState(WorldStates variable, int value) {
        sendUpdateWorldState(variable, value, false);
    }

    public final void sendUpdateWorldState(WorldStates variable, int value, boolean hidden) {
        sendUpdateWorldState((int) variable.getValue(), value, hidden);
    }

    public final void sendUpdateWorldState(int variable, int value) {
        sendUpdateWorldState(variable, value, false);
    }

    public final void sendUpdateWorldState(int variable, int value, boolean hidden) {
        UpdateWorldState worldstate = new updateWorldState();
        worldstate.variableID = variable;
        worldstate.value = (int) value;
        worldstate.hidden = hidden;
        sendPacket(worldstate);
    }

    public final long getBarberShopCost(ArrayList<ChrCustomizationChoice> newCustomizations) {
        if (hasAuraType(AuraType.RemoveBarberShopCost)) {
            return 0;
        }

        var bsc = CliDB.BarberShopCostBaseGameTable.GetRow(getLevel());

        if (bsc == null) // shouldn't happen
        {
            return 0;
        }

        long cost = 0;

        for (var newChoice : newCustomizations) {
            var currentCustomizationIndex = getPlayerData().customizations.FindIndexIf(currentCustomization ->
            {
                return currentCustomization.chrCustomizationOptionID == newChoice.chrCustomizationOptionID;
            });

            if (currentCustomizationIndex == -1 || getPlayerData().customizations.get(currentCustomizationIndex).chrCustomizationChoiceID != newChoice.chrCustomizationChoiceID) {
                var customizationOption = CliDB.ChrCustomizationOptionStorage.get(newChoice.chrCustomizationOptionID);

                if (customizationOption != null) {
                    cost += (long) (bsc.Cost * customizationOption.BarberShopCostModifier);
                }
            }
        }

        return cost;
    }

    public final void setFactionForRace(Race race) {
        team = teamForRace(race);

        var rEntry = CliDB.ChrRacesStorage.get(race);
        setFaction(rEntry != null ? (int) rEntry.FactionID : 0);
    }

    public final void setResurrectRequestData(WorldObject caster, int health, int mana, int appliedAura) {
        resurrectionData = new ResurrectionData();
        resurrectionData.setGuid(caster.getGUID());
        resurrectionData.getLocation().WorldRelocate(caster.getLocation());
        resurrectionData.setHealth(health);
        resurrectionData.setMana(mana);
        resurrectionData.setAura(appliedAura);
    }

    public final void clearResurrectRequestData() {
        resurrectionData = null;
    }

    public final boolean isRessurectRequestedBy(ObjectGuid guid) {
        if (!isResurrectRequested()) {
            return false;
        }

        return !resurrectionData.getGuid().isEmpty() && Objects.equals(resurrectionData.getGuid(), guid);
    }

    public final void resurrectUsingRequestData() {
        // Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
        teleportTo(resurrectionData.getLocation());

        if (isBeingTeleported()) {
            scheduleDelayedOperation(PlayerDelayedOperations.ResurrectPlayer);

            return;
        }

        resurrectUsingRequestDataImpl();
    }

    public final void updateTriggerVisibility() {
        if (getClientGuiDs().isEmpty()) {
            return;
        }

        if (!isInWorld()) {
            return;
        }

        UpdateData udata = new UpdateData(getLocation().getMapId());

        synchronized (getClientGuiDs()) {
            for (var guid : getClientGuiDs()) {
                if (guid.isCreatureOrVehicle()) {
                    var creature = getMap().getCreature(guid);

                    // Update fields of triggers, transformed units or unselectable units (values dependent on GM state)
                    if (creature == null || (!creature.isTrigger() && !creature.hasAuraType(AuraType.Transform) && !creature.hasUnitFlag(UnitFlag.Uninteractible))) {
                        continue;
                    }

                    creature.getValues().modifyValue(getUnitData()).modifyValue(getUnitData().displayID);
                    creature.getValues().modifyValue(getUnitData()).modifyValue(getUnitData().flags);
                    creature.forceUpdateFieldChange();
                    creature.buildValuesUpdateBlockForPlayer(udata, this);
                } else if (guid.isAnyTypeGameObject()) {
                    var go = getMap().getGameObject(guid);

                    if (go == null) {
                        continue;
                    }

                    go.getValues().modifyValue(getObjectData()).modifyValue(getObjectData().dynamicFlags);
                    go.forceUpdateFieldChange();
                    go.buildValuesUpdateBlockForPlayer(udata, this);
                }
            }
        }

        if (!udata.hasData()) {
            return;
        }

        UpdateObject packet;
        tangible.OutObject<UpdateObject> tempOut_packet = new tangible.OutObject<UpdateObject>();
        udata.buildPacket(tempOut_packet);
        packet = tempOut_packet.outArgValue;
        sendPacket(packet);
    }

    public final boolean isAllowedToLoot(Creature creature) {
        if (!creature.isDead()) {
            return false;
        }

        if (getHasPendingBind()) {
            return false;
        }

        var loot = creature.getLootForPlayer(this);

        if (loot == null || loot.isLooted()) // nothing to loot or everything looted.
        {
            return false;
        }

        if (!loot.hasAllowedLooter(getGUID()) || (!loot.hasItemForAll() && !loot.hasItemFor(this))) // no loot in creature for this player
        {
            return false;
        }

        switch (loot.getLootMethod()) {
            case PersonalLoot:
            case FreeForAll:
                return true;
            case RoundRobin:
                // may only loot if the player is the loot roundrobin player
                // or if there are free/quest/conditional item for the player
                if (loot.roundRobinPlayer.isEmpty() || Objects.equals(loot.roundRobinPlayer, getGUID())) {
                    return true;
                }

                return loot.hasItemFor(this);
            case MasterLoot:
            case GroupLoot:
            case NeedBeforeGreed:
                // may only loot if the player is the loot roundrobin player
                // or item over threshold (so roll(s) can be launched or to preview master looted items)
                // or if there are free/quest/conditional item for the player
                if (loot.roundRobinPlayer.isEmpty() || Objects.equals(loot.roundRobinPlayer, getGUID())) {
                    return true;
                }

                if (loot.hasOverThresholdItem()) {
                    return true;
                }

                return loot.hasItemFor(this);
        }

        return false;
    }

    @Override
    public boolean isImmunedToSpellEffect(SpellInfo spellInfo, SpellEffectInfo spellEffectInfo, WorldObject caster) {
        return isImmunedToSpellEffect(spellInfo, spellEffectInfo, caster, false);
    }

    @Override
    public boolean isImmunedToSpellEffect(SpellInfo spellInfo, SpellEffectInfo spellEffectInfo, WorldObject caster, boolean requireImmunityPurgesEffectAttribute) {
        // players are immune to taunt (the aura and the spell effect).
        if (spellEffectInfo.isAura(AuraType.ModTaunt)) {
            return true;
        }

        if (spellEffectInfo.isEffect(SpellEffectName.AttackMe)) {
            return true;
        }

        return super.isImmunedToSpellEffect(spellInfo, spellEffectInfo, caster, requireImmunityPurgesEffectAttribute);
    }

    public final void resetAllPowers() {
        setFullHealth();

        switch (getDisplayPowerType()) {
            case Mana:
                setFullPower(powerType.mana);

                break;
            case Rage:
                setPower(powerType.Rage, 0);

                break;
            case Energy:
                setFullPower(powerType.Energy);

                break;
            case RunicPower:
                setPower(powerType.RunicPower, 0);

                break;
            case LunarPower:
                setPower(powerType.LunarPower, 0);

                break;
            default:
                break;
        }
    }

    public final double environmentalDamage(EnviromentalDamage type, double damage) {
        if (isImmuneToEnvironmentalDamage()) {
            return 0;
        }

        damage = damage * getTotalAuraMultiplier(AuraType.ModEnvironmentalDamageTaken);

        // absorb, resist some environmental damage type
        double absorb = 0;
        double resist = 0;
        var dmgSchool = getEnviormentDamageType(type);

        switch (type) {
            case Lava:
            case Slime:
                DamageInfo dmgInfo = new DamageInfo(this, this, damage, null, dmgSchool, DamageEffectType.Direct, WeaponAttackType.BaseAttack);
                calcAbsorbResist(dmgInfo);
                absorb = dmgInfo.getAbsorb();
                resist = dmgInfo.getResist();
                damage = dmgInfo.getDamage();

                break;
        }

        tangible.RefObject<Double> tempRef_damage = new tangible.RefObject<Double>(damage);
        tangible.RefObject<Double> tempRef_absorb = new tangible.RefObject<Double>(absorb);
        dealDamageMods(null, this, tempRef_damage, tempRef_absorb);
        absorb = tempRef_absorb.refArgValue;
        damage = tempRef_damage.refArgValue;
        EnvironmentalDamageLog packet = new EnvironmentalDamageLog();
        packet.victim = getGUID();
        packet.type = type != EnviromentalDamage.FallToVoid ? type : EnviromentalDamage.Fall;
        packet.amount = (int) damage;
        packet.absorbed = (int) absorb;
        packet.resisted = (int) resist;

        var final_damage = dealDamage(this, this, damage, null, DamageEffectType.Self, dmgSchool, null, false);
        packet.logData.initialize(this);

        sendCombatLogMessage(packet);

        if (!isAlive()) {
            if (type == EnviromentalDamage.Fall) // DealDamage not apply item durability loss at self damage
            {
                Log.outDebug(LogFilter.player, String.format("Player::EnvironmentalDamage: Player '%1$s' (%2$s) fall to death, losing %3$s durability", getName(), getGUID(), WorldConfig.getFloatValue(WorldCfg.RateDurabilityLossOnDeath)));
                durabilityLossAll(WorldConfig.getFloatValue(WorldCfg.RateDurabilityLossOnDeath), false);
                // durability lost message
                sendDurabilityLoss(this, (int) (WorldConfig.getFloatValue(WorldCfg.RateDurabilityLossOnDeath) * 100.0f));
            }

            updateCriteria(CriteriaType.DieFromEnviromentalDamage, 1, (long) type.getValue());
        }

        return final_damage;
    }

    @Override
    public boolean canNeverSee(WorldObject obj) {
        // the intent is to delay sending visible objects until client is ready for them
        // some gameobjects dont function correctly if they are sent before TransportServerTime is correctly set (after CMSG_MOVE_INIT_ACTIVE_MOVER_COMPLETE)
        return !hasPlayerLocalFlag(PlayerLocalFlags.OverrideTransportServerTime) || super.canNeverSee(obj);
    }

    @Override
    public boolean canAlwaysSee(WorldObject obj) {
        // Always can see self
        if (getUnitBeingMoved() == obj) {
            return true;
        }

        ObjectGuid guid = getActivePlayerData().farsightObject;

        if (!guid.isEmpty()) {
            if (Objects.equals(obj.getGUID(), guid)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean isAlwaysDetectableFor(WorldObject seer) {
        if (super.isAlwaysDetectableFor(seer)) {
            return true;
        }

        if (getDuel() != null && getDuel().getState() != DuelState.Challenged && getDuel().getOpponent() == seer) {
            return false;
        }

        var seerPlayer = seer.toPlayer();

        if (seerPlayer != null) {
            if (isGroupVisibleFor(seerPlayer)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean isNeverVisibleFor(WorldObject seer) {
        if (super.isNeverVisibleFor(seer)) {
            return true;
        }

        if (getSession().getPlayerLogout() || getSession().getPlayerLoading()) {
            return true;
        }

        return false;
    }

    public final void buildPlayerRepop() {
        PreRessurect packet = new PreRessurect();
        packet.playerGUID = getGUID();
        sendPacket(packet);

        // If the player has the Wisp racial then cast the Wisp aura on them
        if (hasSpell(20585)) {
            castSpell(this, 20584, true);
        }

        castSpell(this, 8326, true);

        removeAurasWithInterruptFlags(SpellAuraInterruptFlags.Release);

        // there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
        // there must be SMSG.STOP_MIRROR_TIMER

        // the player cannot have a corpse already on current map, only bones which are not returned by GetCorpse
        var corpseLocation = getCorpseLocation();

        if (corpseLocation.getMapId() == getLocation().getMapId()) {
            Log.outError(LogFilter.player, "BuildPlayerRepop: player {0} ({1}) already has a corpse", getName(), getGUID().toString());

            return;
        }

        // create a corpse and place it at the player's location
        var corpse = createCorpse();

        if (corpse == null) {
            Log.outError(LogFilter.player, "Error creating corpse for Player {0} ({1})", getName(), getGUID().toString());

            return;
        }

        getMap().addToMap(corpse);

        // convert player body to ghost
        setDeathState(deathState.Dead);
        setHealth(1);

        setWaterWalking(true);

        if (!getSession().isLogingOut() && !hasUnitState(UnitState.Stunned)) {
            setRooted(false);
        }

        // BG - remove insignia related
        removeUnitFlag(UnitFlag.Skinnable);

        var corpseReclaimDelay = calculateCorpseReclaimDelay();

        if (corpseReclaimDelay >= 0) {
            sendCorpseReclaimDelay(corpseReclaimDelay);
        }

        // to prevent cheating
        corpse.resetGhostTime();

        stopMirrorTimers(); //disable timers(bars)

        // OnPlayerRepop hook
        global.getScriptMgr().<IPlayerOnPlayerRepop>ForEach(p -> p.OnPlayerRepop(this));
    }

    public final void stopMirrorTimers() {
        stopMirrorTimer(MirrorTimerType.Fatigue);
        stopMirrorTimer(MirrorTimerType.Breath);
        stopMirrorTimer(MirrorTimerType.Fire);
    }

    public final boolean isMirrorTimerActive(MirrorTimerType type) {
        return _mirrorTimer[type.getValue()] == getMaxTimer(type);
    }

    public final void updateMirrorTimers() {
        // Desync flags for update on next HandleDrowning
        if (mirrorTimerFlags != 0) {
            mirrorTimerFlagsLast = ~mirrorTimerFlags;
        }
    }

    public final void resurrectPlayer(float restore_percent) {
        resurrectPlayer(restore_percent, false);
    }

    public final void resurrectPlayer(float restore_percent, boolean applySickness) {
        DeathReleaseLoc packet = new DeathReleaseLoc();
        packet.mapID = -1;
        sendPacket(packet);

        // speed change, land walk

        // remove death flag + set aura
        removePlayerFlag(playerFlags.IsOutOfBounds);

        // This must be called always even on Players with race != RACE_NIGHTELF in case of faction change
        removeAura(20584); // speed bonuses
        removeAura(8326); // SPELL_AURA_GHOST

        if (getSession().isARecruiter() || (getSession().getRecruiterId() != 0)) {
            setDynamicFlag(UnitDynFlags.ReferAFriend);
        }

        setDeathState(deathState.Alive);

        // add the flag to make sure opcode is always sent
        addUnitMovementFlag(MovementFlag.WaterWalk);
        setWaterWalking(false);

        if (!hasUnitState(UnitState.Stunned)) {
            setRooted(false);
        }

        deathTimer = 0;

        // set health/powers (0- will be set in caller)
        if (restore_percent > 0.0f) {
            setHealth(getMaxHealth() * restore_percent);
            setPower(powerType.mana, (int) (getMaxPower(powerType.mana) * restore_percent));
            setPower(powerType.Rage, 0);
            setPower(powerType.Energy, (int) (getMaxPower(powerType.Energy) * restore_percent));
            setPower(powerType.Focus, (int) (getMaxPower(powerType.Focus) * restore_percent));
            setPower(powerType.LunarPower, 0);
        }

        // trigger update zone for alive state zone updates
        int newzone;
        tangible.OutObject<Integer> tempOut_newzone = new tangible.OutObject<Integer>();
        int newarea;
        tangible.OutObject<Integer> tempOut_newarea = new tangible.OutObject<Integer>();
        getZoneAndAreaId(tempOut_newzone, tempOut_newarea);
        newarea = tempOut_newarea.outArgValue;
        newzone = tempOut_newzone.outArgValue;
        updateZone(newzone, newarea);
        global.getOutdoorPvPMgr().handlePlayerResurrects(this, newzone);

        if (getInBattleground()) {
            var bg = getBattleground();

            if (bg) {
                bg.handlePlayerResurrect(this);
            }
        }

        // update visibility
        updateObjectVisibility();

        // recast lost by death auras of any items held in the inventory
        castAllObtainSpells();

        if (!applySickness) {
            return;
        }

        //Characters from level 1-10 are not affected by resurrection sickness.
        //Characters from level 11-19 will suffer from one minute of sickness
        //for each level they are above 10.
        //Characters level 20 and up suffer from ten minutes of sickness.
        var startLevel = WorldConfig.getIntValue(WorldCfg.DeathSicknessLevel);
        var raceEntry = CliDB.ChrRacesStorage.get(getRace());

        if (getLevel() >= startLevel) {
            // set resurrection sickness
            castSpell(this, raceEntry.ResSicknessSpellID, true);

            // not full duration
            if (getLevel() < startLevel + 9) {
                var delta = (int) (getLevel() - startLevel + 1) * time.Minute;
                var aur = getAura(raceEntry.ResSicknessSpellID, getGUID());

                if (aur != null) {
                    aur.setDuration(delta * time.InMilliseconds);
                }
            }
        }
    }

    public final void killPlayer() {
        if (isFlying() && getTransport() == null) {
            getMotionMaster().moveFall();
        }

        setRooted(true);

        stopMirrorTimers(); //disable timers(bars)

        setDeathState(deathState.Corpse);

        replaceAllDynamicFlags(UnitDynFlags.NONE);

        if (!CliDB.MapStorage.get(getLocation().getMapId()).Instanceable() && !hasAuraType(AuraType.PreventResurrection)) {
            setPlayerLocalFlag(PlayerLocalFlags.ReleaseTimer);
        } else {
            removePlayerLocalFlag(PlayerLocalFlags.ReleaseTimer);
        }

        // 6 minutes until repop at graveyard
        deathTimer = 6 * time.Minute * time.InMilliseconds;

        updateCorpseReclaimDelay(); // dependent at use SetDeathPvP() call before kill

        var corpseReclaimDelay = calculateCorpseReclaimDelay();

        if (corpseReclaimDelay >= 0) {
            sendCorpseReclaimDelay(corpseReclaimDelay);
        }

        ScriptManager.getInstance().<IPlayerOnDeath>ForEach(getClass(), a -> a.OnDeath(this));
        // don't create corpse at this moment, player might be falling

        // update visibility
        updateObjectVisibility();
    }

    public final void spawnCorpseBones() {
        spawnCorpseBones(true);
    }

    public final void spawnCorpseBones(boolean triggerSave) {
        corpseLocation = new worldLocation();

        if (getMap().convertCorpseToBones(getGUID())) {
            if (triggerSave && !getSession().getPlayerLogoutWithSave()) // at logout we will already store the player
            {
                saveToDB(); // prevent loading as ghost without corpse
            }
        }
    }

    public final Corpse getCorpse() {
        return getMap().getCorpseByPlayer(getGUID());
    }

    public final void repopAtGraveyard() {
        // note: this can be called also when the player is alive
        // for example from WorldSession.HandleMovementOpcodes

        var zone = CliDB.AreaTableStorage.get(getArea());

        var shouldResurrect = false;

        // Such zones are considered unreachable as a ghost and the player must be automatically revived
        if ((!isAlive() && zone != null && zone.hasFlag(AreaFlags.NeedFly)) || getTransport() != null || getLocation().getZ() < getMap().getMinHeight(getPhaseShift(), getLocation().getX(), getLocation().getY())) {
            shouldResurrect = true;
            spawnCorpseBones();
        }

        WorldSafeLocsEntry ClosestGrave;

        // Special handle for Battlegroundmaps
        var bg = getBattleground();

        if (bg) {
            ClosestGrave = bg.getClosestGraveYard(this);
        } else {
            var bf = global.getBattleFieldMgr().getBattlefieldToZoneId(getMap(), getZone());

            if (bf != null) {
                ClosestGrave = bf.getClosestGraveYard(this);
            } else {
                ClosestGrave = global.getObjectMgr().getClosestGraveYard(getLocation(), getTeam(), this);
            }
        }

        // stop countdown until repop
        deathTimer = 0;

        // if no grave found, stay at the current location
        // and don't show spirit healer location
        if (ClosestGrave != null) {
            teleportTo(ClosestGrave.loc, shouldResurrect ? TeleportToOptions.ReviveAtTeleport : 0);

            if (isDead()) // not send if alive, because it used in teleportTo()
            {
                DeathReleaseLoc packet = new DeathReleaseLoc();
                packet.mapID = (int) ClosestGrave.loc.getMapId();
                packet.loc = ClosestGrave.loc;
                sendPacket(packet);
            }
        } else if (getLocation().getZ() < getMap().getMinHeight(getPhaseShift(), getLocation().getX(), getLocation().getY())) {
            teleportTo(homeBind);
        }

        removePlayerFlag(playerFlags.IsOutOfBounds);
    }

    public final int getCorpseReclaimDelay(boolean pvp) {
        if (pvp) {
            if (!WorldConfig.getBoolValue(WorldCfg.DeathCorpseReclaimDelayPvp)) {
                return PlayerConst.copseReclaimDelay[0];
            }
        } else if (!WorldConfig.getBoolValue(WorldCfg.DeathCorpseReclaimDelayPve)) {
            return 0;
        }

        var now = gameTime.GetGameTime();
        // 0..2 full period
        // should be ceil(x)-1 but not floor(x)
        var count = (long) ((now < _deathExpireTime - 1) ? (_deathExpireTime - 1 - now) / PlayerConst.DeathExpireStep : 0);

        return PlayerConst.copseReclaimDelay[count];
    }

    public final boolean tryGetPet(tangible.OutObject<pet> pet) {
        pet.outArgValue = getCurrentPet();

        return pet.outArgValue != null;
    }

    public final Pet summonPet(int entry, PetSaveMode slot, Position pos, int duration) {
        tangible.OutObject<Boolean> tempOut__ = new tangible.OutObject<Boolean>();
        var tempVar = summonPet(entry, slot, pos, duration, tempOut__);
        _ = tempOut__.outArgValue;
        return tempVar;
    }

    public final Pet summonPet(int entry, PetSaveMode slot, Position pos, int duration, tangible.OutObject<Boolean> isNew) {
        isNew.outArgValue = false;

        var petStable = getPetStable();

        Pet pet = new pet(this, PetType.summon);

        if (pet.LoadPetFromDB(this, entry, 0, false, slot)) {
            if (duration > 0) {
                pet.setDuration(duration);
            }

            return null;
        }

        // petentry == 0 for hunter "call pet" (current pet summoned if any)
        if (entry == 0) {
            return null;
        }

        // only SUMMON_PET are handled here
        updateAllowedPositionZ(pos);

        if (!pet.getLocation().isPositionValid()) {
            Log.outError(LogFilter.Server, "Pet (guidlow {0}, entry {1}) not summoned. Suggested coordinates isn't valid (X: {2} Y: {3})", pet.getGUID().toString(), pet.getEntry(), pet.getLocation().getX(), pet.getLocation().getY());

            return null;
        }

        var map = getMap();
        var petNumber = global.getObjectMgr().generatePetNumber();

        if (!pet.create(map.generateLowGuid(HighGuid.Pet), map, entry, petNumber)) {
            Log.outError(LogFilter.Server, "no such creature entry {0}", entry);

            return null;
        }

        if (petStable.GetCurrentPet() != null) {
            removePet(null, PetSaveMode.NotInSlot);
        }

        PhasingHandler.inheritPhaseShift(pet, this);

        pet.setCreatorGUID(getGUID());
        pet.setFaction(getFaction());
        pet.replaceAllNpcFlags(NPCFlags.NONE);
        pet.replaceAllNpcFlags2(NPCFlags2.NONE);
        pet.initStatsForLevel(getLevel());

        setMinion(pet, true);

        // this enables pet details window (Shift+P)
        pet.getCharmInfo().setPetNumber(petNumber, true);
        pet.setClass(playerClass.Mage);
        pet.SetPetExperience(0);
        pet.SetPetNextLevelExperience(1000);
        pet.setFullHealth();
        pet.setFullPower(powerType.mana);
        pet.setPetNameTimestamp((int) gameTime.GetGameTime());

        map.addToMap(pet.toCreature());

        petStable.SetCurrentUnslottedPetIndex((int) petStable.UnslottedPets.size());
        PetStable.PetInfo petInfo = new PetStable.petInfo();
        pet.FillPetInfo(petInfo);
        petStable.UnslottedPets.add(petInfo);

        pet.InitPetCreateSpells();
        pet.SavePetToDB(PetSaveMode.AsCurrent);
        petSpellInitialize();

        if (duration > 0) {
            pet.setDuration(duration);
        }

        //ObjectAccessor.updateObjectVisibility(pet);

        isNew.outArgValue = true;
        pet.getLocation().WorldRelocate(pet.getOwnerUnit().getLocation().getMapId(), pos);
        pet.nearTeleportTo(pos);

        return pet;
    }

    public final void removePet(Pet pet, PetSaveMode mode) {
        removePet(pet, mode, false);
    }

// C# TO JAVA CONVERTER TASK: There is no preprocessor in Java:
    ///#region Sends / Updates

    public final void removePet(Pet pet, PetSaveMode mode, boolean returnreagent) {
        if (!pet) {
            pet = getCurrentPet();
        }

        if (pet) {
            Log.outDebug(LogFilter.pet, "RemovePet {0}, {1}, {2}", pet.getEntry(), mode, returnreagent);

            if (pet.removed) {
                return;
            }
        }

        if (returnreagent && (pet || temporaryUnsummonedPetNumber != 0) && !getInBattleground()) {
            //returning of reagents only for players, so best done here
            var spellId = pet ? pet.getUnitData().CreatedBySpell : oldpetspell;
            var spellInfo = global.getSpellMgr().getSpellInfo(spellId, getMap().getDifficultyID());

            if (spellInfo != null) {
                for (int i = 0; i < SpellConst.MaxReagents; ++i) {
                    if (spellInfo.Reagent[i] > 0) {
                        ArrayList<ItemPosCount> dest = new ArrayList<>(); //for succubus, voidwalker, felhunter and felguard credit soulshard when despawn reason other than death (out of range, logout)
                        var msg = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, (int) spellInfo.Reagent[i], spellInfo.ReagentCount[i]);

                        if (msg == InventoryResult.Ok) {
                            var item = storeNewItem(dest, (int) spellInfo.Reagent[i], true);

                            if (isInWorld()) {
                                sendNewItem(item, spellInfo.ReagentCount[i], true, false);
                            }
                        }
                    }
                }
            }

            temporaryUnsummonedPetNumber = 0;
        }

        if (pet == null) {
            // Handle removing pet while it is in "temporarily unsummoned" state, for example on mount
            if (mode == PetSaveMode.NotInSlot && petStable != null && petStable.CurrentPetIndex != null) {
                petStable.CurrentPetIndex = null;
            }

            return;
        }

        pet.combatStop();

        // only if current pet in slot
        pet.SavePetToDB(mode);

        var currentPet = petStable.GetCurrentPet();

        if (mode == PetSaveMode.NotInSlot || mode == PetSaveMode.AsDeleted) {
            petStable.CurrentPetIndex = null;
        }
        // else if (stable slots) handled in opcode handlers due to required swaps
        // else (current pet) doesnt need to do anything

        setMinion(pet, false);

        pet.addObjectToRemoveList();
        pet.removed = true;

        if (pet.isControlled()) {
            sendPacket(new PetSpells());

            if (getGroup()) {
                setGroupUpdateFlag(GroupUpdateFlags.pet);
            }
        }
    }

    public final void sendTameFailure(PetTameResult result) {
        PetTameFailure petTameFailure = new PetTameFailure();
        petTameFailure.result = (byte) result.getValue();
        sendPacket(petTameFailure);
    }

    public final void addPetAura(PetAura petSpell) {
        getPetAuras().add(petSpell);

        var pet = getCurrentPet();

        if (pet != null) {
            pet.CastPetAura(petSpell);
        }
    }

    public final void removePetAura(PetAura petSpell) {
        getPetAuras().remove(petSpell);

        var pet = getCurrentPet();

        if (pet != null) {
            pet.removeAura(petSpell.getAura(pet.getEntry()));
        }
    }

    public final void sendOnCancelExpectedVehicleRideAura() {
        sendPacket(new OnCancelExpectedRideVehicleAura());
    }

    public final void sendMovementSetCollisionHeight(float height, UpdateCollisionHeightReason reason) {
        MoveSetCollisionHeight setCollisionHeight = new MoveSetCollisionHeight();
        setCollisionHeight.moverGUID = getGUID();
        setCollisionHeight.sequenceIndex = getMovementCounter();
        setMovementCounter(getMovementCounter() + 1);
        setCollisionHeight.height = height;
        setCollisionHeight.scale = getObjectScale();
        setCollisionHeight.mountDisplayID = getMountDisplayId();
        setCollisionHeight.scaleDuration = getUnitData().scaleDuration;
        setCollisionHeight.reason = reason;
        sendPacket(setCollisionHeight);

        MoveUpdateCollisionHeight updateCollisionHeight = new MoveUpdateCollisionHeight();
        updateCollisionHeight.status = getMovementInfo();
        updateCollisionHeight.height = height;
        updateCollisionHeight.scale = getObjectScale();
        sendMessageToSet(updateCollisionHeight, false);
    }

    public final void sendPlayerChoice(ObjectGuid sender, int choiceId) {
        var playerChoice = global.getObjectMgr().getPlayerChoice(choiceId);

        if (playerChoice == null) {
            return;
        }

        var locale = getSession().getSessionDbLocaleIndex();
        var playerChoiceLocale = locale != locale.enUS ? global.getObjectMgr().getPlayerChoiceLocale(choiceId) : null;

        getPlayerTalkClass().getInteractionData().reset();
        getPlayerTalkClass().getInteractionData().setSourceGuid(sender);
        getPlayerTalkClass().getInteractionData().setPlayerChoiceId((int) choiceId);

        DisplayPlayerChoice displayPlayerChoice = new DisplayPlayerChoice();
        displayPlayerChoice.senderGUID = sender;
        displayPlayerChoice.choiceID = choiceId;
        displayPlayerChoice.uiTextureKitID = playerChoice.uiTextureKitId;
        displayPlayerChoice.soundKitID = playerChoice.soundKitId;
        displayPlayerChoice.question = playerChoice.question;

        if (playerChoiceLocale != null) {
            tangible.RefObject<String> tempRef_Question = new tangible.RefObject<String>(displayPlayerChoice.question);
            ObjectManager.getLocaleString(playerChoiceLocale.question, locale, tempRef_Question);
            displayPlayerChoice.question = tempRef_Question.refArgValue;
        }

        displayPlayerChoice.closeChoiceFrame = false;
        displayPlayerChoice.hideWarboardHeader = playerChoice.hideWarboardHeader;
        displayPlayerChoice.keepOpenAfterChoice = playerChoice.keepOpenAfterChoice;

        for (var i = 0; i < playerChoice.responses.size(); ++i) {
            var playerChoiceResponseTemplate = playerChoice.responses.get(i);
            var playerChoiceResponse = new networking.packets.PlayerChoiceResponse();

            playerChoiceResponse.responseID = playerChoiceResponseTemplate.ResponseId;
            playerChoiceResponse.responseIdentifier = playerChoiceResponseTemplate.responseIdentifier;
            playerChoiceResponse.choiceArtFileID = playerChoiceResponseTemplate.ChoiceArtFileId;
            playerChoiceResponse.flags = playerChoiceResponseTemplate.flags;
            playerChoiceResponse.widgetSetID = playerChoiceResponseTemplate.widgetSetID;
            playerChoiceResponse.uiTextureAtlasElementID = playerChoiceResponseTemplate.uiTextureAtlasElementID;
            playerChoiceResponse.soundKitID = playerChoiceResponseTemplate.soundKitID;
            playerChoiceResponse.groupID = playerChoiceResponseTemplate.groupID;
            playerChoiceResponse.uiTextureKitID = playerChoiceResponseTemplate.uiTextureKitID;
            playerChoiceResponse.answer = playerChoiceResponseTemplate.answer;
            playerChoiceResponse.header = playerChoiceResponseTemplate.header;
            playerChoiceResponse.subHeader = playerChoiceResponseTemplate.subHeader;
            playerChoiceResponse.buttonTooltip = playerChoiceResponseTemplate.buttonTooltip;
            playerChoiceResponse.description = playerChoiceResponseTemplate.description;
            playerChoiceResponse.confirmation = playerChoiceResponseTemplate.confirmation;

            if (playerChoiceLocale != null) {
                var playerChoiceResponseLocale = playerChoiceLocale.responses.get(playerChoiceResponseTemplate.ResponseId);

                if (playerChoiceResponseLocale != null) {
                    tangible.RefObject<String> tempRef_Answer = new tangible.RefObject<String>(playerChoiceResponse.answer);
                    ObjectManager.getLocaleString(playerChoiceResponseLocale.answer, locale, tempRef_Answer);
                    playerChoiceResponse.answer = tempRef_Answer.refArgValue;
                    tangible.RefObject<String> tempRef_Header = new tangible.RefObject<String>(playerChoiceResponse.header);
                    ObjectManager.getLocaleString(playerChoiceResponseLocale.header, locale, tempRef_Header);
                    playerChoiceResponse.header = tempRef_Header.refArgValue;
                    tangible.RefObject<String> tempRef_SubHeader = new tangible.RefObject<String>(playerChoiceResponse.subHeader);
                    ObjectManager.getLocaleString(playerChoiceResponseLocale.subHeader, locale, tempRef_SubHeader);
                    playerChoiceResponse.subHeader = tempRef_SubHeader.refArgValue;
                    tangible.RefObject<String> tempRef_ButtonTooltip = new tangible.RefObject<String>(playerChoiceResponse.buttonTooltip);
                    ObjectManager.getLocaleString(playerChoiceResponseLocale.buttonTooltip, locale, tempRef_ButtonTooltip);
                    playerChoiceResponse.buttonTooltip = tempRef_ButtonTooltip.refArgValue;
                    tangible.RefObject<String> tempRef_Description = new tangible.RefObject<String>(playerChoiceResponse.description);
                    ObjectManager.getLocaleString(playerChoiceResponseLocale.description, locale, tempRef_Description);
                    playerChoiceResponse.description = tempRef_Description.refArgValue;
                    tangible.RefObject<String> tempRef_Confirmation = new tangible.RefObject<String>(playerChoiceResponse.confirmation);
                    ObjectManager.getLocaleString(playerChoiceResponseLocale.confirmation, locale, tempRef_Confirmation);
                    playerChoiceResponse.confirmation = tempRef_Confirmation.refArgValue;
                }
            }

            if (playerChoiceResponseTemplate.reward != null) {
                var reward = new networking.packets.PlayerChoiceResponseReward();
                reward.titleID = playerChoiceResponseTemplate.reward.titleId;
                reward.packageID = playerChoiceResponseTemplate.reward.PackageId;
                reward.skillLineID = playerChoiceResponseTemplate.reward.SkillLineId;
                reward.skillPointCount = playerChoiceResponseTemplate.reward.skillPointCount;
                reward.arenaPointCount = playerChoiceResponseTemplate.reward.arenaPointCount;
                reward.honorPointCount = playerChoiceResponseTemplate.reward.honorPointCount;
                reward.money = playerChoiceResponseTemplate.reward.money;
                reward.xp = playerChoiceResponseTemplate.reward.xp;

                for (var item : playerChoiceResponseTemplate.reward.items) {
                    var rewardEntry = new networking.packets.PlayerChoiceResponseRewardEntry();
                    rewardEntry.item.itemID = item.id;
                    rewardEntry.quantity = item.quantity;

                    if (!item.bonusListIDs.isEmpty()) {
                        rewardEntry.item.itemBonus = new ItemBonuses();
                        rewardEntry.item.itemBonus.bonusListIDs = item.bonusListIDs;
                    }

                    reward.items.add(rewardEntry);
                }

                for (var currency : playerChoiceResponseTemplate.reward.currency) {
                    var rewardEntry = new networking.packets.PlayerChoiceResponseRewardEntry();
                    rewardEntry.item.itemID = currency.id;
                    rewardEntry.quantity = currency.quantity;
                    reward.items.add(rewardEntry);
                }

                for (var faction : playerChoiceResponseTemplate.reward.faction) {
                    var rewardEntry = new networking.packets.PlayerChoiceResponseRewardEntry();
                    rewardEntry.item.itemID = faction.id;
                    rewardEntry.quantity = faction.quantity;
                    reward.items.add(rewardEntry);
                }

                for (var item : playerChoiceResponseTemplate.reward.itemChoices) {
                    var rewardEntry = new networking.packets.PlayerChoiceResponseRewardEntry();
                    rewardEntry.item.itemID = item.id;
                    rewardEntry.quantity = item.quantity;

                    if (!item.bonusListIDs.isEmpty()) {
                        rewardEntry.item.itemBonus = new ItemBonuses();
                        rewardEntry.item.itemBonus.bonusListIDs = item.bonusListIDs;
                    }

                    reward.itemChoices.add(rewardEntry);
                }

                playerChoiceResponse.reward = reward;
                displayPlayerChoice.responses.set(i, playerChoiceResponse);
            }

            playerChoiceResponse.rewardQuestID = playerChoiceResponseTemplate.rewardQuestID;

            if (playerChoiceResponseTemplate.MAWPOWER != null) {
                var mawPower = new networking.packets.PlayerChoiceResponseMawPower();
                mawPower.typeArtFileID = playerChoiceResponse.MAWPOWER.getValue().typeArtFileID;
                mawPower.rarity = playerChoiceResponse.MAWPOWER.getValue().rarity;
                mawPower.rarityColor = playerChoiceResponse.MAWPOWER.getValue().rarityColor;
                mawPower.spellID = playerChoiceResponse.MAWPOWER.getValue().spellID;
                mawPower.maxStacks = playerChoiceResponse.MAWPOWER.getValue().maxStacks;

                playerChoiceResponse.MAWPOWER = mawPower;
            }
        }

        sendPacket(displayPlayerChoice);
    }

    public final boolean meetPlayerCondition(int conditionId) {
        var playerCondition = CliDB.PlayerConditionStorage.get(conditionId);

        if (playerCondition != null) {
            if (!ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                return false;
            }
        }

        return true;
    }

    public final boolean canEnableWarModeInArea() {
        var zone = CliDB.AreaTableStorage.get(getZone());

        if (zone == null || !isFriendlyArea(zone)) {
            return false;
        }

        var area = CliDB.AreaTableStorage.get(getArea());

        if (area == null) {
            area = zone;
        }

        do {
            if ((area.Flags[1] & (int) AreaFlags2.CanEnableWarMode.getValue()) != 0) {
                return true;
            }

            area = CliDB.AreaTableStorage.get(area.ParentAreaID);
        } while (area != null);

        return false;
    }

    // Used in triggers for check "Only to targets that grant experience or honor" req
    public final boolean isHonorOrXPTarget(Unit victim) {
        var v_level = victim.getLevelForTarget(this);
        var k_grey = Formulas.getGrayLevel(getLevel());

        // Victim level less gray level
        if (v_level < k_grey && WorldConfig.getIntValue(WorldCfg.MinCreatureScaledXpRatio) == 0) {
            return false;
        }

        var creature = victim.toCreature();

        if (creature != null) {
            if (creature.isCritter() || creature.isTotem()) {
                return false;
            }
        }

        return true;
    }

    public final void setRegenTimerCount(int time) {
        regenTimerCount = time;
    }

    public final boolean hasEnoughMoney(long amount) {
        return getMoney() >= amount;
    }

    public final boolean modifyMoney(long amount) {
        return modifyMoney(amount, true);
    }

    public final boolean modifyMoney(long amount, boolean sendError) {
        if (amount == 0) {
            return true;
        }

        global.getScriptMgr().<IPlayerOnMoneyChanged>ForEach(p -> p.OnMoneyChanged(this, amount));

        if (amount < 0) {
            setMoney((long) (getMoney() > (long) -amount ? (long) getMoney() + amount : 0));
        } else {
            if (getMoney() <= (PlayerConst.MaxMoneyAmount - (long) amount)) {
                setMoney((long) (getMoney() + amount));
            } else {
                if (sendError) {
                    sendEquipError(InventoryResult.TooMuchGold);
                }

                return false;
            }
        }

        return true;
    }

    //Target
    // Used for serverside target changes, does not apply to players
    @Override
    public void setTarget(ObjectGuid guid) {
    }

    public final void setSelection(ObjectGuid guid) {
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().target), guid);
    }

    //LoginFlag
    public final boolean hasAtLoginFlag(AtLoginFlags f) {
        return (boolean) (getLoginFlags().getValue() & f.getValue());
    }

    public final void setAtLoginFlag(AtLoginFlags f) {
        setLoginFlags(AtLoginFlags.forValue(getLoginFlags().getValue() | f.getValue()));
    }

    public final void removeAtLoginFlag(AtLoginFlags flags) {
        removeAtLoginFlag(flags, false);
    }

    public final void removeAtLoginFlag(AtLoginFlags flags, boolean persist) {
        setLoginFlags(AtLoginFlags.forValue(getLoginFlags().getValue() & ~flags.getValue()));

        if (persist) {
            var stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_REM_AT_LOGIN_FLAG);
            stmt.AddValue(0, (short) flags.getValue());
            stmt.AddValue(1, getGUID().getCounter());

            DB.characters.execute(stmt);
        }
    }

    //Guild
    public final void setInGuild(long guildId) {
        if (guildId != 0) {
            setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().guildGUID), ObjectGuid.create(HighGuid.Guild, guildId));
            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().guildClubMemberID), getGUID().getCounter());
            setPlayerFlag(playerFlags.GuildLevelEnabled);
        } else {
            setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().guildGUID), ObjectGuid.Empty);
            removePlayerFlag(playerFlags.GuildLevelEnabled);
        }

        global.getCharacterCacheStorage().updateCharacterGuildId(getGUID(), guildId);
    }

    public final void setFreePrimaryProfessions(int profs) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().characterPoints), profs);
    }

    public final void giveLevel(int level) {
        var oldLevel = getLevel();

        if (level == oldLevel) {
            return;
        }

        var guild = getGuild();

        if (guild != null) {
            guild.updateMemberData(this, GuildMemberData.level, level);
        }

        var info = global.getObjectMgr().getPlayerLevelInfo(getRace(), getClass(), level);

        int basemana;
        tangible.OutObject<Integer> tempOut_basemana = new tangible.OutObject<Integer>();
        global.getObjectMgr().getPlayerClassLevelInfo(getClass(), level, tempOut_basemana);
        basemana = tempOut_basemana.outArgValue;

        LevelUpInfo packet = new LevelUpInfo();
        packet.level = level;
        packet.healthDelta = 0;

        // @todo find some better solution
        packet.PowerDelta[0] = basemana - getCreateMana();
        packet.PowerDelta[1] = 0;
        packet.PowerDelta[2] = 0;
        packet.PowerDelta[3] = 0;
        packet.PowerDelta[4] = 0;
        packet.PowerDelta[5] = 0;
        packet.PowerDelta[6] = 0;

        for (var i = stats.Strength; i.getValue() < stats.max.getValue(); ++i) {
            packet.StatDelta[i.getValue()] = info.getStats()[i.getValue()] - (int) getCreateStat(i);
        }

        packet.numNewTalents = (int) (global.getDB2Mgr().GetNumTalentsAtLevel(level, getClass()) - global.getDB2Mgr().GetNumTalentsAtLevel(oldLevel, getClass()));
        packet.numNewPvpTalentSlots = global.getDB2Mgr().GetPvpTalentNumSlotsAtLevel(level, getClass()) - global.getDB2Mgr().GetPvpTalentNumSlotsAtLevel(oldLevel, getClass());

        sendPacket(packet);

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().nextLevelXP), global.getObjectMgr().getXPForLevel(level));

        //update level, max level of skills
        playedTimeLevel = 0; // Level Played Time reset

        _ApplyAllLevelScaleItemMods(false);

        setLevel(level, false);

        updateSkillsForLevel();
        learnDefaultSkills();
        learnSpecializationSpells();

        // save base values (bonuses already included in stored stats
        for (var i = stats.Strength; i.getValue() < stats.max.getValue(); ++i) {
            setCreateStat(i, info.getStats()[i.getValue()]);
        }

        setCreateHealth(0);
        setCreateMana(basemana);

        initTalentForLevel();
        initTaxiNodesForLevel();

        updateAllStats();

        _ApplyAllLevelScaleItemMods(true); // Moved to above SetFullHealth so player will have full health from Heirlooms

        var artifactAura = getAura(PlayerConst.ArtifactsAllWeaponsGeneralWeaponEquippedPassive);

        if (artifactAura != null) {
            var artifact = getItemByGuid(artifactAura.castItemGuid);

            if (artifact != null) {
                artifact.checkArtifactRelicSlotUnlock(this);
            }
        }

        // Only health and mana are set to maximum.
        setFullHealth();
        setFullPower(powerType.mana);

        // update level to hunter/summon pet
        var pet = getCurrentPet();

        if (pet) {
            pet.SynchronizeLevelWithOwner();
        }

        var mailReward = global.getObjectMgr().getMailLevelReward(level, (int) SharedConst.GetMaskForRace(getRace()));

        if (mailReward != null) {
            //- TODO: Poor design of mail system
            SQLTransaction trans = new SQLTransaction();
            (new MailDraft(mailReward.mailTemplateId)).sendMailTo(trans, this, new MailSender(MailMessageType.CREATURE, mailReward.senderEntry));
            DB.characters.CommitTransaction(trans);
        }

        updateCriteria(CriteriaType.ReachLevel);
        updateCriteria(CriteriaType.ActivelyReachLevel, level);

        pushQuests();

        global.getScriptMgr().<IPlayerOnLevelChanged>ForEach(getClass(), p -> p.OnLevelChanged(this, oldLevel));
    }

    public final void toggleAFK() {
        if (isAFK()) {
            removePlayerFlag(playerFlags.AFK);
        } else {
            setPlayerFlag(playerFlags.AFK);
        }

        // afk player not allowed in Battleground
        if (!isGameMaster() && isAFK() && getInBattleground() && !getInArena()) {
            leaveBattleground();
        }
    }

    public final void toggleDND() {
        if (isDND()) {
            removePlayerFlag(playerFlags.DND);
        } else {
            setPlayerFlag(playerFlags.DND);
        }
    }

    public final void initDisplayIds() {
        var model = global.getDB2Mgr().GetChrModel(getRace(), getNativeGender());

        if (model == null) {
            Log.outError(LogFilter.player, String.format("Player %1$s has incorrect race/gender pair. Can't init display ids.", getGUID()));

            return;
        }

        setDisplayId(model.displayID);
        setNativeDisplayId(model.displayID);
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().stateAnimID), global.getDB2Mgr().GetEmptyAnimStateID());
    }

    //Creature
    public final Creature getNPCIfCanInteractWith(ObjectGuid guid, NPCFlags npcFlags, NPCFlags2 npcFlags2) {
        // unit checks
        if (guid.isEmpty()) {
            return null;
        }

        if (!isInWorld()) {
            return null;
        }

        if (isInFlight()) {
            return null;
        }

        // exist (we need look pets also for some interaction (quest/etc)
        var creature = ObjectAccessor.GetCreatureOrPetOrVehicle(this, guid);

        if (creature == null) {
            return null;
        }

        // Deathstate checks
        if (!isAlive() && !(boolean) (creature.getTemplate().typeFlags.getValue() & CreatureTypeFlags.VisibleToGhosts.getValue())) {
            return null;
        }

        // alive or spirit healer
        if (!creature.isAlive() && !(boolean) (creature.getTemplate().typeFlags.getValue() & CreatureTypeFlags.InteractWhileDead.getValue())) {
            return null;
        }

        // appropriate npc type
// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		bool hasNpcFlags()
//			{
//				if (npcFlags == 0 && npcFlags2 == 0)
//					return true;
//
//				if (creature.hasNpcFlag(npcFlags))
//					return true;
//
//				if (creature.hasNpcFlag2(npcFlags2))
//					return true;
//
//				return false;
//			}

        if (!hasNpcFlags()) {
            return null;
        }

        // not allow interaction under control, but allow with own pets
        if (!creature.getCharmerGUID().isEmpty()) {
            return null;
        }

        // not unfriendly/hostile
        if (creature.getReactionTo(this) <= ReputationRank.Unfriendly.getValue()) {
            return null;
        }

        // not too far, taken from CGGameUI::SetInteractTarget
        if (!creature.isWithinDistInMap(this, creature.getCombatReach() + 4.0f)) {
            return null;
        }

        return creature;
    }

    public final GameObject getGameObjectIfCanInteractWith(ObjectGuid guid) {
        if (guid.isEmpty()) {
            return null;
        }

        if (!isInWorld()) {
            return null;
        }

        if (isInFlight()) {
            return null;
        }

        // exist
        var go = ObjectAccessor.getGameObject(this, guid);

        if (go == null) {
            return null;
        }

        // Players cannot interact with gameobjects that use the "Point" icon
        if (Objects.equals(go.getTemplate().iconName, "Point")) {
            return null;
        }

        if (!go.isWithinDistInMap(this)) {
            return null;
        }

        return go;
    }

    public final GameObject getGameObjectIfCanInteractWith(ObjectGuid guid, GameObjectTypes type) {
        var go = getGameObjectIfCanInteractWith(guid);

        if (!go) {
            return null;
        }

        if (go.getGoType() != type) {
            return null;
        }

        return go;
    }

// C# TO JAVA CONVERTER TASK: There is no preprocessor in Java:
    ///#endregion

// C# TO JAVA CONVERTER TASK: There is no preprocessor in Java:
    ///#region Chat

    public final void sendInitialPacketsBeforeAddToMap() {
        if (!teleportOptions.hasFlag(TeleportToOptions.Seamless)) {
            setMovementCounter(0);
            getSession().resetTimeSync();
        }

        getSession().sendTimeSync();

        getSocial().sendSocialList(this, SocialFlag.All);

        // SMSG_BINDPOINTUPDATE
        sendBindPointUpdate();

        // SMSG_SET_PROFICIENCY
        // SMSG_SET_PCT_SPELL_MODIFIER
        // SMSG_SET_FLAT_SPELL_MODIFIER

        // SMSG_TALENTS_INFO
        sendTalentsInfoData();

        // SMSG_INITIAL_SPELLS
        sendKnownSpells();

        // SMSG_SEND_UNLEARN_SPELLS
        sendUnlearnSpells();

        // SMSG_SEND_SPELL_HISTORY
        SendSpellHistory sendSpellHistory = new SendSpellHistory();
        getSpellHistory().writePacket(sendSpellHistory);
        sendPacket(sendSpellHistory);

        // SMSG_SEND_SPELL_CHARGES
        SendSpellCharges sendSpellCharges = new SendSpellCharges();
        getSpellHistory().writePacket(sendSpellCharges);
        sendPacket(sendSpellCharges);

        ActiveGlyphs activeGlyphs = new ActiveGlyphs();

        for (var glyphId : getGlyphs(getActiveTalentGroup())) {
            var bindableSpells = global.getDB2Mgr().GetGlyphBindableSpells(glyphId);

            for (var bindableSpell : bindableSpells) {
                if (hasSpell(bindableSpell) && !overrideSpells.ContainsKey(bindableSpell)) {
                    activeGlyphs.glyphs.add(new GlyphBinding(bindableSpell, (short) glyphId));
                }
            }
        }

        activeGlyphs.isFullUpdate = true;
        sendPacket(activeGlyphs);

        // SMSG_ACTION_BUTTONS
        sendInitialActionButtons();

        // SMSG_INITIALIZE_FACTIONS
        reputationMgr.sendInitialReputations();

        // SMSG_SETUP_CURRENCY
        sendCurrencies();

        // SMSG_EQUIPMENT_SET_LIST
        sendEquipmentSetList();

        _AchievementSys.sendAllData(this);
        questObjectiveCriteriaManager.sendAllData(this);

        // SMSG_LOGIN_SETTIMESPEED
        var TimeSpeed = 0.01666667f;
        LoginSetTimeSpeed loginSetTimeSpeed = new LoginSetTimeSpeed();
        loginSetTimeSpeed.newSpeed = TimeSpeed;
        loginSetTimeSpeed.gameTime = (int) gameTime.GetGameTime();
        loginSetTimeSpeed.serverTime = (int) gameTime.GetGameTime();
        loginSetTimeSpeed.gameTimeHolidayOffset = 0; // @todo
        loginSetTimeSpeed.serverTimeHolidayOffset = 0; // @todo
        sendPacket(loginSetTimeSpeed);

        // SMSG_WORLD_SERVER_INFO
        WorldServerInfo worldServerInfo = new WorldServerInfo();
        worldServerInfo.instanceGroupSize = getMap().getMapDifficulty().MaxPlayers; // @todo
        worldServerInfo.isTournamentRealm = false; // @todo
        worldServerInfo.restrictedAccountMaxLevel = null; // @todo
        worldServerInfo.restrictedAccountMaxMoney = null; // @todo
        worldServerInfo.difficultyID = (int) getMap().getDifficultyID().getValue();
        // worldServerInfo.XRealmPvpAlert;  // @todo
        sendPacket(worldServerInfo);

        // Spell modifiers
        sendSpellModifiers();

        // SMSG_ACCOUNT_MOUNT_UPDATE
        AccountMountUpdate mountUpdate = new AccountMountUpdate();
        mountUpdate.isFullUpdate = true;
        mountUpdate.mounts = getSession().getCollectionMgr().getAccountMounts();
        sendPacket(mountUpdate);

        // SMSG_ACCOUNT_TOYS_UPDATE
        AccountToyUpdate toyUpdate = new AccountToyUpdate();
        toyUpdate.isFullUpdate = true;
        toyUpdate.toys = getSession().getCollectionMgr().getAccountToys();
        sendPacket(toyUpdate);

        // SMSG_ACCOUNT_HEIRLOOM_UPDATE
        AccountHeirloomUpdate heirloomUpdate = new AccountHeirloomUpdate();
        heirloomUpdate.isFullUpdate = true;
        heirloomUpdate.heirlooms = getSession().getCollectionMgr().getAccountHeirlooms();
        sendPacket(heirloomUpdate);

        getSession().getCollectionMgr().sendFavoriteAppearances();

        InitialSetup initialSetup = new InitialSetup();
        initialSetup.serverExpansionLevel = (byte) WorldConfig.getIntValue(WorldCfg.expansion);
        sendPacket(initialSetup);

        setMovedUnit(this);
    }

    public final void sendInitialPacketsAfterAddToMap() {
        updateVisibilityForPlayer();

        // update zone
        int newzone;
        tangible.OutObject<Integer> tempOut_newzone = new tangible.OutObject<Integer>();
        int newarea;
        tangible.OutObject<Integer> tempOut_newarea = new tangible.OutObject<Integer>();
        getZoneAndAreaId(tempOut_newzone, tempOut_newarea);
        newarea = tempOut_newarea.outArgValue;
        newzone = tempOut_newzone.outArgValue;
        updateZone(newzone, newarea); // also call sendInitWorldStates();

        getSession().sendLoadCUFProfiles();

        castSpell(this, 836, true); // LOGINEFFECT

        // set some aura effects that send packet to player client after add player to map
        // SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
        // same auras state lost at far teleport, send it one more time in this case also
        AuraType[] auratypes = {AuraType.ModFear, AuraType.Transform, AuraType.WaterWalk, AuraType.FeatherFall, AuraType.Hover, AuraType.SafeFall, AuraType.Fly, AuraType.ModIncreaseMountedFlightSpeed, AuraType.None};

        for (var aura : auratypes) {
            var auraList = getAuraEffectsByType(aura);

            if (!auraList.isEmpty()) {
                auraList.get(0).handleEffect(this, AuraEffectHandleModes.SendForClient, true);
            }
        }

        if (hasAuraType(AuraType.ModStun) || hasAuraType(AuraType.ModStunDisableGravity)) {
            setRooted(true);
        }

        MoveSetCompoundState setCompoundState = new MoveSetCompoundState();

        // manual send package (have code in handleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
        if (hasAuraType(AuraType.ModRoot) || hasAuraType(AuraType.ModRoot2) || hasAuraType(AuraType.ModRootDisableGravity)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveRoot, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.FeatherFall)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveSetFeatherFall, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.WaterWalk)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveSetWaterWalk, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.Hover)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveSetHovering, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.ModRootDisableGravity) || hasAuraType(AuraType.ModStunDisableGravity)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveDisableGravity, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.CanTurnWhileFalling)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveSetCanTurnWhileFalling, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAura(196055)) //DH DoubleJump
        {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveEnableDoubleJump, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.IgnoreMovementForces)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveSetIgnoreMovementForces, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (hasAuraType(AuraType.DisableInertia)) {
            setCompoundState.stateChanges.add(new MoveSetCompoundState.MoveStateChange(ServerOpcode.MoveDisableInertia, getMovementCounter()));
            setMovementCounter(getMovementCounter() + 1);
        }

        if (!setCompoundState.stateChanges.isEmpty()) {
            setCompoundState.moverGUID = getGUID();
            sendPacket(setCompoundState);
        }

        sendAurasForTarget(this);
        sendEnchantmentDurations(); // must be after add to map
        sendItemDurations(); // must be after add to map

        // raid downscaling - send difficulty to player
        if (getMap().isRaid()) {
            var mapDifficulty = getMap().getDifficultyID();
            var difficulty = CliDB.DifficultyStorage.get(mapDifficulty);
            sendRaidDifficulty((difficulty.flags.getValue() & DifficultyFlags.legacy.getValue()) != 0, mapDifficulty.getValue());
        } else if (getMap().isNonRaidDungeon()) {
            sendDungeonDifficulty(getMap().getDifficultyID().getValue());
        }

        PhasingHandler.onMapChange(this);

        if (garrison != null) {
            garrison.sendRemoteInfo();
        }

        updateItemLevelAreaBasedScaling();

        if (!getPlayerSharingQuest().isEmpty()) {
            var quest = global.getObjectMgr().getQuestTemplate(getSharedQuestID());

            if (quest != null) {
                getPlayerTalkClass().sendQuestGiverQuestDetails(quest, getGUID(), true, false);
            } else {
                clearQuestSharingInfo();
            }
        }

        getSceneMgr().triggerDelayedScenes();
    }

    public final void removeSocial() {
        global.getSocialMgr().removePlayerSocial(getGUID());
        social = null;
    }

    public final void saveRecallPosition() {
        recallLocation = new worldLocation(getLocation());
        recallInstanceId = getInstanceId();
    }

    public final void recall() {
        teleportTo(recallLocation, 0, recallInstanceId);
    }

    public final void initStatsForLevel() {
        initStatsForLevel(false);
    }

    public final void initStatsForLevel(boolean reapplyMods) {
        if (reapplyMods) //reapply stats values only on .reset stats (level) command
        {
            _RemoveAllStatBonuses();
        }

        int basemana;
        tangible.OutObject<Integer> tempOut_basemana = new tangible.OutObject<Integer>();
        global.getObjectMgr().getPlayerClassLevelInfo(getClass(), getLevel(), tempOut_basemana);
        basemana = tempOut_basemana.outArgValue;

        var info = global.getObjectMgr().getPlayerLevelInfo(getRace(), getClass(), getLevel());

        var exp_max_lvl = (int) global.getObjectMgr().getMaxLevelForExpansion(getSession().getExpansion());
        var conf_max_lvl = WorldConfig.getIntValue(WorldCfg.MaxPlayerLevel);

        if (exp_max_lvl == SharedConst.DefaultMaxLevel || exp_max_lvl >= conf_max_lvl) {
            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().maxLevel), conf_max_lvl);
        } else {
            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().maxLevel), exp_max_lvl);
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().nextLevelXP), global.getObjectMgr().getXPForLevel(getLevel()));

        if (getActivePlayerData().XP >= getActivePlayerData().nextLevelXP) {
            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().XP), getActivePlayerData().NextLevelXP - 1);
        }

        // reset before any aura state sources (health set/aura apply)
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().auraState), 0);

        updateSkillsForLevel();

        // set default cast time multiplier
        setModCastingSpeed(1.0f);
        setModSpellHaste(1.0f);
        setModHaste(1.0f);
        setModRangedHaste(1.0f);
        setModHasteRegen(1.0f);
        setModTimeRate(1.0f);

        // reset size before reapply auras
        setObjectScale(1.0f);

        // save base values (bonuses already included in stored stats
        for (var i = stats.Strength; i.getValue() < stats.max.getValue(); ++i) {
            setCreateStat(i, info.getStats()[i.getValue()]);
        }

        for (var i = stats.Strength; i.getValue() < stats.max.getValue(); ++i) {
            setStat(i, info.getStats()[i.getValue()]);
        }

        setCreateHealth(0);

        //set create powers
        setCreateMana(basemana);

        setArmor((int) (getCreateStat(stats.Agility) * 2), 0);

        initStatBuffMods();

        //reset rating fields values
        for (var index = 0; index < CombatRating.max.getValue(); ++index) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().combatRatings, index), 0);
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modHealingDonePos), 0);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modHealingPercent), 1.0f);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modPeriodicHealingDonePercent), 1.0f);

        for (byte i = 0; i < SpellSchools.max.getValue(); ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDoneNeg, i), 0);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDonePos, i), 0);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDonePercent, i), 1.0f);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modHealingDonePercent, i), 1.0f);
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modSpellPowerPercent), 1.0f);

        //reset attack power, damage and attack speed fields
        for (WeaponAttackType attackType = 0; attackType.getValue() < WeaponAttackType.max.getValue(); ++attackType) {
            setBaseAttackTime(attackType, SharedConst.baseAttackTime);
        }

        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().minDamage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().maxDamage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().minOffHandDamage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().maxOffHandDamage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().minRangedDamage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getUnitData()).modifyValue(getUnitData().maxRangedDamage), 0.0f);

        for (var i = 0; i < 3; ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().weaponDmgMultipliers, i), 1.0f);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().weaponAtkSpeedMultipliers, i), 1.0f);
        }

        setAttackPower(0);
        setAttackPowerMultiplier(0.0f);
        setRangedAttackPower(0);
        setRangedAttackPowerMultiplier(0.0f);

        // Base crit values (will be recalculated in updateAllStats() at loading and in _ApplyAllStatBonuses() at reset
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().critPercentage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().offhandCritPercentage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().rangedCritPercentage), 0.0f);

        // Init spell schools (will be recalculated in updateAllStats() at loading and in _ApplyAllStatBonuses() at reset
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().spellCritPercentage), 0.0f);

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().parryPercentage), 0.0f);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().blockPercentage), 0.0f);

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().shieldBlock), 0);

        // Dodge percentage
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().dodgePercentage), 0.0f);

        // set armor (resistance 0) to original second (create_agility*2)
        setArmor((int) (getCreateStat(stats.Agility) * 2), 0);
        setBonusResistanceMod(SpellSchools.NORMAL, 0);

        // set other resistance to original second (0)
        for (var spellSchool = SpellSchools.Holy; spellSchool.getValue() < SpellSchools.max.getValue(); ++spellSchool) {
            setResistance(spellSchool, 0);
            setBonusResistanceMod(spellSchool, 0);
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modTargetResistance), 0);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modTargetPhysicalResistance), 0);

        for (var i = 0; i < SpellSchools.max.getValue(); ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().manaCostModifier, i), 0);
        }

        // Reset no reagent cost field
        setNoRegentCostMask(new flagArray128());

        // Init data for form but skip reapply item mods for form
        initDataForForm(reapplyMods);

        // save new stats
        for (var i = powerType.mana; i.getValue() < powerType.max.getValue(); ++i) {
            setMaxPower(i, getCreatePowerValue(i));
        }

        setMaxHealth(0); // stamina bonus will applied later

        // cleanup mounted state (it will set correctly at aura loading if player saved at mount.
        setMountDisplayId(0);

        // cleanup unit flags (will be re-applied if need at aura load).
        removeUnitFlag(UnitFlag.NonAttackable.getValue() | UnitFlag.RemoveClientControl.getValue().getValue() | UnitFlag.NotAttackable1.getValue().getValue().getValue() | UnitFlag.ImmuneToPc.getValue().getValue().getValue().getValue() | UnitFlag.ImmuneToNpc.getValue().getValue().getValue().getValue().getValue() | UnitFlag.Looting.getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.PET_IN_COMBAT.getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Pacified.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Stunned.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.IN_COMBAT.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Disarmed.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Confused.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Fleeing.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Uninteractible.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.Skinnable.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.mount.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue() | UnitFlag.OnTaxi.getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue().getValue());

        setUnitFlag(UnitFlag.PlayerControlled); // must be set

        setUnitFlag2(UnitFlag2.RegeneratePower); // must be set

        // cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
        removePlayerFlag(playerFlags.AFK.getValue() | playerFlags.DND.getValue().getValue() | playerFlags.GM.getValue().getValue().getValue() | playerFlags.Ghost.getValue().getValue().getValue());

        removeVisFlag(UnitVisFlags.All); // one form stealth modified bytes
        removePvpFlag(UnitPVPStateFlags.FFAPvp.getValue() | UnitPVPStateFlags.Sanctuary.getValue());

        // restore if need some important flags
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().localRegenFlags), (byte) 0);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().auraVision), (byte) 0);

        if (reapplyMods) // reapply stats values only on .reset stats (level) command
        {
            _ApplyAllStatBonuses();
        }

        // set current level health and mana/energy to maximum after applying all mods.
        setFullHealth();
        setFullPower(powerType.mana);
        setFullPower(powerType.Energy);

        if (getPower(powerType.Rage) > getMaxPower(powerType.Rage)) {
            setFullPower(powerType.Rage);
        }

        setFullPower(powerType.Focus);
        setPower(powerType.RunicPower, 0);

        // update level to hunter/summon pet
        var pet = getCurrentPet();

        if (pet) {
            pet.SynchronizeLevelWithOwner();
        }
    }

    public final void initDataForForm() {
        initDataForForm(false);
    }

    public final void initDataForForm(boolean reapplyMods) {
        var form = getShapeshiftForm();

        var ssEntry = CliDB.SpellShapeshiftFormStorage.get((int) form.getValue());

        if (ssEntry != null && ssEntry.CombatRoundTime != 0) {
            setBaseAttackTime(WeaponAttackType.BaseAttack, ssEntry.CombatRoundTime);
            setBaseAttackTime(WeaponAttackType.OffAttack, ssEntry.CombatRoundTime);
            setBaseAttackTime(WeaponAttackType.RangedAttack, SharedConst.baseAttackTime);
        } else {
            setRegularAttackTime();
        }

        updateDisplayPower();

        // update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
        if (!reapplyMods) {
            updateEquipSpellsAtFormChange();
        }

        updateAttackPowerAndDamage();
        updateAttackPowerAndDamage(true);
    }

    public final ReputationRank getReputationRank(int faction) {
        var factionEntry = CliDB.FactionStorage.get(faction);

        return getReputationMgr().getRank(factionEntry);
    }

    public final void setReputation(int factionentry, int value) {
        getReputationMgr().setReputation(CliDB.FactionStorage.get(factionentry), value);
    }

    public final int getReputation(int factionentry) {
        return getReputationMgr().getReputation(CliDB.FactionStorage.get(factionentry));
    }

    public final void clearWhisperWhiteList() {
        whisperList.clear();
    }

    public final void addWhisperWhiteList(ObjectGuid guid) {
        whisperList.add(guid);
    }

    public final boolean isInWhisperWhiteList(ObjectGuid guid) {
        return whisperList.contains(guid);
    }

    public final void removeFromWhisperWhiteList(ObjectGuid guid) {
        whisperList.remove(guid);
    }

    public final void setFallInformation(int time, float z) {
        lastFallTime = time;
        lastFallZ = z;
    }

    public final void sendCinematicStart(int CinematicSequenceId) {
        TriggerCinematic packet = new TriggerCinematic();
        packet.cinematicID = CinematicSequenceId;
        sendPacket(packet);

        var sequence = CliDB.CinematicSequencesStorage.get(CinematicSequenceId);

        if (sequence != null) {
            cinematicMgr.beginCinematic(sequence);
        }
    }

    public final void sendMovieStart(int movieId) {
        setMovie(movieId);
        TriggerMovie packet = new TriggerMovie();
        packet.movieID = movieId;
        sendPacket(packet);
    }

    public final boolean hasRaceChanged() {
        return extraFlags.hasFlag(PlayerExtraFlags.HasRaceChanged);
    }

    public final void setHasRaceChanged() {
        extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.HasRaceChanged.getValue());
    }

    public final boolean hasBeenGrantedLevelsFromRaF() {
        return extraFlags.hasFlag(PlayerExtraFlags.GrantedLevelsFromRaf);
    }

// C# TO JAVA CONVERTER TASK: There is no preprocessor in Java:
    ///#endregion

    //public sbyte getCovenant()
    //{
    //    ObjectGuid guid = getGUID();

    //    var stmt = DB.character.GetPreparedStatement(CHAR_SEL_COVENANT);
    //    stmt.AddValue(0, guid.GetCounter());
    //    var covenant = CharacterDatabase.query(stmt);

    //    if (covenant == null)
    //    {
    //        return 0;
    //    }
    //    Field[] fields = covenant.Fetch();
    //    ushort _covenantId = fields[0].GetUInt16();

    //    return (sbyte)_covenantId;
    //}

    public final void setBeenGrantedLevelsFromRaF() {
        extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.GrantedLevelsFromRaf.getValue());
    }

    public final boolean hasLevelBoosted() {
        return extraFlags.hasFlag(PlayerExtraFlags.LevelBoosted);
    }

    public final void setHasLevelBoosted() {
        extraFlags = PlayerExtraFlags.forValue(extraFlags.getValue() | PlayerExtraFlags.LevelBoosted.getValue());
    }

    public final void giveXP(int xp, Unit victim) {
        giveXP(xp, victim, 1.0f);
    }

    public final void giveXP(int xp, Unit victim, float group_rate) {
        if (xp < 1) {
            return;
        }

        if (!isAlive() && getBattlegroundId() == 0) {
            return;
        }

        if (hasPlayerFlag(playerFlags.NoXPGain)) {
            return;
        }

        if (victim != null && victim.isTypeId(TypeId.UNIT) && !victim.toCreature().getHasLootRecipient()) {
            return;
        }

        var level = getLevel();

        tangible.RefObject<Integer> tempRef_xp = new tangible.RefObject<Integer>(xp);
        global.getScriptMgr().<IPlayerOnGiveXP>ForEach(p -> p.OnGiveXP(this, tempRef_xp, victim));
        xp = tempRef_xp.refArgValue;

        // XP to money conversion processed in player.RewardQuest
        if (isMaxLevel()) {
            return;
        }

        double bonus_xp;
        var recruitAFriend = getsRecruitAFriendBonus(true);

        // RaF does NOT stack with rested experience
        if (recruitAFriend) {
            bonus_xp = 2 * xp; // xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
        } else {
            bonus_xp = victim != null ? restMgr.getRestBonusFor(RestTypes.XP, xp) : 0; // XP resting bonus
        }

        LogXPGain packet = new LogXPGain();
        packet.victim = victim ? victim.getGUID() : ObjectGuid.Empty;
        packet.original = (int) (xp + bonus_xp);
        packet.reason = victim ? PlayerLogXPReason.Kill : PlayerLogXPReason.NoKill;
        packet.amount = xp;
        packet.groupBonus = group_rate;
        sendPacket(packet);

        var nextLvlXP = getXPForNextLevel();
        var newXP = getXP() + xp + (int) bonus_xp;

        while (newXP >= nextLvlXP && !isMaxLevel()) {
            newXP -= nextLvlXP;

            if (!isMaxLevel()) {
                giveLevel(level + 1);
            }

            level = getLevel();
            nextLvlXP = getXPForNextLevel();
        }

        setXP(newXP);
    }

    public final void handleBaseModFlatValue(BaseModGroup modGroup, double amount, boolean apply) {
        if (modGroup.getValue() >= BaseModGroup.End.getValue()) {
            Log.outError(LogFilter.spells, String.format("Player.HandleBaseModFlatValue: Invalid BaseModGroup (%1$s) for player '%2$s' (%3$s)", modGroup, getName(), getGUID()));

            return;
        }

        _auraBaseFlatMod[modGroup.getValue()] += apply ? amount : -amount;
        updateBaseModGroup(modGroup);
    }

    public final void applyBaseModPctValue(BaseModGroup modGroup, double pct) {
        if (modGroup.getValue() >= BaseModGroup.End.getValue()) {
            Log.outError(LogFilter.spells, String.format("Player.ApplyBaseModPctValue: Invalid BaseModGroup/BaseModType (%1$s/%2$s) for player '%3$s' (%4$s)", modGroup, BaseModType.flatMod, getName(), getGUID()));

            return;
        }

        tangible.RefObject<Double> tempRef_Object = new tangible.RefObject<Double>(_auraBasePctMod[modGroup.getValue()]);
        MathUtil.AddPct(tempRef_Object, pct);
        _auraBasePctMod[modGroup.getValue()] = tempRef_Object.refArgValue;
        updateBaseModGroup(modGroup);
    }

    public final void setBaseModFlatValue(BaseModGroup modGroup, double val) {
        if (_auraBaseFlatMod[modGroup.getValue()] == val) {
            return;
        }

        _auraBaseFlatMod[modGroup.getValue()] = val;
        updateBaseModGroup(modGroup);
    }

    public final void setBaseModPctValue(BaseModGroup modGroup, double val) {
        if (_auraBasePctMod[modGroup.getValue()] == val) {
            return;
        }

        _auraBasePctMod[modGroup.getValue()] = val;
        updateBaseModGroup(modGroup);
    }

    @Override
    public void updateDamageDoneMods(WeaponAttackType attackType) {
        updateDamageDoneMods(attackType, -1);
    }

    @Override
    public void updateDamageDoneMods(WeaponAttackType attackType, int skipEnchantSlot) {
        super.updateDamageDoneMods(attackType, skipEnchantSlot);

        var unitMod = switch (attackType) {
            case BaseAttack -> UnitMods.DamageMainHand.getValue();
            case OffAttack -> UnitMods.DamageOffHand.getValue();
            case RangedAttack -> UnitMods.DamageRanged.getValue();
// C# TO JAVA CONVERTER TASK: Throw expressions are not converted by C# to Java Converter:
            default -> throw new UnsupportedOperationException();
        };

        var amount = 0.0f;
        var item = getWeaponForAttack(attackType, true);

        if (item == null) {
            return;
        }

        for (var slot = EnchantmentSlot.Perm; slot.getValue() < EnchantmentSlot.max.getValue(); ++slot) {
            if (skipEnchantSlot == slot.getValue()) {
                continue;
            }

            var enchantmentEntry = CliDB.SpellItemEnchantmentStorage.get(item.getEnchantmentId(slot));

            if (enchantmentEntry == null) {
                continue;
            }

            for (byte i = 0; i < ItemConst.MaxItemEnchantmentEffects; ++i) {
                switch (enchantmentEntry.Effect[i]) {
                    case ItemEnchantmentType.Damage:
                        amount += enchantmentEntry.EffectScalingPoints[i];

                        break;
                    case ItemEnchantmentType.Totem:
                        if (getClass() == playerClass.Shaman) {
                            amount += enchantmentEntry.EffectScalingPoints[i] * item.getTemplate().getDelay() / 1000.0f;
                        }

                        break;
                    default:
                        break;
                }
            }
        }

        handleStatFlatModifier(unitMod, UnitModifierFlatType.Total, amount, true);
    }

    public final void setDrunkValue(byte newDrunkValue, int itemId) {
        var isSobering = newDrunkValue < getDrunkValue();
        var oldDrunkenState = getDrunkenstateByValue(getDrunkValue());

        if (newDrunkValue > 100) {
            newDrunkValue = 100;
        }

        // select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
        var drunkPercent = Math.max(newDrunkValue, getTotalAuraModifier(AuraType.ModFakeInebriate));

        if (drunkPercent != 0) {
            getInvisibilityDetect().addFlag(InvisibilityType.drunk);
            getInvisibilityDetect().setValue(InvisibilityType.drunk, drunkPercent);
        } else if (!hasAuraType(AuraType.ModFakeInebriate) && newDrunkValue == 0) {
            getInvisibilityDetect().delFlag(InvisibilityType.drunk);
        }

        var newDrunkenState = getDrunkenstateByValue(newDrunkValue);
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().inebriation), newDrunkValue);
        updateObjectVisibility();

        if (!isSobering) {
            drunkTimer = 0; // reset sobering timer
        }

        if (newDrunkenState == oldDrunkenState) {
            return;
        }

        CrossedInebriationThreshold data = new CrossedInebriationThreshold();
        data.guid = getGUID();
        data.threshold = (int) newDrunkenState.getValue();
        data.itemID = itemId;

        sendMessageToSet(data, true);
    }

    public final boolean activateTaxiPathTo(ArrayList<Integer> nodes, Creature npc, int spellid) {
        return activateTaxiPathTo(nodes, npc, spellid, 0);
    }

    public final boolean activateTaxiPathTo(ArrayList<Integer> nodes, Creature npc) {
        return activateTaxiPathTo(nodes, npc, 0, 0);
    }

    public final boolean activateTaxiPathTo(ArrayList<Integer> nodes) {
        return activateTaxiPathTo(nodes, null, 0, 0);
    }

    public final boolean activateTaxiPathTo(ArrayList<Integer> nodes, Creature npc, int spellid, int preferredMountDisplay) {
        if (nodes.size() < 2) {
            getSession().sendActivateTaxiReply(ActivateTaxiReply.NoSuchPath);

            return false;
        }

        // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
        if (getSession().isLogingOut() || isInCombat() || hasUnitState(UnitState.Stunned) || hasUnitState(UnitState.Root)) {
            getSession().sendActivateTaxiReply(ActivateTaxiReply.PlayerBusy);

            return false;
        }

        if (hasUnitFlag(UnitFlag.RemoveClientControl)) {
            return false;
        }

        // taximaster case
        if (npc != null) {
            // not let cheating with start flight mounted
            removeAurasByType(AuraType.Mounted);

            if (getDisplayId() != getNativeDisplayId()) {
                restoreDisplayId(true);
            }

            if (isDisallowedMountForm(getTransformSpell(), ShapeShiftForm.NONE, getDisplayId())) {
                getSession().sendActivateTaxiReply(ActivateTaxiReply.PlayerShapeshifted);

                return false;
            }

            // not let cheating with start flight in time of logout process || if casting not finished || while in combat || if not use Spell's with EffectSendTaxi
            if (isNonMeleeSpellCast(false)) {
                getSession().sendActivateTaxiReply(ActivateTaxiReply.PlayerBusy);

                return false;
            }
        }
        // cast case or scripted call case
        else {
            removeAurasByType(AuraType.Mounted);

            if (getDisplayId() != getNativeDisplayId()) {
                restoreDisplayId(true);
            }

            var spell = getCurrentSpell(CurrentSpellTypes.generic);

            if (spell != null) {
                if (spell.spellInfo.getId() != spellid) {
                    interruptSpell(CurrentSpellTypes.generic, false);
                }
            }

            interruptSpell(CurrentSpellTypes.AutoRepeat, false);

            spell = getCurrentSpell(CurrentSpellTypes.Channeled);

            if (spell != null) {
                if (spell.spellInfo.getId() != spellid) {
                    interruptSpell(CurrentSpellTypes.Channeled, true);
                }
            }
        }

        var sourcenode = nodes.get(0);

        // starting node too far away (cheat?)
        var node = CliDB.TaxiNodesStorage.get(sourcenode);

        if (node == null) {
            getSession().sendActivateTaxiReply(ActivateTaxiReply.NoSuchPath);

            return false;
        }

        // Prepare to flight start now

        // stop combat at start taxi flight if any
        combatStop();

        stopCastingCharm();
        stopCastingBindSight();
        exitVehicle();

        // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
        tradeCancel(true);

        // clean not finished taxi path if any
        getTaxi().clearTaxiDestinations();

        // 0 element current node
        getTaxi().addTaxiDestination(sourcenode);

        // fill destinations path tail
        int sourcepath = 0;
        int totalcost = 0;
        int firstcost = 0;

        var prevnode = sourcenode;
        int lastnode = 0;

        for (var i = 1; i < nodes.size(); ++i) {
            lastnode = nodes.get(i);
            int path;
            tangible.OutObject<Integer> tempOut_path = new tangible.OutObject<Integer>();
            int cost;
            tangible.OutObject<Integer> tempOut_cost = new tangible.OutObject<Integer>();
            global.getObjectMgr().getTaxiPath(prevnode, lastnode, tempOut_path, tempOut_cost);
            cost = tempOut_cost.outArgValue;
            path = tempOut_path.outArgValue;

            if (path == 0) {
                getTaxi().clearTaxiDestinations();

                return false;
            }

            totalcost += cost;

            if (i == 1) {
                firstcost = cost;
            }

            if (prevnode == sourcenode) {
                sourcepath = path;
            }

            getTaxi().addTaxiDestination(lastnode);

            prevnode = lastnode;
        }

        // get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
        //
        // Hack-Fix for Alliance not being able to use Acherus taxi. There is
        // only one mount ID for both sides. Probably not good to use 315 in case DBC nodes
        // change but I couldn't find a suitable alternative. OK to use class because only DK
        // can use this taxi.
        int mount_display_id;

        if (node.flags.hasFlag(TaxiNodeFlags.UseFavoriteMount) && preferredMountDisplay != 0) {
            mount_display_id = preferredMountDisplay;
        } else {
            mount_display_id = global.getObjectMgr().getTaxiMountDisplayId(sourcenode, getTeam(), npc == null || (sourcenode == 315 && getClass() == playerClass.Deathknight));
        }

        // in spell case allow 0 model
        if ((mount_display_id == 0 && spellid == 0) || sourcepath == 0) {
            getSession().sendActivateTaxiReply(ActivateTaxiReply.UnspecifiedServerError);
            getTaxi().clearTaxiDestinations();

            return false;
        }

        var money = getMoney();

        if (npc != null) {
            var discount = getReputationPriceDiscount(npc);
            totalcost = (int) Math.ceil(totalcost * discount);
            firstcost = (int) Math.ceil(firstcost * discount);
            getTaxi().setFlightMasterFactionTemplateId(npc.getFaction());
        } else {
            getTaxi().setFlightMasterFactionTemplateId(0);
        }

        if (money < totalcost) {
            getSession().sendActivateTaxiReply(ActivateTaxiReply.NotEnoughMoney);
            getTaxi().clearTaxiDestinations();

            return false;
        }

        //Checks and preparations done, DO FLIGHT
        updateCriteria(CriteriaType.BuyTaxi, 1);

        if (WorldConfig.getBoolValue(WorldCfg.InstantTaxi)) {
            var lastPathNode = CliDB.TaxiNodesStorage.get(nodes.get( ^ 1))
            getTaxi().clearTaxiDestinations();
            modifyMoney(-totalcost);
            updateCriteria(CriteriaType.MoneySpentOnTaxis, totalcost);
            teleportTo(lastPathNode.ContinentID, lastPathNode.pos.X, lastPathNode.pos.Y, lastPathNode.pos.Z, getLocation().getO());

            return false;
        } else {
            modifyMoney(-firstcost);
            updateCriteria(CriteriaType.MoneySpentOnTaxis, firstcost);
            getSession().sendActivateTaxiReply();
            getSession().sendDoFlight(mount_display_id, sourcepath);
        }

        return true;
    }

    public final boolean activateTaxiPathTo(int taxi_path_id) {
        return activateTaxiPathTo(taxi_path_id, 0);
    }

    public final boolean activateTaxiPathTo(int taxi_path_id, int spellid) {
        var entry = CliDB.TaxiPathStorage.get(taxi_path_id);

        if (entry == null) {
            return false;
        }

        ArrayList<Integer> nodes = new ArrayList<>();

        nodes.add(entry.FromTaxiNode);
        nodes.add(entry.ToTaxiNode);

        return activateTaxiPathTo(nodes, null, spellid);
    }

    public final void finishTaxiFlight() {
        if (!isInFlight()) {
            return;
        }

        getMotionMaster().remove(MovementGeneratorType.flight);
        getTaxi().clearTaxiDestinations(); // not destinations, clear source node
    }

    public final void cleanupAfterTaxiFlight() {
        getTaxi().clearTaxiDestinations(); // not destinations, clear source node
        dismount();
        removeUnitFlag(UnitFlag.RemoveClientControl.getValue() | UnitFlag.OnTaxi.getValue());
    }

    public final void continueTaxiFlight() {
        var sourceNode = getTaxi().getTaxiSource();

        if (sourceNode == 0) {
            return;
        }

        Log.outDebug(LogFilter.unit, "WORLD: Restart character {0} taxi flight", getGUID().toString());

        var mountDisplayId = global.getObjectMgr().getTaxiMountDisplayId(sourceNode, getTeam(), true);

        if (mountDisplayId == 0) {
            return;
        }

        var path = getTaxi().getCurrentTaxiPath();

        // search appropriate start path node
        int startNode = 0;

        var nodeList = CliDB.TaxiPathNodesByPath.get(path);

        float distPrev;
        var distNext = getLocation().getExactDistSq(nodeList[0].loc.X, nodeList[0].loc.Y, nodeList[0].loc.Z);

        for (var i = 1; i < nodeList.length; ++i) {
            var node = nodeList[i];
            var prevNode = nodeList[i - 1];

            // skip nodes at another map
            if (node.ContinentID != getLocation().getMapId()) {
                continue;
            }

            distPrev = distNext;

            distNext = getLocation().getExactDistSq(node.loc.X, node.loc.Y, node.loc.Z);

            var distNodes = (node.loc.X - prevNode.loc.X) * (node.loc.X - prevNode.loc.X) + (node.loc.Y - prevNode.loc.Y) * (node.loc.Y - prevNode.loc.Y) + (node.loc.Z - prevNode.loc.Z) * (node.loc.Z - prevNode.loc.Z);

            if (distNext + distPrev < distNodes) {
                startNode = i;

                break;
            }
        }

        getSession().sendDoFlight(mountDisplayId, path, startNode);
    }

    public final boolean getsRecruitAFriendBonus(boolean forXP) {
        var recruitAFriend = false;

        if (getLevel() <= WorldConfig.getIntValue(WorldCfg.MaxRecruitAFriendBonusPlayerLevel) || !forXP) {
            var group = getGroup();

            if (group) {
                for (var refe = group.getFirstMember(); refe != null; refe = refe.next()) {
                    var player = refe.getSource();

                    if (!player) {
                        continue;
                    }

                    if (!player.isAtRecruitAFriendDistance(this)) {
                        continue; // member (alive or dead) or his corpse at req. distance
                    }

                    if (forXP) {
                        // level must be allowed to get RaF bonus
                        if (player.getLevel() > WorldConfig.getIntValue(WorldCfg.MaxRecruitAFriendBonusPlayerLevel)) {
                            continue;
                        }

                        // level difference must be small enough to get RaF bonus, UNLESS we are lower level
                        if (player.getLevel() < getLevel()) {
                            if (getLevel() - player.getLevel() > WorldConfig.getIntValue(WorldCfg.MaxRecruitAFriendBonusPlayerLevelDifference)) {
                                continue;
                            }
                        }
                    }

                    var ARecruitedB = (player.getSession().getRecruiterId() == getSession().getAccountId());
                    var BRecruitedA = (getSession().getRecruiterId() == player.getSession().getAccountId());

                    if (ARecruitedB || BRecruitedA) {
                        recruitAFriend = true;

                        break;
                    }
                }
            }
        }

        return recruitAFriend;
    }

    public final void setSemaphoreTeleportNear(boolean semphsetting) {
        semaphoreTeleportNear = semphsetting;
    }

    public final void setSemaphoreTeleportFar(boolean semphsetting) {
        semaphoreTeleportFar = semphsetting;
    }

    public final void unlockReagentBank() {
        setPlayerFlagEx(playerFlagsEx.ReagentBankUnlocked);
    }

    //new
    public final int doRandomRoll(int minimum, int maximum) {
        var roll = RandomUtil.URand(minimum, maximum);

        RandomRoll randomRoll = new RandomRoll();
        randomRoll.min = minimum;
        randomRoll.max = maximum;
        randomRoll.result = (int) roll;
        randomRoll.roller = getGUID();
        randomRoll.rollerWowAccount = getSession().getAccountGUID();

        var group = getGroup();

        if (group) {
            group.broadcastPacket(randomRoll, false);
        } else {
            sendPacket(randomRoll);
        }

        return roll;
    }

    public final boolean isVisibleGloballyFor(Player u) {
        if (u == null) {
            return false;
        }

        // Always can see self
        if (Objects.equals(u.getGUID(), getGUID())) {
            return true;
        }

        // Visible units, always are visible for all players
        if (isVisible()) {
            return true;
        }

        // GMs are visible for higher gms (or players are visible for gms)
        if (!global.getAccountMgr().isPlayerAccount(u.getSession().getSecurity())) {
            return getSession().getSecurity().getValue() <= u.getSession().getSecurity().getValue();
        }

        // non faction visibility non-breakable for non-GMs
        return false;
    }

    public final float getReputationPriceDiscount(Creature creature) {
        return getReputationPriceDiscount(creature.getFactionTemplateEntry());
    }

    public final float getReputationPriceDiscount(FactionTemplateRecord factionTemplate) {
        if (factionTemplate == null || factionTemplate.faction == 0) {
            return 1.0f;
        }

        var rank = getReputationRank(factionTemplate.faction);

        if (rank.getValue() <= ReputationRank.Neutral.getValue()) {
            return 1.0f;
        }

        return 1.0f - 0.05f * (rank - ReputationRank.Neutral);
    }

    public final boolean isSpellFitByClassAndRace(int spell_id) {
        var racemask = SharedConst.GetMaskForRace(getRace());
        var classmask = getClassMask();

        var bounds = global.getSpellMgr().getSkillLineAbilityMapBounds(spell_id);

        if (bounds.isEmpty()) {
            return true;
        }

        for (var _spell_idx : bounds) {
            // skip wrong race skills
            if (_spell_idx.raceMask != 0 && (_spell_idx.raceMask & racemask) == 0) {
                continue;
            }

            // skip wrong class skills
            if (_spell_idx.ClassMask != 0 && (_spell_idx.ClassMask & classmask) == 0) {
                continue;
            }

            // skip wrong class and race skill saved in SkillRaceClassInfo.dbc
            if (global.getDB2Mgr().GetSkillRaceClassInfo(_spell_idx.skillLine, getRace(), getClass()) == null) {
                continue;
            }

            return true;
        }

        return false;
    }

    public final boolean haveAtClient(GenericObject object) {
        return Objects.equals(object.getGUID(), this.getGUID())
                || getClientGuiDs().contains(object.getGUID());
    }

    public final boolean hasTitle(CharTitlesRecord title) {
        return hasTitle(title.MaskID);
    }

    public final boolean hasTitle(int bitIndex) {
        var fieldIndexOffset = bitIndex / 64;

        if (fieldIndexOffset >= getActivePlayerData().knownTitles.size()) {
            return false;
        }

        var flag = 1 << (bitIndex % 64);

        return (getActivePlayerData().knownTitles.get((int) fieldIndexOffset) & flag) != 0;
    }

    public final void setTitle(CharTitlesRecord title) {
        setTitle(title, false);
    }

    public final void setTitle(CharTitlesRecord title, boolean lost) {
        var fieldIndexOffset = (title.MaskID / 64);
        var flag = 1 << (title.MaskID % 64);

        if (lost) {
            if (!hasTitle(title)) {
                return;
            }

            removeUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().knownTitles, fieldIndexOffset), flag);
        } else {
            if (hasTitle(title)) {
                return;
            }

            setUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().knownTitles, fieldIndexOffset), flag);
        }

        TitleEarned packet = new TitleEarned(lost ? ServerOpcode.TitleLost : ServerOpcode.TitleEarned);
        packet.index = title.MaskID;
        sendPacket(packet);
    }

    public final void setChosenTitle(int title) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().playerTitle), title);
    }

    public final void setKnownTitles(int index, long mask) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().knownTitles, index), mask);
    }

    public final void setViewpoint(WorldObject target, boolean apply) {
        if (apply) {
            Logs.MAPS.debug("Player.CreateViewpoint: Player {0} create seer {1} (TypeId: {2}).", getName(), target.getEntry(), target.getTypeId());

            if (getActivePlayerData().farsightObject != ObjectGuid.Empty) {
                Log.outFatal(LogFilter.player, "Player.CreateViewpoint: Player {0} cannot add new viewpoint!", getName());

                return;
            }

            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().farsightObject), target.getGUID());

            // farsight dynobj or puppet may be very far away
            updateVisibilityOf(target);

            if (target.isType(TypeMask.unit) && target != getVehicleBase()) {
                target.toUnit().addPlayerToVision(this);
            }

            setSeer(target);
        } else {
            Logs.MAPS.debug("Player.CreateViewpoint: Player {0} remove seer", getName());

            if (target.getGUID() != getActivePlayerData().farsightObject) {
                Log.outFatal(LogFilter.player, "Player.CreateViewpoint: Player {0} cannot remove current viewpoint!", getName());

                return;
            }

            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().farsightObject), ObjectGuid.Empty);

            if (target.isType(TypeMask.unit) && target != getVehicleBase()) {
                target.toUnit().removePlayerFromVision(this);
            }

            //must immediately set seer back otherwise may crash
            setSeer(this);
        }
    }

    public final void setClientControl(Unit target, boolean allowMove) {
        // don't allow possession to be overridden
        if (target.hasUnitState(UnitState.Charmed) && (ObjectGuid.opNotEquals(getGUID(), target.getCharmerGUID()))) {
            // this should never happen, otherwise m_unitBeingMoved might be left dangling!
            Log.outError(LogFilter.player, String.format("Player '%1$s' attempt to client control '%2$s', which is charmed by GUID %3$s", getName(), target.getName(), target.getCharmerGUID()));

            return;
        }

        // still affected by some aura that shouldn't allow control, only allow on last such aura to be removed
        if (target.hasUnitState(UnitState.Fleeing.getValue() | UnitState.Confused.getValue())) {
            allowMove = false;
        }

        ControlUpdate packet = new ControlUpdate();
        packet.guid = target.getGUID();
        packet.on = allowMove;
        sendPacket(packet);

        var viewpoint = getViewpoint();

        if (viewpoint == null) {
            viewpoint = this;
        }

        if (target != viewpoint) {
            if (viewpoint != this) {
                setViewpoint(viewpoint, false);
            }

            if (target != this) {
                setViewpoint(target, true);
            }
        }

        setMovedUnit(target);
    }

    public final Item getWeaponForAttack(WeaponAttackType attackType) {
        return getWeaponForAttack(attackType, false);
    }

    public final Item getWeaponForAttack(WeaponAttackType attackType, boolean useable) {
        byte slot;

        switch (attackType) {
            case BaseAttack:
                slot = EquipmentSlot.MainHand;

                break;
            case OffAttack:
                slot = EquipmentSlot.OffHand;

                break;
            case RangedAttack:
                slot = EquipmentSlot.MainHand;

                break;
            default:
                return null;
        }

        Item item;

        if (useable) {
            item = getUseableItemByPos(InventorySlots.Bag0, slot);
        } else {
            item = getItemByPos(InventorySlots.Bag0, slot);
        }

        if (item == null || item.getTemplate().getClass() != itemClass.Weapon) {
            return null;
        }

        if ((attackType == WeaponAttackType.RangedAttack) != item.getTemplate().isRangedWeapon()) {
            return null;
        }

        if (!useable) {
            return item;
        }

        if (item.isBroken()) {
            return null;
        }

        return item;
    }

    public final void autoUnequipOffhandIfNeed() {
        autoUnequipOffhandIfNeed(false);
    }

    public final void autoUnequipOffhandIfNeed(boolean force) {
        var offItem = getItemByPos(InventorySlots.Bag0, EquipmentSlot.OffHand);

        if (offItem == null) {
            return;
        }

        var offtemplate = offItem.getTemplate();

        // unequip offhand weapon if player doesn't have dual wield anymore
        if (!canDualWield && ((offItem.getTemplate().getInventoryType() == inventoryType.WeaponOffhand && !offItem.getTemplate().hasFlag(ItemFlags3.AlwaysAllowDualWield)) || offItem.getTemplate().getInventoryType() == inventoryType.Weapon)) {
            force = true;
        }

        // need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
        if (!force && (canTitanGrip() || (offtemplate.getInventoryType() != inventoryType.Weapon2Hand && !isTwoHandUsed()))) {
            return;
        }

        ArrayList<ItemPosCount> off_dest = new ArrayList<>();
        var off_msg = canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, off_dest, offItem, false);

        if (off_msg == InventoryResult.Ok) {
            removeItem(InventorySlots.Bag0, EquipmentSlot.OffHand, true);
            storeItem(off_dest, offItem, true);
        } else {
            moveItemFromInventory(InventorySlots.Bag0, EquipmentSlot.OffHand, true);
            SQLTransaction trans = new SQLTransaction();
            offItem.deleteFromInventoryDB(trans); // deletes item from character's inventory
            offItem.saveToDB(trans); // recursive and not have transaction guard into self, item not in inventory and can be save standalone

            var subject = global.getObjectMgr().getCypherString(CypherStrings.NotEquippedItem);
            (new MailDraft(subject, "There were problems with equipping one or several items")).addItem(offItem).sendMailTo(trans, this, new MailSender(this, MailStationery.gm), MailCheckMask.Copied);

            DB.characters.CommitTransaction(trans);
        }
    }

    public final void setRestState(RestTypes type, PlayerRestState state) {
        var restInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().restInfo, type.getValue());
        setUpdateFieldValue(restInfo.modifyValue(restInfo.stateID), (byte) state.getValue());
    }

    public final void setRestThreshold(RestTypes type, int threshold) {
        var restInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().restInfo, type.getValue());
        setUpdateFieldValue(restInfo.modifyValue(restInfo.threshold), threshold);
    }

    public final boolean hasPlayerFlag(PlayerFlag flags) {
        return hasFlag(PLAYER_FLAGS, flags);
    }

    public final void setPlayerFlag(PlayerFlag flags) {
        setFlag(PLAYER_FLAGS, flags);
    }

    public final void removePlayerFlag(PlayerFlag flags) {
        removeFlag(PLAYER_FLAGS_EX, flags);
    }

    public final void replaceAllPlayerFlags(PlayerFlag flags) {
        toggleFlag(PLAYER_FLAGS, flags);
    }

    public final boolean hasPlayerFlagEx(PlayerFlagEx flags) {
        return hasFlag(PLAYER_FLAGS_EX, flags);
    }

    public final void setPlayerFlagEx(PlayerFlagEx flags) {
        setFlag(PLAYER_FLAGS_EX, flags);
    }

    public final void removePlayerFlagEx(PlayerFlagEx flags) {
        removeFlag(PLAYER_FLAGS_EX, flags);
    }

    public final void replaceAllPlayerFlagsEx(PlayerFlagEx flags) {
        toggleFlag(PLAYER_FLAGS_EX, flags);
    }

    public final void setAverageItemLevelTotal(float newItemLevel) {
        setFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL, newItemLevel);
    }

    public final void setAverageItemLevelEquipped(float newItemLevel) {
        setFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + 1, newItemLevel);
    }

    public final int getCustomizationChoice(int chrCustomizationOptionId) {
        var choiceIndex = getPlayerData().customizations.FindIndexIf(choice ->
        {
            return choice.chrCustomizationOptionID == chrCustomizationOptionId;
        });

        if (choiceIndex >= 0) {
            return getPlayerData().customizations.get(choiceIndex).chrCustomizationChoiceID;
        }

        return 0;
    }

    public final void setCustomizations(ArrayList<ChrCustomizationChoice> customizations) {
        setCustomizations(customizations, true);
    }

    public final void setCustomizations(ArrayList<ChrCustomizationChoice> customizations, boolean markChanged) {
        if (markChanged) {
            customizationsChanged = true;
        }

        clearDynamicUpdateFieldValues(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().customizations));

        for (var customization : customizations) {
            ChrCustomizationChoice newChoice = new ChrCustomizationChoice();
            newChoice.chrCustomizationOptionID = customization.chrCustomizationOptionID;
            newChoice.chrCustomizationChoiceID = customization.chrCustomizationChoiceID;
            addDynamicUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().customizations), newChoice);
        }
    }

    public final void setPvpTitle(byte pvpTitle) {
        setByteValue(PLAYER_BYTES_4, PLAYER_BYTES_4_OFFSET_PVP_TITLE, pvpTitle);
    }

    public final void setArenaFaction(byte arenaFaction) {
        setByteValue(PLAYER_BYTES_4, PLAYER_BYTES_4_OFFSET_ARENA_FACTION, arenaFaction);
    }

    public final void applyModFakeInebriation(int mod, boolean apply) {
        applyModInt32Value(PLAYER_FAKE_INEBRIATION, mod, apply);
    }

    public final void setVirtualPlayerRealm(int virtualRealmAddress) {
        setInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, virtualRealmAddress);
    }

    public final void setCurrentBattlePetBreedQuality(byte battlePetBreedQuality) {
        setByteValue(PLAYER_FIELD_CURRENT_BATTLE_PET_BREED_QUALITY, FIELD_BYTE_OFFSET_0, battlePetBreedQuality);
    }

    public final void addHeirloom(int itemId, int flags) {
        addDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOMS, itemId);
        addDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS, flags);
    }

    public final void setHeirloom(int slot, int itemId) {
        setDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOMS, slot, itemId);
    }

    public final void setHeirloomFlags(int slot, int flags) {
        setDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS, slot, flags);
    }

    public final void addToy(int itemId, int flags) {
        addDynamicValue(PLAYER_DYNAMIC_FIELD_TOYS, itemId);
    }

    public final void addTransmogBlock(int blockValue) {
        addDynamicValue(PLAYER_DYNAMIC_FIELD_TRANSMOG, blockValue);
    }

    public final void addTransmogFlag(int slot, int flag) {
        int currentMask = getDynamicValue(PLAYER_DYNAMIC_FIELD_TRANSMOG, slot);
        setDynamicValue(PLAYER_DYNAMIC_FIELD_TRANSMOG, slot, currentMask | flag);
    }

    public final void addConditionalTransmog(int itemModifiedAppearanceId) {
        addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().conditionalTransmog), itemModifiedAppearanceId);
    }

    public final void removeConditionalTransmog(int itemModifiedAppearanceId) {
        var index = getActivePlayerData().conditionalTransmog.FindIndex(itemModifiedAppearanceId);

        if (index >= 0) {
            removeDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().conditionalTransmog), index);
        }
    }

    public final void addIllusionBlock(int blockValue) {
        addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().transmogIllusions), blockValue);
    }

    public final void addIllusionFlag(int slot, int flag) {
        setUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().transmogIllusions, slot), flag);
    }

    public final void addSelfResSpell(int spellId) {
        addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().selfResSpells), spellId);
    }

    public final void removeSelfResSpell(int spellId) {
        var index = getActivePlayerData().selfResSpells.FindIndex(spellId);

        if (index >= 0) {
            removeDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().selfResSpells), index);
        }
    }

    public final void clearSelfResSpell() {
        clearDynamicUpdateFieldValues(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().selfResSpells));
    }

    public final void setTrackCreatureFlag(int flags) {
        setUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().trackCreatureMask), flags);
    }

    public final void removeTrackCreatureFlag(int flags) {
        removeUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().trackCreatureMask), flags);
    }

    public final void setVersatilityBonus(float value) {
        setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().versatilityBonus), value);
    }

    public final void applyModOverrideSpellPowerByAPPercent(float mod, boolean apply) {
        applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().overrideSpellPowerByAPPercent), mod, apply);
    }

    public final void applyModOverrideAPBySpellPowerPercent(float mod, boolean apply) {
        applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().overrideAPBySpellPowerPercent), mod, apply);
    }

    public final boolean hasPlayerLocalFlag(PlayerLocalFlags flags) {
        return (getActivePlayerData().localFlags & flags.getValue()) != 0;
    }

    public final void setPlayerLocalFlag(PlayerLocalFlags flags) {
        setUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().localFlags), (int) flags.getValue());
    }

    public final void removePlayerLocalFlag(PlayerLocalFlags flags) {
        removeUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().localFlags), (int) flags.getValue());
    }

    public final void replaceAllPlayerLocalFlags(PlayerLocalFlags flags) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().localFlags), (int) flags.getValue());
    }

    public final void setWatchedFactionIndex(int index) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().watchedFactionIndex), index);
    }

    public final void addAuraVision(PlayerFieldByte2Flags flags) {
        setUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().auraVision), (byte) flags.getValue());
    }

    public final void removeAuraVision(PlayerFieldByte2Flags flags) {
        removeUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().auraVision), (byte) flags.getValue());
    }

    public final void setTransportServerTime(int transportServerTime) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().transportServerTime), transportServerTime);
    }

    public final void sendAttackSwingCancelAttack() {
        sendPacket(new CancelCombat());
    }

    public final void sendAttackSwingNotInRange() {
        sendPacket(new AttackSwingError(AttackSwingErr.NotInRange));
    }

    public final void sendAutoRepeatCancel(Unit target) {
        CancelAutoRepeat cancelAutoRepeat = new CancelAutoRepeat();
        cancelAutoRepeat.guid = target.getGUID(); // may be it's target guid
        sendMessageToSet(cancelAutoRepeat, true);
    }

    @Override
    public void buildCreateUpdateBlockForPlayer(UpdateData data, Player target) {
        if (target == this) {
            for (var i = EquipmentSlot.start; i < InventorySlots.BankBagEnd; ++i) {
                if (_items[i] == null) {
                    continue;
                }

                _items[i].buildCreateUpdateBlockForPlayer(data, target);
            }

            for (var i = InventorySlots.ReagentStart; i < InventorySlots.ChildEquipmentEnd; ++i) {
                if (_items[i] == null) {
                    continue;
                }

                _items[i].buildCreateUpdateBlockForPlayer(data, target);
            }
        }

        super.buildCreateUpdateBlockForPlayer(data, target);
    }

    @Override
    public UpdateFieldFlag getUpdateFieldFlagsFor(Player target) {
        var flags = super.getUpdateFieldFlagsFor(target);

        if (isInSameRaidWith(target)) {
            flags = UpdateFieldFlag.forValue(flags.getValue() | UpdateFieldFlag.PartyMember.getValue());
        }

        return flags;
    }

    @Override
    public void buildValuesCreate(WorldPacket data, Player target) {
        var flags = getUpdateFieldFlagsFor(target);
        WorldPacket buffer = new WorldPacket();

        buffer.writeInt8((byte) flags.getValue());
        getObjectData().writeCreate(buffer, flags, this, target);
        getUnitData().writeCreate(buffer, flags, this, target);
        getPlayerData().writeCreate(buffer, flags, this, target);

        if (target == this) {
            getActivePlayerData().writeCreate(buffer, flags, this, target);
        }

        data.writeInt32(buffer.getSize());
        data.writeBytes(buffer);
    }

    @Override
    public void buildValuesUpdate(WorldPacket data, Player target) {
        var flags = getUpdateFieldFlagsFor(target);
        WorldPacket buffer = new WorldPacket();

        buffer.writeInt32(getValues().getChangedObjectTypeMask() & ~((target != this ? 1 : 0) << getTypeId().getValue().activePlayer.getValue()));

        if (getValues().hasChanged(TypeId.object)) {
            getObjectData().writeUpdate(buffer, flags, this, target);
        }

        if (getValues().hasChanged(TypeId.UNIT)) {
            getUnitData().writeUpdate(buffer, flags, this, target);
        }

        if (getValues().hasChanged(TypeId.PLAYER)) {
            getPlayerData().writeUpdate(buffer, flags, this, target);
        }

        if (target == this && getValues().hasChanged(TypeId.activePlayer)) {
            getActivePlayerData().writeUpdate(buffer, flags, this, target);
        }

        data.writeInt32(buffer.getSize());
        data.writeBytes(buffer);
    }

    @Override
    public void buildValuesUpdateWithFlag(WorldPacket data, UpdateFieldFlag flags, Player target) {
        UpdateMask valuesMask = new UpdateMask(getTypeId().max.getValue());
        valuesMask.set(getTypeId().unit.getValue());
        valuesMask.set(getTypeId().player.getValue());

        WorldPacket buffer = new WorldPacket();

        UpdateMask mask = new UpdateMask(191);
        getUnitData().appendAllowedFieldsMaskForFlag(mask, flags);
        getUnitData().writeUpdate(buffer, mask, true, this, target);

        UpdateMask mask2 = new UpdateMask(161);
        getPlayerData().appendAllowedFieldsMaskForFlag(mask2, flags);
        getPlayerData().writeUpdate(buffer, mask2, true, this, target);

        data.writeInt32(buffer.getSize());
        data.writeInt32(valuesMask.getBlock(0));
        data.writeBytes(buffer);
    }

    @Override
    public void clearUpdateMask(boolean remove) {
        getValues().clearChangesMask(getPlayerData());
        getValues().clearChangesMask(getActivePlayerData());
        super.clearUpdateMask(remove);
    }

    //Helpers
    public final void addGossipItem(GossipOptionNpc optionNpc, String text, int sender, int action) {
        getPlayerTalkClass().getGossipMenu().addMenuItem(0, -1, optionNpc, text, 0, GossipOptionFlags.NONE, null, 0, 0, false, 0, "", null, null, sender, action);
    }


    public final void addGossipItem(GossipOptionNpc optionNpc, String text, int sender, int action, String popupText, int popupMoney, boolean coded) {
        getPlayerTalkClass().getGossipMenu().addMenuItem(0, -1, optionNpc, text, 0, GossipOptionFlags.NONE, null, 0, 0, coded, popupMoney, popupText, null, null, sender, action);
    }


    public final void addGossipItem(int gossipMenuID, int gossipMenuItemID, int sender, int action) {
        getPlayerTalkClass().getGossipMenu().addMenuItem(gossipMenuID, gossipMenuItemID, sender, action);
    }

    // This fuction Sends the current menu to show to client, a - NPCTEXTID(uint32), b - npc guid(uint64)
    public final void sendGossipMenu(int titleId, ObjectGuid objGUID) {
        getPlayerTalkClass().sendGossipMenu(titleId, objGUID);
    }

    // Closes the Menu
    public final void closeGossipMenu() {
        getPlayerTalkClass().sendCloseGossip();
    }


    public final void initGossipMenu(int menuId) {
        getPlayerTalkClass().getGossipMenu().setMenuId(menuId);
    }

    //Clears the Menu
    public final void clearGossipMenu() {
        getPlayerTalkClass().clearMenus();
    }

    public final void setCovenant(byte covenantId) {
        // General Additions
        if (getQuestStatus(CovenantQuests.ChoosingYourPurpose_fromOribos) == QuestStatus.INCOMPLETE) {
            completeQuest(CovenantQuests.ChoosingYourPurpose_fromOribos);
        }

        if (getQuestStatus(CovenantQuests.ChoosingYourPurpose_fromNathria) == QuestStatus.INCOMPLETE) {
            completeQuest(CovenantQuests.ChoosingYourPurpose_fromNathria);
        }

        castSpell(this, CovenantSpells.Remove_TBYB_Auras, true);
        castSpell(this, CovenantSpells.Create_Covenant_Garrison, true);
        castSpell(this, CovenantSpells.Start_Oribos_Intro_Quests, true);
        castSpell(this, CovenantSpells.Create_Garrison_Artifact_296, true);
        castSpell(this, CovenantSpells.Create_Garrison_Artifact_299, true);

        // Specific Additions
        switch (covenantId) {
            case Covenant.Kyrian:
                castSpell(this, CovenantSpells.Become_A_Kyrian, true);
                learnSpell(CovenantSpells.CA_Opening_Kyrian, true);
                learnSpell(CovenantSpells.CA_Kyrian, true);

                break;
            case Covenant.Venthyr:
                castSpell(this, CovenantSpells.Become_A_Venthyr, true);
                learnSpell(CovenantSpells.CA_Opening_Venthyr, true);
                learnSpell(CovenantSpells.CA_Venthyr, true);

                break;
            case Covenant.NightFae:
                castSpell(this, CovenantSpells.Become_A_NightFae, true);
                learnSpell(CovenantSpells.CA_Opening_NightFae, true);
                learnSpell(CovenantSpells.CA_NightFae, true);

                break;
            case Covenant.Necrolord:
                castSpell(this, CovenantSpells.Become_A_Necrolord, true);
                learnSpell(CovenantSpells.CA_Opening_Necrolord, true);
                learnSpell(CovenantSpells.CA_Necrolord, true);

                break;
        }

        // TODO
        // Save to DB
        //ObjectGuid guid = getGUID();
        //var stmt = DB.character.GetPreparedStatement(CHAR_UPD_COVENANT);
        //stmt.AddValue(0, covenantId);
        //stmt.AddValue(1, guid.GetCounter());
        //CharacterDatabase.execute(stmt);

        // UpdateField
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().covenantID), covenantId);
    }

    private void applyCustomConfigs() {
        // Adds the extra bag slots for having an authenticator.
        if (ConfigMgr.GetDefaultValue("player.enableExtaBagSlots", false) && !hasPlayerLocalFlag(PlayerLocalFlags.AccountSecured)) {
            setPlayerLocalFlag(PlayerLocalFlags.AccountSecured);
        }

        if (ConfigMgr.GetDefaultValue("player.addHearthstoneToCollection", false)) {
            getSession().getCollectionMgr().addToy(193588, true, true);
        }

        T chatChannel;
        tangible.OutObject<T> tempOut_chatChannel = new tangible.OutObject<T>();
        if (ConfigMgr.TryGetIfNotDefaultValue("AutoJoinChatChannel", "", tempOut_chatChannel)) {
            chatChannel = tempOut_chatChannel.outArgValue;
            var channelMgr = ChannelManager.forTeam(getTeam());

            var channel = channelMgr.getCustomChannel(chatChannel);

            if (channel != null) {
                channel.joinChannel(this);
            } else {
                channel = channelMgr.createCustomChannel(chatChannel);

                if (channel != null) {
                    channel.joinChannel(this);
                }
            }
        } else {
            chatChannel = tempOut_chatChannel.outArgValue;
        }
    }

    private void scheduleDelayedOperation(PlayerDelayedOperations operation) {
        if (operation.getValue() < PlayerDelayedOperations.End.getValue()) {
            delayedOperations = PlayerDelayedOperations.forValue(delayedOperations.getValue() | operation.getValue());
        }
    }

    private void deleteGarrison() {
        if (garrison != null) {
            garrison.delete();
            garrison = null;
        }
    }

    //Currency
    private void setCreateCurrency(CurrencyTypes id, int amount) {
        setCreateCurrency((int) id.getValue(), amount);
    }


    private void setCreateCurrency(int id, int amount) {
        if (!currencyStorage.containsKey(id)) {
            PlayerCurrency playerCurrency = new PlayerCurrency();
            playerCurrency.setState(PlayerCurrencyState.New);
            playerCurrency.setQuantity(amount);
            currencyStorage.put(id, playerCurrency);
        }
    }


    private int getCurrencyIncreasedCapQuantity(int id) {
        var playerCurrency = currencyStorage.get(id);

        if (playerCurrency == null) {
            return 0;
        }

        return playerCurrency.increasedCapQuantity;
    }


    private int getCurrencyWeeklyCap(int id) {
        var currency = CliDB.CurrencyTypesStorage.get(id);

        if (currency == null) {
            return 0;
        }

        return getCurrencyWeeklyCap(currency);
    }
	private final MultiMap<(


    private int getCurrencyWeeklyCap(CurrencyTypesRecord currency) {
        // TODO: CurrencyTypeFlags::ComputedWeeklyMaximum
        return currency.MaxEarnablePerWeek;
    },

    private boolean isActionButtonDataValid(byte button, long action, int type) {
        if (button >= PlayerConst.MaxActionButtons) {
            Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Action %1$s not added into button %2$s for player %3$s (%4$s): button must be < %5$s", action, button, getName(), getGUID(), PlayerConst.MaxActionButtons));

            return false;
        }

        if (action >= PlayerConst.MaxActionButtonActionValue) {
            Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Action %1$s not added into button %2$s for player %3$s (%4$s): action must be < %5$s", action, button, getName(), getGUID(), PlayerConst.MaxActionButtonActionValue));

            return false;
        }

        switch (ActionButtonType.forValue(type)) {
            case Spell:
                if (!global.getSpellMgr().hasSpellInfo((int) action, Difficulty.NONE)) {
                    Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Spell action %1$s not added into button %2$s for player %3$s (%4$s): spell not exist", action, button, getName(), getGUID()));

                    return false;
                }

                break;
            case Item:
                if (global.getObjectMgr().getItemTemplate((int) action) == null) {
                    Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Item action %1$s not added into button %2$s for player %3$s (%4$s): item not exist", action, button, getName(), getGUID()));

                    return false;
                }

                break;
            case Companion: {
                if (getSession().getBattlePetMgr().getPet(ObjectGuid.create(HighGuid.BattlePet, action)) == null) {
                    Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Companion action %1$s not added into button %2$s for player %3$s (%4$s): companion does not exist", action, button, getName(), getGUID()));

                    return false;
                }

                break;
            }
            case Mount:
                var mount = CliDB.MountStorage.get(action);

                if (mount == null) {
                    Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Mount action %1$s not added into button %2$s for player %3$s (%4$s): mount does not exist", action, button, getName(), getGUID()));

                    return false;
                }

                if (!hasSpell(mount.sourceSpellID)) {
                    Log.outError(LogFilter.player, String.format("Player::IsActionButtonDataValid: Mount action %1$s not added into button %2$s for player %3$s (%4$s): Player does not know this mount", action, button, getName(), getGUID()));

                    return false;
                }

                break;
            case C:
            case CMacro:
            case Macro:
            case Eqset:
                break;
            default:
                Log.outError(LogFilter.player, String.format("Unknown action type %1$s", type));

                return false; // other cases not checked at this moment
        }

        return true;
    }),QuestObjectiveStatusData>_questObjectiveStatus =new MultiMap<(

    private void sendInitialActionButtons() {
        sendActionButtons(0);
    },

    private void sendActionButtons(int state) {
        UpdateActionButtons packet = new UpdateActionButtons();

        for (var pair : actionButtons.entrySet()) {
            if (pair.getValue().UState != ActionButtonUpdateState.Deleted && pair.getKey() < packet.actionButtons.length) {
                packet.ActionButtons[pair.getKey()] = pair.getValue().packedData;
            }
        }

        packet.reason = (byte) state;
        sendPacket(packet);
    }),QuestObjectiveStatusData>();

    // Calculate how many reputation points player gain with the quest
    private void rewardReputation(Quest quest) {
        for (byte i = 0; i < SharedConst.QuestRewardReputationsCount; ++i) {
            if (quest.RewardFactionId[i] == 0) {
                continue;
            }

            var factionEntry = CliDB.FactionStorage.get(quest.RewardFactionId[i]);

            if (factionEntry == null) {
                continue;
            }

            var rep = 0;
            var noQuestBonus = false;

            if (quest.RewardFactionOverride[i] != 0) {
                rep = quest.RewardFactionOverride[i] / 100;
                noQuestBonus = true;
            } else {
                var row = ((quest.RewardFactionValue[i] < 0) ? 1 : 0) + 1;
                var questFactionRewEntry = CliDB.QuestFactionRewardStorage.get(row);

                if (questFactionRewEntry != null) {
                    var field = Math.abs(quest.RewardFactionValue[i]);
                    rep = questFactionRewEntry.Difficulty[field];
                }
            }

            if (rep == 0) {
                continue;
            }

            if (quest.RewardFactionCapIn[i] != 0 && rep > 0 && getReputationMgr().getRank(factionEntry).getValue() >= quest.RewardFactionCapIn[i]) {
                continue;
            }

            if (quest.isDaily()) {
                rep = calculateReputationGain(ReputationSource.DailyQuest, (int) getQuestLevel(quest), rep, (int) quest.RewardFactionId[i], noQuestBonus);
            } else if (quest.isWeekly()) {
                rep = calculateReputationGain(ReputationSource.WeeklyQuest, (int) getQuestLevel(quest), rep, (int) quest.RewardFactionId[i], noQuestBonus);
            } else if (quest.isMonthly()) {
                rep = calculateReputationGain(ReputationSource.MonthlyQuest, (int) getQuestLevel(quest), rep, (int) quest.RewardFactionId[i], noQuestBonus);
            } else if (quest.isRepeatable()) {
                rep = calculateReputationGain(ReputationSource.RepeatableQuest, (int) getQuestLevel(quest), rep, (int) quest.RewardFactionId[i], noQuestBonus);
            } else {
                rep = calculateReputationGain(ReputationSource.Quest, (int) getQuestLevel(quest), rep, (int) quest.RewardFactionId[i], noQuestBonus);
            }

            var noSpillover = (boolean) (quest.rewardReputationMask & (1 << i));
            getReputationMgr().modifyReputation(factionEntry, rep, false, noSpillover);
        }
    }

    private void setDelayedTeleportFlag(boolean setting) {
        hasDelayedTeleport = setting;
    }

    private void updateLocalChannels(int newZone) {
        if (getSession().getPlayerLoading() && !isBeingTeleportedFar()) {
            return; // The client handles it automatically after loading, but not after teleporting
        }

        var current_zone = CliDB.AreaTableStorage.get(newZone);

        if (current_zone == null) {
            return;
        }

        var cMgr = ChannelManager.forTeam(getTeam());

        if (cMgr == null) {
            return;
        }

        for (var channelEntry : CliDB.ChatChannelsStorage.values()) {
            if (!channelEntry.flags.hasFlag(ChannelDBCFlags.initial)) {
                continue;
            }

            Channel usedChannel = null;

            for (var channel : channels) {
                if (channel.getChannelId() == channelEntry.id) {
                    usedChannel = channel;

                    break;
                }
            }

            Channel removeChannel = null;
            Channel joinChannel = null;
            var sendRemove = true;

            if (canJoinConstantChannelInZone(channelEntry, current_zone)) {
                if (!channelEntry.flags.hasFlag(ChannelDBCFlags.global)) {
                    if (channelEntry.flags.hasFlag(ChannelDBCFlags.CityOnly) && usedChannel != null) {
                        continue; // Already on the channel, as city channel names are not changing
                    }

                    joinChannel = cMgr.getSystemChannel(channelEntry.id, current_zone);

                    if (usedChannel != null) {
                        if (joinChannel != usedChannel) {
                            removeChannel = usedChannel;
                            sendRemove = false; // Do not send leave channel, it already replaced at client
                        } else {
                            joinChannel = null;
                        }
                    }
                } else {
                    joinChannel = cMgr.getSystemChannel(channelEntry.id);
                }
            } else {
                removeChannel = usedChannel;
            }

            if (joinChannel != null) {
                joinChannel.joinChannel(this); // Changed Channel: ... or Joined Channel: ...
            }

            if (removeChannel != null) {
                removeChannel.leaveChannel(this, sendRemove, true); // Leave old channel

                leftChannel(removeChannel); // Remove from player's channel list
                cMgr.leftChannel(removeChannel.getChannelId(), removeChannel.getZoneEntry()); // Delete if empty
            }
        }
    }

    private void sendNewMail() {
        sendPacket(new NotifyReceivedMail());
    }

    private void updateHomebindTime(int time) {
        // GMs never get homebind timer online
        if (getInstanceValid() || isGameMaster()) {
            if (homebindTimer != 0) // instance valid, but timer not reset
            {
                sendRaidGroupOnlyMessage(RaidGroupReason.NONE, 0);
            }

            // instance is valid, reset homebind timer
            homebindTimer = 0;
        } else if (homebindTimer > 0) {
            if (time >= homebindTimer) {
                // teleport to nearest graveyard
                repopAtGraveyard();
            } else {
                _homebindTimer -= time;
            }
        } else {
            // instance is invalid, start homebind timer
            homebindTimer = 60000;
            // send message to player
            sendRaidGroupOnlyMessage(RaidGroupReason.RequirementsUnmatch, (int) homebindTimer);
            Logs.MAPS.debug("PLAYER: Player '{0}' (GUID: {1}) will be teleported to homebind in 60 seconds", getName(), getGUID().toString());
        }
    }

    private void sendInitWorldStates(int zoneId, int areaId) {
        // data depends on zoneid/mapid...
        var mapid = getLocation().getMapId();

        InitWorldStates packet = new InitWorldStates();
        packet.mapID = mapid;
        packet.areaID = zoneId;
        packet.subareaID = areaId;

        global.getWorldStateMgr().fillInitialWorldStates(packet, getMap(), areaId);

        sendPacket(packet);
    }

    private int getChampioningFaction() {
        return championingFaction;
    }

    public final void setChampioningFaction(int faction) {
        championingFaction = faction;
    }

    private void resurrectUsingRequestDataImpl() {
        // save health and mana before resurrecting, _resurrectionData can be erased
        var resurrectHealth = resurrectionData.getHealth();
        var resurrectMana = resurrectionData.getMana();
        var resurrectAura = resurrectionData.getAura();
        var resurrectGUID = resurrectionData.getGuid();

        resurrectPlayer(0.0f, false);

        setHealth(resurrectHealth);
        setPower(powerType.mana, (int) resurrectMana);

        setPower(powerType.Rage, 0);
        setFullPower(powerType.Energy);
        setFullPower(powerType.Focus);
        setPower(powerType.LunarPower, 0);

        if (resurrectAura != 0) {
            castSpell(this, resurrectAura, (new CastSpellExtraArgs(TriggerCastFlags.FullMask)).setOriginalCaster(resurrectGUID));
        }

        spawnCorpseBones();
    }

    private void regenerateAll() {
        regenTimerCount += getRegenTimer();
        foodEmoteTimerCount += getRegenTimer();

        for (var power = powerType.mana; power.getValue() < powerType.max.getValue(); power++) // = power + 1)
        {
            if (power != powerType.runes) {
                regenerate(power);
            }
        }

        // Runes act as cooldowns, and they don't need to send any data
        if (getClass() == playerClass.Deathknight) {
            int regeneratedRunes = 0;
            var regenIndex = 0;

            while (regeneratedRunes < PlayerConst.MaxRechargingRunes && runes.getCooldownOrder().size() > regenIndex) {
                var runeToRegen = runes.getCooldownOrder().get(regenIndex);
                var runeCooldown = getRuneCooldown(runeToRegen);

                if (runeCooldown > getRegenTimer()) {
                    setRuneCooldown(runeToRegen, runeCooldown - getRegenTimer());
                    ++regenIndex;
                } else {
                    setRuneCooldown(runeToRegen, 0);
                }

                ++regeneratedRunes;
            }
        }

        if (regenTimerCount >= 2000) {
            // Not in combat or they have regeneration
            if (!isInCombat() || isPolymorphed() || baseHealthRegen != 0 || hasAuraType(AuraType.ModRegenDuringCombat) || hasAuraType(AuraType.ModHealthRegenInCombat)) {
                regenerateHealth();
            }

            _regenTimerCount -= 2000;
        }

        setRegenTimer(0);

        // Handles the emotes for drinking and eating.
        // According to sniffs there is a background timer going on that repeats independed from the time window where the aura applies.
        // That's why we dont need to reset the timer on apply. In sniffs I have seen that the first call for the spell visual is totally random, then after
        // 5 seconds over and over again which confirms my theory that we have a independed timer.
        if (foodEmoteTimerCount >= 5000) {
            var auraList = getAuraEffectsByType(AuraType.ModRegen);
            auraList.addAll(getAuraEffectsByType(AuraType.ModPowerRegen));

            for (var auraEffect : auraList) {
                // Food emote comes above drinking emote if we have to decide (mage regen food for example)
                if (auraEffect.getBase().hasEffectType(AuraType.ModRegen) && auraEffect.getSpellInfo().hasAuraInterruptFlag(SpellAuraInterruptFlags.standing)) {
                    sendPlaySpellVisualKit(SpellConst.VisualKitFood, 0, 0);

                    break;
                } else if (auraEffect.getBase().hasEffectType(AuraType.ModPowerRegen) && auraEffect.getSpellInfo().hasAuraInterruptFlag(SpellAuraInterruptFlags.standing)) {
                    sendPlaySpellVisualKit(SpellConst.VisualKitDrink, 0, 0);

                    break;
                }
            }

            _foodEmoteTimerCount -= 5000;
        }
    }

    private void regenerate(Power power) {
        // Skip regeneration for power type we cannot have
        var powerIndex = getPowerIndex(power);

        if (powerIndex == powerType.max.getValue() || powerIndex >= powerType.MaxPerClass.getValue()) {
            return;
        }

        // @todo possible use of miscvalueb instead of amount
        if (hasAuraTypeWithValue(AuraType.PreventRegeneratePower, power.getValue())) {
            return;
        }

        var curValue = getPower(power);

        // TODO: updating haste should update UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER for certain power types
        var powerType = global.getDB2Mgr().GetPowerTypeEntry(power);

        if (powerType == null) {
            return;
        }

        double addvalue;

        if (!isInCombat()) {
            if (powerType.RegenInterruptTimeMS != 0 && time.GetMSTimeDiffToNow(combatExitTime) < powerType.RegenInterruptTimeMS) {
                return;
            }

            addvalue = (powerType.RegenPeace + getUnitData().powerRegenFlatModifier.get(powerIndex)) * 0.001f * getRegenTimer();
        } else {
            addvalue = (powerType.RegenCombat + getUnitData().powerRegenInterruptedFlatModifier.get(powerIndex)) * 0.001f * getRegenTimer();
        }

        WorldCfg[] RatesForPower = {WorldCfg.RatePowerMana, WorldCfg.RatePowerRageLoss, WorldCfg.RatePowerFocus, WorldCfg.RatePowerEnergy, WorldCfg.RatePowerComboPointsLoss, 0, WorldCfg.RatePowerRunicPowerLoss, WorldCfg.RatePowerSoulShards, WorldCfg.RatePowerLunarPower, WorldCfg.RatePowerHolyPower, 0, WorldCfg.RatePowerMaelstrom, WorldCfg.RatePowerChi, WorldCfg.RatePowerInsanity, 0, 0, WorldCfg.RatePowerArcaneCharges, WorldCfg.RatePowerFury, WorldCfg.RatePowerPain, 0};

        if (RatesForPower[power.getValue()] != 0) {
            addvalue *= WorldConfig.getFloatValue(RatesForPower[power.getValue()]);
        }

        // Mana regen calculated in player.updateManaRegen()
        if (power != powerType.mana) {
            addvalue *= getTotalAuraMultiplierByMiscValue(AuraType.ModPowerRegenPercent, power.getValue());
            addvalue += getTotalAuraModifierByMiscValue(AuraType.ModPowerRegen, power.getValue()) * ((power != powerType.Energy) ? _regenTimerCount : getRegenTimer()) / (5 * time.InMilliseconds);
        }

        var minPower = powerType.MinPower;
        var maxPower = getMaxPower(power);

        if (powerType.CenterPower != 0) {
            if (curValue > powerType.CenterPower) {
                addvalue = -Math.abs(addvalue);
                minPower = powerType.CenterPower;
            } else if (curValue < powerType.CenterPower) {
                addvalue = Math.abs(addvalue);
                maxPower = powerType.CenterPower;
            } else {
                return;
            }
        }

        addvalue += _powerFraction[powerIndex];
        var integerValue = (int) Math.abs(addvalue);

        var forcesSetPower = false;

        if (addvalue < 0.0f) {
            if (curValue <= minPower) {
                return;
            }
        } else if (addvalue > 0.0f) {
            if (curValue >= maxPower) {
                return;
            }
        } else {
            return;
        }

        if (addvalue < 0.0f) {
            if (curValue > minPower + integerValue) {
                curValue -= integerValue;
                _powerFraction[powerIndex] = addvalue + integerValue;
            } else {
                curValue = minPower;
                _powerFraction[powerIndex] = 0;
                forcesSetPower = true;
            }
        } else {
            if (curValue + integerValue <= maxPower) {
                curValue += integerValue;
                _powerFraction[powerIndex] = addvalue - integerValue;
            } else {
                curValue = maxPower;
                _powerFraction[powerIndex] = 0;
                forcesSetPower = true;
            }
        }

        if (getCommandStatus(PlayerCommandStates.power)) {
            curValue = maxPower;
        }

        if (regenTimerCount >= 2000 || forcesSetPower) {
            setPower(power, curValue, true, true);
        } else {
            // throttle packet sending
            doWithSuppressingObjectUpdates(() ->
            {
                setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().power, (int) powerIndex), curValue);
                getUnitData().clearChanged(getUnitData().power, powerIndex);
            });
        }
    }

    private void regenerateHealth() {
        var curValue = getHealth();
        var maxValue = getMaxHealth();

        if (curValue >= maxValue) {
            return;
        }

        var HealthIncreaseRate = WorldConfig.getFloatValue(WorldCfg.RateHealth);
        double addValue = 0.0f;

        // polymorphed case
        if (isPolymorphed()) {
            addValue = getMaxHealth() / 3;
        }
        // normal regen case (maybe partly in combat case)
        else if (!isInCombat() || hasAuraType(AuraType.ModRegenDuringCombat)) {
            addValue = HealthIncreaseRate;

            if (!isInCombat()) {
                if (getLevel() < 15) {
                    addValue = (0.20f * (getMaxHealth()) / getLevel() * HealthIncreaseRate);
                } else {
                    addValue = 0.015f * (getMaxHealth()) * HealthIncreaseRate;
                }

                addValue *= getTotalAuraMultiplier(AuraType.ModHealthRegenPercent);
                addValue += getTotalAuraModifier(AuraType.ModRegen) * 2 * time.InMilliseconds / (5 * time.InMilliseconds);
            } else if (hasAuraType(AuraType.ModRegenDuringCombat)) {
                tangible.RefObject<Double> tempRef_addValue = new tangible.RefObject<Double>(addValue);
                MathUtil.ApplyPct(tempRef_addValue, getTotalAuraModifier(AuraType.ModRegenDuringCombat));
                addValue = tempRef_addValue.refArgValue;
            }

            if (!isStandState()) {
                addValue *= 1.5f;
            }
        }

        // always regeneration bonus (including combat)
        addValue += getTotalAuraModifier(AuraType.ModHealthRegenInCombat);
        addValue += _baseHealthRegen / 2.5f;

        if (addValue < 0) {
            addValue = 0;
        }

        modifyHealth(addValue);
    }

    private void leaveLFGChannel() {
        for (var i : channels) {
            if (i.isLFG()) {
                i.leaveChannel(this);

                break;
            }
        }
    }

    private boolean isImmuneToEnvironmentalDamage() {
        // check for GM and death state included in isAttackableByAOE
        return (!isTargetableForAttack(false));
    }

    private SpellSchoolMask getEnviormentDamageType(EnviromentalDamage dmgType) {
        switch (dmgType) {
            case Lava:
            case Fire:
                return spellSchoolMask.Fire;
            case Slime:
                return spellSchoolMask.Nature;
            default:
                return spellSchoolMask.NORMAL;
        }
    }


    private void handleDrowning(int time_diff) {
        if (mirrorTimerFlags == 0) {
            return;
        }

        var breathTimer = MirrorTimerType.Breath.getValue();
        var fatigueTimer = MirrorTimerType.Fatigue.getValue();
        var fireTimer = MirrorTimerType.Fire.getValue();

        // In water
        if (mirrorTimerFlags.hasFlag(PlayerUnderwaterState.InWater)) {
            // Breath timer not activated - activate it
            if (_mirrorTimer[breathTimer] == -1) {
                _mirrorTimer[breathTimer] = getMaxTimer(MirrorTimerType.Breath);
                sendMirrorTimer(MirrorTimerType.Breath, _mirrorTimer[breathTimer], _mirrorTimer[breathTimer], -1);
            } else // If activated - do tick
            {
                _mirrorTimer[breathTimer] -= time_diff;

                // Timer limit - need deal damage
                if (_mirrorTimer[breathTimer] < 0) {
                    _mirrorTimer[breathTimer] += 1 * time.InMilliseconds;
                    // Calculate and deal damage
                    // @todo Check this formula
                    var damage = (int) (getMaxHealth() / 5 + RandomUtil.URand(0, getLevel() - 1));
                    environmentalDamage(EnviromentalDamage.Drowning, damage);
                } else if (!mirrorTimerFlagsLast.hasFlag(PlayerUnderwaterState.InWater)) // Update time in client if need
                {
                    sendMirrorTimer(MirrorTimerType.Breath, getMaxTimer(MirrorTimerType.Breath), _mirrorTimer[breathTimer], -1);
                }
            }
        } else if (_mirrorTimer[breathTimer] != -1) // Regen timer
        {
            var UnderWaterTime = getMaxTimer(MirrorTimerType.Breath);
            // Need breath regen
            _mirrorTimer[breathTimer] += 10 * time_diff;

            if (_mirrorTimer[breathTimer] >= UnderWaterTime || !isAlive()) {
                stopMirrorTimer(MirrorTimerType.Breath);
            } else if (mirrorTimerFlagsLast.hasFlag(PlayerUnderwaterState.InWater)) {
                sendMirrorTimer(MirrorTimerType.Breath, UnderWaterTime, _mirrorTimer[breathTimer], 10);
            }
        }

        // In dark water
        if (mirrorTimerFlags.hasFlag(PlayerUnderwaterState.InDarkWater)) {
            // Fatigue timer not activated - activate it
            if (_mirrorTimer[fatigueTimer] == -1) {
                _mirrorTimer[fatigueTimer] = getMaxTimer(MirrorTimerType.Fatigue);
                sendMirrorTimer(MirrorTimerType.Fatigue, _mirrorTimer[fatigueTimer], _mirrorTimer[fatigueTimer], -1);
            } else {
                _mirrorTimer[fatigueTimer] -= time_diff;

                // Timer limit - need deal damage or teleport ghost to graveyard
                if (_mirrorTimer[fatigueTimer] < 0) {
                    _mirrorTimer[fatigueTimer] += 1 * time.InMilliseconds;

                    if (isAlive()) // Calculate and deal damage
                    {
                        var damage = (int) (getMaxHealth() / 5 + RandomUtil.URand(0, getLevel() - 1));
                        environmentalDamage(EnviromentalDamage.Exhausted, damage);
                    } else if (hasPlayerFlag(playerFlags.Ghost)) // Teleport ghost to graveyard
                    {
                        repopAtGraveyard();
                    }
                } else if (!mirrorTimerFlagsLast.hasFlag(PlayerUnderwaterState.InDarkWater)) {
                    sendMirrorTimer(MirrorTimerType.Fatigue, getMaxTimer(MirrorTimerType.Fatigue), _mirrorTimer[fatigueTimer], -1);
                }
            }
        } else if (_mirrorTimer[fatigueTimer] != -1) // Regen timer
        {
            var DarkWaterTime = getMaxTimer(MirrorTimerType.Fatigue);
            _mirrorTimer[fatigueTimer] += 10 * time_diff;

            if (_mirrorTimer[fatigueTimer] >= DarkWaterTime || !isAlive()) {
                stopMirrorTimer(MirrorTimerType.Fatigue);
            } else if (mirrorTimerFlagsLast.hasFlag(PlayerUnderwaterState.InDarkWater)) {
                sendMirrorTimer(MirrorTimerType.Fatigue, DarkWaterTime, _mirrorTimer[fatigueTimer], 10);
            }
        }

        if (mirrorTimerFlags.hasFlag(PlayerUnderwaterState.InLava) && !(getLastLiquid() != null && getLastLiquid().spellID != 0)) {
            // Breath timer not activated - activate it
            if (_mirrorTimer[fireTimer] == -1) {
                _mirrorTimer[fireTimer] = getMaxTimer(MirrorTimerType.Fire);
            } else {
                _mirrorTimer[fireTimer] -= time_diff;

                if (_mirrorTimer[fireTimer] < 0) {
                    _mirrorTimer[fireTimer] += 1 * time.InMilliseconds;
                    // Calculate and deal damage
                    // @todo Check this formula
                    var damage = RandomUtil.URand(600, 700);

                    if (mirrorTimerFlags.hasFlag(PlayerUnderwaterState.InLava)) {
                        environmentalDamage(EnviromentalDamage.Lava, damage);
                    }
                    // need to skip Slime damage in Undercity,
                    // maybe someone can find better way to handle environmental damage
                    //else if (m_zoneUpdateId != 1497)
                    //    environmentalDamage(DAMAGE_SLIME, damage);
                }
            }
        } else {
            _mirrorTimer[fireTimer] = -1;
        }

        // Recheck timers flag
        mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() & ~PlayerUnderwaterState.ExistTimers.getValue());

        for (byte i = 0; i < MirrorTimerType.max.getValue(); ++i) {
            if (_mirrorTimer[i] != -1) {
                mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() | PlayerUnderwaterState.ExistTimers.getValue());

                break;
            }
        }

        mirrorTimerFlagsLast = mirrorTimerFlags;
    }

    private void handleSobering() {
        drunkTimer = 0;

        var currentDrunkValue = getDrunkValue();
        var drunk = (byte) (currentDrunkValue != 0 ? --currentDrunkValue : 0);
        setDrunkValue(drunk);
    }

    private void sendMirrorTimer(MirrorTimerType type, int maxValue, int CurrentValue, int Regen) {
        if (maxValue == -1) {
            if (CurrentValue != -1) {
                stopMirrorTimer(type);
            }

            return;
        }

        sendPacket(new StartMirrorTimer(type, CurrentValue, maxValue, Regen, 0, false));
    }

    private void stopMirrorTimer(MirrorTimerType type) {
        _mirrorTimer[Type.getValue()] = -1;
        sendPacket(new stopMirrorTimer(type));
    }

    private int getMaxTimer(MirrorTimerType timer) {
        switch (timer) {
            case Fatigue:
                return time.Minute * time.InMilliseconds;
            case Breath: {
                if (!isAlive() || hasAuraType(AuraType.WaterBreathing) || getSession().getSecurity().getValue() >= AccountTypes.forValue(WorldConfig.getIntValue(WorldCfg.DisableBreathing))) {
                    return -1;
                }

                var UnderWaterTime = 3 * time.Minute * time.InMilliseconds;
                UnderWaterTime *= (int) getTotalAuraMultiplier(AuraType.ModWaterBreathing);

                return UnderWaterTime;
            }
            case Fire: {
                if (!isAlive()) {
                    return -1;
                }

                return 1 * time.InMilliseconds;
            }
            default:
                return 0;
        }
    }

    private Corpse createCorpse() {
        // prevent existence 2 corpse for player
        spawnCorpseBones();

        Corpse corpse = new Corpse((boolean) (extraFlags.getValue() & PlayerExtraFlags.PVPDeath.getValue()) ? CorpseType.ResurrectablePVP : CorpseType.ResurrectablePVE);
        setPvPDeath(false);

        if (!corpse.create(getMap().generateLowGuid(HighGuid.Corpse), this)) {
            return null;
        }

        corpseLocation = new worldLocation(getLocation());

        CorpseFlags flags = CorpseFlags.forValue(0);

        if (hasPvpFlag(UnitPVPStateFlags.pvP)) {
            flags = CorpseFlags.forValue(flags.getValue() | CorpseFlags.pvP.getValue());
        }

        if (getInBattleground() && !getInArena()) {
            flags = CorpseFlags.forValue(flags.getValue() | CorpseFlags.Skinnable.getValue()); // to be able to remove insignia
        }

        if (hasPvpFlag(UnitPVPStateFlags.FFAPvp)) {
            flags = CorpseFlags.forValue(flags.getValue() | CorpseFlags.FFAPvP.getValue());
        }

        corpse.setRace((byte) getRace().getValue());
        corpse.setSex((byte) getNativeGender().getValue());
        corpse.setClass((byte) getClass().getValue());
        corpse.setCustomizations(getPlayerData().customizations);
        corpse.replaceAllFlags(flags);
        corpse.setDisplayId(getNativeDisplayId());
        corpse.setFactionTemplate(CliDB.ChrRacesStorage.get(getRace()).factionID);

        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; i++) {
            if (_items[i] != null) {
                var itemDisplayId = _items[i].getDisplayId(this);
                int itemInventoryType;
                var itemEntry = CliDB.ItemStorage.get(_items[i].getVisibleEntry(this));

                if (itemEntry != null) {
                    itemInventoryType = (int) itemEntry.inventoryType;
                } else {
                    itemInventoryType = (int) _items[i].getTemplate().getInventoryType().getValue();
                }

                corpse.setItem(i, itemDisplayId | (itemInventoryType << 24));
            }
        }

        // register for player, but not show
        getMap().addCorpse(corpse);

        corpse.updatePositionData();
        corpse.setZoneScript();

        // we do not need to save corpses for instances
        if (!getMap().isInstanceable()) {
            corpse.saveToDB();
        }

        return corpse;
    }

    private void updateCorpseReclaimDelay() {
        var pvp = extraFlags.hasFlag(PlayerExtraFlags.PVPDeath);

        if ((pvp && !WorldConfig.getBoolValue(WorldCfg.DeathCorpseReclaimDelayPvp)) || (!pvp && !WorldConfig.getBoolValue(WorldCfg.DeathCorpseReclaimDelayPve))) {
            return;
        }

        var now = gameTime.GetGameTime();

        if (now < deathExpireTime) {
            // full and partly periods 1..3
            var count = (long) (_deathExpireTime - now) / PlayerConst.DeathExpireStep + 1;

            if (count < PlayerConst.MaxDeathCount) {
                deathExpireTime = now + (long) (count + 1) * PlayerConst.DeathExpireStep;
            } else {
                deathExpireTime = now + PlayerConst.MaxDeathCount * PlayerConst.DeathExpireStep;
            }
        } else {
            deathExpireTime = now + PlayerConst.DeathExpireStep;
        }
    }

    private int calculateCorpseReclaimDelay() {
        return calculateCorpseReclaimDelay(false);
    }

    private int calculateCorpseReclaimDelay(boolean load) {
        var corpse = getCorpse();

        if (load && !corpse) {
            return -1;
        }

        var pvp = corpse ? corpse.getCorpseType() == CorpseType.ResurrectablePVP : (extraFlags.getValue() & PlayerExtraFlags.PVPDeath.getValue()) != 0;

        int delay;

        if (load) {
            if (corpse.getGhostTime() > deathExpireTime) {
                return -1;
            }

            long count = 0;

            if ((pvp && WorldConfig.getBoolValue(WorldCfg.DeathCorpseReclaimDelayPvp)) || (!pvp && WorldConfig.getBoolValue(WorldCfg.DeathCorpseReclaimDelayPve))) {
                count = (long) (_deathExpireTime - corpse.getGhostTime()) / PlayerConst.DeathExpireStep;

                if (count >= PlayerConst.MaxDeathCount) {
                    count = PlayerConst.MaxDeathCount - 1;
                }
            }

            var expected_time = corpse.getGhostTime() + PlayerConst.copseReclaimDelay[count];
            var now = gameTime.GetGameTime();

            if (now >= expected_time) {
                return -1;
            }

            delay = expected_time - now;
        } else {
            delay = getCorpseReclaimDelay(pvp);
        }

        return (int) (delay * time.InMilliseconds);
    }

    private void sendCorpseReclaimDelay(int delay) {
        CorpseReclaimDelay packet = new CorpseReclaimDelay();
        packet.remaining = delay;
        sendPacket(packet);
    }

    private boolean isFriendlyArea(AreaTableRecord areaEntry) {
        var factionTemplate = getFactionTemplateEntry();

        if (factionTemplate == null) {
            return false;
        }

        return (factionTemplate.FriendGroup & areaEntry.FactionGroupMask) != 0;
    }

    private void setWarModeLocal(boolean enabled) {
        if (enabled) {
            setPlayerLocalFlag(PlayerLocalFlags.WarMode);
        } else {
            removePlayerLocalFlag(PlayerLocalFlags.WarMode);
        }
    }

    private void updateWarModeAuras() {
        int auraInside = 282559;
        var auraOutside = PlayerConst.WarmodeEnlistedSpellOutside;

        if (isWarModeDesired()) {
            if (canEnableWarModeInArea()) {
                removePlayerFlag(playerFlags.WarModeActive);
                castSpell(this, auraInside, true);
                removeAura(auraOutside);
            } else {
                setPlayerFlag(playerFlags.WarModeActive);
                castSpell(this, auraOutside, true);
                removeAura(auraInside);
            }

            setWarModeLocal(true);
            setPvpFlag(UnitPVPStateFlags.pvP);
        } else {
            setWarModeLocal(false);
            removeAura(auraOutside);
            removeAura(auraInside);
            removePlayerFlag(playerFlags.WarModeActive);
            removePvpFlag(UnitPVPStateFlags.pvP);
        }
    }


    private void setWeaponChangeTimer(int time) {
        weaponChangeTimer = time;
    }

    private void sendAurasForTarget(Unit target) {
        if (target == null || target.getVisibleAuras().isEmpty()) // speedup things
        {
            return;
        }

        var visibleAuras = target.getVisibleAuras();

        AuraUpdate update = new AuraUpdate();
        update.updateAll = true;
        update.unitGUID = target.getGUID();


        for (var auraApp : visibleAuras) {
            AuraInfo auraInfo = new AuraInfo();
            tangible.RefObject<AuraInfo> tempRef_auraInfo = new tangible.RefObject<AuraInfo>(auraInfo);
            auraApp.buildUpdatePacket(tempRef_auraInfo, false);
            auraInfo = tempRef_auraInfo.refArgValue;
            update.auras.add(auraInfo);
        }

        sendPacket(update);
    }

    private void updateBaseModGroup(BaseModGroup modGroup) {
        if (!canModifyStats()) {
            return;
        }

        switch (modGroup) {
            case CritPercentage:
                updateCritPercentage(WeaponAttackType.BaseAttack);

                break;
            case RangedCritPercentage:
                updateCritPercentage(WeaponAttackType.RangedAttack);

                break;
            case OffhandCritPercentage:
                updateCritPercentage(WeaponAttackType.OffAttack);

                break;
            default:
                break;
        }
    }

    private double getBaseModValue(BaseModGroup modGroup, BaseModType modType) {
        if (modGroup.getValue() >= BaseModGroup.End.getValue() || modType.getValue() >= BaseModType.End.getValue()) {
            Log.outError(LogFilter.spells, String.format("Player.GetBaseModValue: Invalid BaseModGroup/BaseModType (%1$s/%2$s) for player '%3$s' (%4$s)", modGroup, modType, getName(), getGUID()));

            return 0.0f;
        }

        return (modType == BaseModType.FlatMod ? _auraBaseFlatMod[modGroup.getValue()] : _auraBasePctMod[modGroup.getValue()]);
    }

    private double getTotalBaseModValue(BaseModGroup modGroup) {
        if (modGroup.getValue() >= BaseModGroup.End.getValue()) {
            Log.outError(LogFilter.spells, String.format("Player.GetTotalBaseModValue: Invalid BaseModGroup (%1$s) for player '%2$s' (%3$s)", modGroup, getName(), getGUID()));

            return 0.0f;
        }

        return _auraBaseFlatMod[modGroup.getValue()] * _auraBasePctMod[modGroup.getValue()];
    }

    private boolean isAtRecruitAFriendDistance(WorldObject pOther) {
        if (!pOther || !isInMap(pOther)) {
            return false;
        }

        WorldObject player = getCorpse();

        if (!player || isAlive()) {
            player = this;
        }

        return pOther.getDistance(player) <= WorldConfig.getFloatValue(WorldCfg.MaxRecruitAFriendDistance);
    }

    private void setActiveCombatTraitConfigID(int traitConfigId) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().activeCombatTraitConfigID), traitConfigId);
    }

    private void initPrimaryProfessions() {
        setFreePrimaryProfessions(WorldConfig.getUIntValue(WorldCfg.MaxPrimaryTradeSkill));
    }


    private void setFreePrimaryProfessions(short profs) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().characterPoints), profs);
    }

    private void sendAttackSwingCantAttack() {
        sendPacket(new AttackSwingError(AttackSwingErr.CantAttack));
    }

    private void sendAttackSwingDeadTarget() {
        sendPacket(new AttackSwingError(AttackSwingErr.DeadTarget));
    }

    private void sendAttackSwingBadFacingAttack() {
        sendPacket(new AttackSwingError(AttackSwingErr.BadFacing));
    }

    private void buildValuesUpdateForPlayerWithMask(UpdateData data, UpdateMask requestedObjectMask, UpdateMask requestedUnitMask, UpdateMask requestedPlayerMask, UpdateMask requestedActivePlayerMask, Player target) {
        var flags = getUpdateFieldFlagsFor(target);
        UpdateMask valuesMask = new UpdateMask(getTypeId().max.getValue());

        if (requestedObjectMask.isAnySet()) {
            valuesMask.set(getTypeId().object.getValue());
        }

        getUnitData().filterDisallowedFieldsMaskForFlag(requestedUnitMask, flags);

        if (requestedUnitMask.isAnySet()) {
            valuesMask.set(getTypeId().unit.getValue());
        }

        getPlayerData().filterDisallowedFieldsMaskForFlag(requestedPlayerMask, flags);

        if (requestedPlayerMask.isAnySet()) {
            valuesMask.set(getTypeId().player.getValue());
        }

        if (target == this && requestedActivePlayerMask.isAnySet()) {
            valuesMask.set(getTypeId().activePlayer.getValue());
        }

        WorldPacket buffer = new WorldPacket();
        buffer.writeInt32(valuesMask.getBlock(0));

        if (valuesMask.get(getTypeId().object.getValue())) {
            getObjectData().writeUpdate(buffer, requestedObjectMask, true, this, target);
        }

        if (valuesMask.get(getTypeId().unit.getValue())) {
            getUnitData().writeUpdate(buffer, requestedUnitMask, true, this, target);
        }

        if (valuesMask.get(getTypeId().player.getValue())) {
            getPlayerData().writeUpdate(buffer, requestedPlayerMask, true, this, target);
        }

        if (valuesMask.get(getTypeId().activePlayer.getValue())) {
            getActivePlayerData().writeUpdate(buffer, requestedActivePlayerMask, true, this, target);
        }

        WorldPacket buffer1 = new WorldPacket();
        buffer1.writeInt8((byte) UpdateType.VALUES.getValue());
        buffer1.writeGuid(getGUID());
        buffer1.writeInt32(buffer.getSize());
        buffer1.writeBytes(buffer.getByteBuf());

        data.addUpdateBlock(buffer1);
    }

    private void beforeVisibilityDestroy(WorldObject obj, Player p) {
        if (!obj.isTypeId(TypeId.UNIT)) {
            return;
        }

        if (Objects.equals(p.getPetGUID(), obj.getGUID()) && obj.toCreature().isPet()) {
            ((pet) obj).remove(PetSaveMode.NotInSlot, true);
        }
    }

    public final void updateVisibilityOf(Collection<WorldObject> targets) {
        if (targets.isEmpty()) {
            return;
        }

        UpdateData udata = new UpdateData(getLocation().getMapId());
        ArrayList<Unit> newVisibleUnits = new ArrayList<>();

        for (var target : targets) {
            if (target == this) {
                continue;
            }

            switch (target.getTypeId()) {
                case Unit:
                    updateVisibilityOf(target.toCreature(), udata, newVisibleUnits);

                    break;
                case Player:
                    updateVisibilityOf(target.toPlayer(), udata, newVisibleUnits);

                    break;
                case GameObject:
                    updateVisibilityOf(target.toGameObject(), udata, newVisibleUnits);

                    break;
                case DynamicObject:
                    updateVisibilityOf(target.toDynObject(), udata, newVisibleUnits);

                    break;
                case Corpse:
                    updateVisibilityOf(target.toCorpse(), udata, newVisibleUnits);

                    break;
                case AreaTrigger:
                    updateVisibilityOf(target.toAreaTrigger(), udata, newVisibleUnits);

                    break;
                case SceneObject:
                    updateVisibilityOf(target.toSceneObject(), udata, newVisibleUnits);

                    break;
                case Conversation:
                    updateVisibilityOf(target.toConversation(), udata, newVisibleUnits);

                    break;
                default:
                    break;
            }
        }

        if (!udata.hasData()) {
            return;
        }

        UpdateObject packet;
        tangible.OutObject<UpdateObject> tempOut_packet = new tangible.OutObject<UpdateObject>();
        udata.buildPacket(tempOut_packet);
        packet = tempOut_packet.outArgValue;
        sendPacket(packet);

        for (var visibleUnit : newVisibleUnits) {
            sendInitialVisiblePackets(visibleUnit);
        }
    }

    public final void updateVisibilityOf(WorldObject target) {
        if (haveAtClient(target)) {
            if (!canSeeOrDetect(target, false, true)) {
                if (target.isTypeId(TypeId.UNIT)) {
                    beforeVisibilityDestroy(target.toCreature(), this);
                }

                if (!target.isDestroyedObject()) {
                    target.sendOutOfRangeForPlayer(this);
                } else {
                    target.destroyForPlayer(this);
                }

                synchronized (getClientGuiDs()) {
                    getClientGuiDs().remove(target.getGUID());
                }
            }
        } else {
            if (canSeeOrDetect(target, false, true)) {
                target.sendUpdateToPlayer(this);

                synchronized (getClientGuiDs()) {
                    getClientGuiDs().add(target.getGUID());
                }

                // target aura duration for caster show only if target exist at caster client
                // send data at target visibility change (adding to client)
                if (target.isType(TypeMask.unit)) {
                    sendInitialVisiblePackets(target.toUnit());
                }
            }
        }
    }

    public final <T extends WorldObject> void updateVisibilityOf(T target, UpdateData data, ArrayList<Unit> visibleNow) {
        if (haveAtClient(target)) {
            if (!canSeeOrDetect(target, false, true)) {
                beforeVisibilityDestroy(target, this);

                if (!target.isDestroyedObject()) {
                    target.buildOutOfRangeUpdateBlock(data);
                } else {
                    target.buildDestroyUpdateBlock(data);
                }

                getClientGuiDs().remove(target.getGUID());
            }
        } else {
            if (canSeeOrDetect(target, false, true)) {
                target.buildCreateUpdateBlockForPlayer(data, this);
                updateVisibilityOf_helper(getClientGuiDs(), target, visibleNow);
            }
        }
    }

    private <T extends WorldObject> void updateVisibilityOf_helper(ArrayList<ObjectGuid> s64, T target, ArrayList<Unit> v) {
        s64.add(target.getGUID());

        switch (target.getTypeId()) {
            case Unit:
                v.add(target.toCreature());

                break;
            case Player:
                v.add(target.toPlayer());

                break;
        }
    }

    public final void sendInitialVisiblePackets(Unit target) {
        sendAurasForTarget(target);

        if (target.isAlive()) {
            if (target.hasUnitState(UnitState.MeleeAttacking) && target.getVictim() != null) {
                target.sendMeleeAttackStart(target.getVictim());
            }
        }
    }

    @Override
    public void updateObjectVisibility() {
        updateObjectVisibility(true);
    }

    @Override
    public void updateObjectVisibility(boolean forced) {
        // Prevent updating visibility if player is not in world (example: LoadFromDB sets drunkstate which updates invisibility while player is not in map)
        if (!isInWorld()) {
            return;
        }

        if (!forced) {
            addToNotify(NotifyFlag.VisibilityChanged);
        } else {
            super.updateObjectVisibility(true);
            updateVisibilityForPlayer();
        }
    }

    public final void updateVisibilityForPlayer() {
        // updates visibility of all objects around point of view for current player
        var notifier = new VisibleNotifier(this, gridType.All);
        Cell.visitGrid(getSeerView(), notifier, getSightRange());
        notifier.sendToSelf(); // send gathered data
    }

    public final void setSeer(WorldObject target) {
        setSeerView(target);
    }

    @Override
    public void sendMessageToSetInRange(ServerPacket data, float dist, boolean self) {
        if (self) {
            sendPacket(data);
        }

        PacketSenderRef sender = new PacketSenderRef(data);
        var notifier = new MessageDistDeliverer<PacketSenderRef>(this, sender, dist);
        Cell.visitGrid(this, notifier, dist);
    }

    private void sendMessageToSetInRange(ServerPacket data, float dist, boolean self, boolean own_team_only) {
        sendMessageToSetInRange(data, dist, self, own_team_only, false);
    }

    private void sendMessageToSetInRange(ServerPacket data, float dist, boolean self, boolean own_team_only, boolean required3dDist) {
        if (self) {
            sendPacket(data);
        }

        PacketSenderRef sender = new PacketSenderRef(data);
        var notifier = new MessageDistDeliverer<PacketSenderRef>(this, sender, dist, own_team_only, null, required3dDist);
        Cell.visitGrid(this, notifier, dist);
    }

    @Override
    public void sendMessageToSet(ServerPacket data, Player skipped_rcvr) {
        if (skipped_rcvr != this) {
            sendPacket(data);
        }

        // we use World.GetMaxVisibleDistance() because i cannot see why not use a distance
        // update: replaced by getMap().GetVisibilityDistance()
        PacketSenderRef sender = new PacketSenderRef(data);
        var notifier = new MessageDistDeliverer<PacketSenderRef>(this, sender, getVisibilityRange(), false, skipped_rcvr);
        Cell.visitGrid(this, notifier, getVisibilityRange());
    }

    @Override
    public void sendMessageToSet(ServerPacket data, boolean self) {
        sendMessageToSetInRange(data, getVisibilityRange(), self);
    }

    @Override
    public boolean updatePosition(Position pos) {
        return updatePosition(pos, false);
    }

    @Override
    public boolean updatePosition(Position pos, boolean teleport) {
        return updatePosition(pos.getX(), pos.getY(), pos.getZ(), pos.getO(), teleport);
    }

    @Override
    public boolean updatePosition(float x, float y, float z, float orientation) {
        return updatePosition(x, y, z, orientation, false);
    }

    @Override
    public boolean updatePosition(float x, float y, float z, float orientation, boolean teleport) {
        if (!super.updatePosition(x, y, z, orientation, teleport)) {
            return false;
        }

        // group update
        if (getGroup()) {
            setGroupUpdateFlag(GroupUpdateFlags.position);
        }

        if (getTrader() && !isWithinDistInMap(getTrader(), SharedConst.InteractionDistance)) {
            getSession().sendCancelTrade();
        }

        checkAreaExploreAndOutdoor();

        return true;
    }

    private void sendCurrencies() {
        SetupCurrency packet = new SetupCurrency();

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(id, currency) : currencyStorage) {
            var currencyRecord = CliDB.CurrencyTypesStorage.get(id);

            if (currencyRecord == null) {
                continue;
            }

            // Check faction
            if ((currencyRecord.IsAlliance() && getTeam() != Team.ALLIANCE) || (currencyRecord.IsHorde() && getTeam() != Team.Horde)) {
                continue;
            }

            // Check award condition
            if (currencyRecord.AwardConditionID != 0) {
                var playerCondition = CliDB.PlayerConditionStorage.get(currencyRecord.AwardConditionID);

                if (playerCondition != null && !ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                    continue;
                }
            }

            SetupCurrency.Record record = new SetupCurrency.record();
            record.type = currencyRecord.id;
            record.quantity = currency.quantity;

            if ((currency.WeeklyQuantity / currencyRecord.GetScaler()) > 0) {
                record.weeklyQuantity = currency.weeklyQuantity;
            }

            if (currencyRecord.HasMaxEarnablePerWeek()) {
                record.maxWeeklyQuantity = getCurrencyWeeklyCap(currencyRecord);
            }

            if (currencyRecord.IsTrackingQuantity()) {
                record.trackedQuantity = currency.trackedQuantity;
            }

            if (currencyRecord.HasTotalEarned()) {
                record.totalEarned = (int) currency.earnedQuantity;
            }

            if (currencyRecord.HasMaxQuantity(true)) {
                record.maxQuantity = getCurrencyMaxQuantity(currencyRecord, true);
            }

            record.flags = (byte) currency.flags;
            record.flags = (byte) (record.flags & ~CurrencyDbFlags.UnusedFlags.getValue());

            packet.data.add(record);
        }

        sendPacket(packet);
    }

    public final void resetCurrencyWeekCap() {
        for (byte arenaSlot = 0; arenaSlot < 3; arenaSlot++) {
            var arenaTeamId = getArenaTeamId(arenaSlot);

            if (arenaTeamId != 0) {
                var arenaTeam = global.getArenaTeamMgr().getArenaTeamById(arenaTeamId);
                arenaTeam.finishWeek(); // set played this week etc values to 0 in memory, too
                arenaTeam.saveToDB(); // save changes
                arenaTeam.notifyStatsChanged(); // notify the players of the changes
            }
        }

        for (var currency : currencyStorage.values()) {
            currency.weeklyQuantity = 0;
            currency.state = PlayerCurrencyState.changed;
        }

        sendPacket(new ResetWeeklyCurrency());
    }


    public final void addExploredZones(int pos, long mask) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldFlagValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().exploredZones, (int) pos), mask);
    }


    public final void removeExploredZones(int pos, long mask) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        removeUpdateFieldFlagValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().exploredZones, (int) pos), mask);
    }

    private void checkAreaExploreAndOutdoor() {
        if (!isAlive()) {
            return;
        }

        if (isInFlight()) {
            return;
        }

        if (WorldConfig.getBoolValue(WorldCfg.VmapIndoorCheck)) {
            removeAurasWithAttribute(isOutdoors() ? SpellAttr0.OnlyIndoors : SpellAttr0.OnlyOutdoors);
        }

        var areaId = getArea();

        if (areaId == 0) {
            return;
        }

        var areaEntry = CliDB.AreaTableStorage.get(areaId);

        if (areaEntry == null) {
            Log.outError(LogFilter.player, "Player '{0}' ({1}) discovered unknown area (x: {2} y: {3} z: {4} map: {5})", getName(), getGUID().toString(), getLocation().getX(), getLocation().getY(), getLocation().getZ(), getLocation().getMapId());

            return;
        }

        var offset = areaEntry.AreaBit / com.github.azeroth.game.entity.activePlayerData.EXPLOREDZONESBITS;

        if (offset >= PlayerConst.EXPLOREDZONESSIZE) {
            Log.outError(LogFilter.player, "Wrong area flag {0} in map data for (X: {1} Y: {2}) point to field PLAYER_EXPLORED_ZONES_1 + {3} ( {4} must be < {5} ).", areaId, getLocation().getX(), getLocation().getY(), offset, offset, PlayerConst.EXPLOREDZONESSIZE);

            return;
        }

        var val = 1 << (areaEntry.AreaBit % com.github.azeroth.game.entity.activePlayerData.EXPLOREDZONESBITS);
        var currFields = getActivePlayerData().exploredZones.get(offset);

        if (!(boolean) (currFields & val)) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldFlagValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().exploredZones, (int) offset), val);

            updateCriteria(CriteriaType.RevealWorldMapOverlay, getArea());

            var areaLevels = global.getDB2Mgr().GetContentTuningData(areaEntry.contentTuningID, getPlayerData().ctrOptions.getValue().contentTuningConditionMask);

            if (areaLevels != null) {
                if (isMaxLevel()) {
                    sendExplorationExperience(areaId, 0);
                } else {
                    var areaLevel = (short) Math.min(Math.max((short) getLevel(), areaLevels.getValue().minLevel), areaLevels.getValue().maxLevel);
                    var diff = getLevel() - areaLevel;
                    int XP;

                    if (diff < -5) {
                        XP = (int) (global.getObjectMgr().getBaseXP(getLevel() + 5) * WorldConfig.getFloatValue(WorldCfg.RateXpExplore));
                    } else if (diff > 5) {
                        var exploration_percent = 100 - ((diff - 5) * 5);

                        if (exploration_percent < 0) {
                            exploration_percent = 0;
                        }

                        XP = (int) (global.getObjectMgr().getBaseXP(areaLevel) * exploration_percent / 100 * WorldConfig.getFloatValue(WorldCfg.RateXpExplore));
                    } else {
                        XP = (int) (global.getObjectMgr().getBaseXP(areaLevel) * WorldConfig.getFloatValue(WorldCfg.RateXpExplore));
                    }

                    if (WorldConfig.getIntValue(WorldCfg.MinDiscoveredScaledXpRatio) != 0) {
                        var minScaledXP = (int) (global.getObjectMgr().getBaseXP(areaLevel) * WorldConfig.getFloatValue(WorldCfg.RateXpExplore)) * WorldConfig.getUIntValue(WorldCfg.MinDiscoveredScaledXpRatio) / 100;
                        XP = Math.max(minScaledXP, XP);
                    }

                    giveXP(XP, null);
                    sendExplorationExperience(areaId, XP);
                }

                Log.outInfo(LogFilter.player, "Player {0} discovered a new area: {1}", getGUID().toString(), areaId);
            }
        }
    }


    private void sendExplorationExperience(int area, int experience) {
        sendPacket(new ExplorationExperience(experience, area));
    }

    public final void sendSysMessage(CypherStrings str, object... args) {
        sendSysMessage((int) str.getValue(), args);
    }


    public final void sendSysMessage(int str, object... args) {
        var input = global.getObjectMgr().getCypherString(str);
        var pattern = """
                %(\\d+(\\.\\d+)?)?(d|f|s|u)""";

        var count = 0;
        var result = system.text.RegularExpressions.Regex.Replace(input, pattern, m ->
        {
            return String.Concat("{", count++, "}");
        });

        sendSysMessage(result, args);
    }

    public final void sendSysMessage(String str, object... args) {
        (new commandHandler(session)).sendSysMessage(String.format(str, args));
    }


    public final void sendBuyError(BuyResult msg, Creature creature, int item) {
        BuyFailed packet = new BuyFailed();
        packet.vendorGUID = creature ? creature.getGUID() : ObjectGuid.Empty;
        packet.muid = item;
        packet.reason = msg;
        sendPacket(packet);
    }

    public final void sendSellError(SellResult msg, Creature creature, ObjectGuid guid) {
        SellResponse sellResponse = new SellResponse();
        sellResponse.vendorGUID = (creature ? creature.getGUID() : ObjectGuid.Empty);
        sellResponse.itemGUID = guid;
        sellResponse.reason = msg;
        sendPacket(sellResponse);
    }

    @Override
    public void say(String text, Language language) {
        say(text, language, null);
    }

    @Override
    public void say(String text, Language language, WorldObject obj) {
        global.getScriptMgr().onPlayerChat(this, ChatMsg.Say, language, text);

        sendChatMessageToSetInRange(ChatMsg.Say, language, text, WorldConfig.getFloatValue(WorldCfg.ListenRangeSay));
    }

    private void sendChatMessageToSetInRange(ChatMsg chatMsg, Language language, String text, float range) {
        CustomChatTextBuilder builder = new CustomChatTextBuilder(this, chatMsg, text, language, this);
        LocalizedDo localizer = new LocalizedDo(builder);

        // Send to self
        localizer.invoke(this);

        // Send to players
        MessageDistDeliverer<LocalizedDo> notifier = new MessageDistDeliverer<LocalizedDo>(this, localizer, range, false, null, true);
        Cell.visitGrid(this, notifier, range);
    }

    @Override
    public void say(int textId) {
        say(textId, null);
    }

    @Override
    public void say(int textId, WorldObject target) {
        talk(textId, ChatMsg.Say, WorldConfig.getFloatValue(WorldCfg.ListenRangeSay), target);
    }

    @Override
    public void yell(String text, Language language) {
        yell(text, language, null);
    }

    @Override
    public void yell(String text, Language language, WorldObject obj) {
        global.getScriptMgr().onPlayerChat(this, ChatMsg.Yell, language, text);

        ChatPkt data = new ChatPkt();
        data.initialize(ChatMsg.Yell, language, this, this, text);
        sendMessageToSetInRange(data, WorldConfig.getFloatValue(WorldCfg.ListenRangeYell), true);
    }

    @Override
    public void yell(int textId) {
        yell(textId, null);
    }

    @Override
    public void yell(int textId, WorldObject target) {
        talk(textId, ChatMsg.Yell, WorldConfig.getFloatValue(WorldCfg.ListenRangeYell), target);
    }

    @Override
    public void textEmote(String text, WorldObject obj) {
        textEmote(text, obj, false);
    }

    @Override
    public void textEmote(String text) {
        textEmote(text, null, false);
    }

    @Override
    public void textEmote(String text, WorldObject obj, boolean something) {
        global.getScriptMgr().onPlayerChat(this, ChatMsg.emote, language.Universal, text);

        ChatPkt data = new ChatPkt();
        data.initialize(ChatMsg.emote, language.Universal, this, this, text);
        sendMessageToSetInRange(data, WorldConfig.getFloatValue(WorldCfg.ListenRangeTextemote), true, !getSession().hasPermission(RBACPermissions.TwoSideInteractionChat), true);
    }

    @Override
    public void textEmote(int textId, WorldObject target) {
        textEmote(textId, target, false);
    }

    @Override
    public void textEmote(int textId) {
        textEmote(textId, null, false);
    }

    @Override
    public void textEmote(int textId, WorldObject target, boolean isBossEmote) {
        talk(textId, ChatMsg.emote, WorldConfig.getFloatValue(WorldCfg.ListenRangeTextemote), target);
    }

    public final void whisperAddon(String text, String prefix, boolean isLogged, Player receiver) {
        global.getScriptMgr().onPlayerChat(this, ChatMsg.Whisper, isLogged ? language.AddonLogged : language.Addon, text, receiver);

        if (!receiver.getSession().isAddonRegistered(prefix)) {
            return;
        }

        ChatPkt data = new ChatPkt();
        data.initialize(ChatMsg.Whisper, isLogged ? language.AddonLogged : language.Addon, this, this, text, 0, "", locale.enUS, prefix);
        receiver.sendPacket(data);
    }

    @Override
    public void whisper(String text, Language language, Player target) {
        whisper(text, language, target, false);
    }

    @Override
    public void whisper(String text, Language language) {
        whisper(text, language, null, false);
    }

    @Override
    public void whisper(String text, Language language, Player target, boolean something) {
        var isAddonMessage = language == language.Addon;

        if (!isAddonMessage) // if not addon data
        {
            language = language.Universal; // whispers should always be readable
        }

        //Player rPlayer = global.ObjAccessor.findPlayer(receiver);

        global.getScriptMgr().onPlayerChat(this, ChatMsg.Whisper, language, text, target);

        ChatPkt data = new ChatPkt();
        data.initialize(ChatMsg.Whisper, language, this, this, text);
        target.sendPacket(data);

        // rest stuff shouldn't happen in case of addon message
        if (isAddonMessage) {
            return;
        }

        data.initialize(ChatMsg.WhisperInform, language, target, target, text);
        sendPacket(data);

        if (!isAcceptWhispers() && !isGameMaster() && !target.isGameMaster()) {
            setAcceptWhispers(true);
            sendSysMessage(CypherStrings.CommandWhisperon);
        }

        // announce afk or dnd message
        if (target.isAFK()) {
            sendSysMessage(CypherStrings.PlayerAfk, target.getName(), target.getAutoReplyMsg());
        } else if (target.isDND()) {
            sendSysMessage(CypherStrings.PlayerDnd, target.getName(), target.getAutoReplyMsg());
        }
    }

    @Override
    public void whisper(int textId, Player target) {
        whisper(textId, target, false);
    }

    @Override
    public void whisper(int textId, Player target, boolean isBossWhisper) {
        if (!target) {
            return;
        }

        var bct = CliDB.BroadcastTextStorage.get(textId);

        if (bct == null) {
            Log.outError(LogFilter.unit, "WorldObject.Whisper: `broadcast_text` was not {0} found", textId);

            return;
        }

        var locale = target.getSession().getSessionDbLocaleIndex();
        ChatPkt packet = new ChatPkt();
        packet.initialize(ChatMsg.Whisper, language.Universal, this, target, global.getDB2Mgr().GetBroadcastTextValue(bct, locale, getGender()));
        target.sendPacket(packet);
    }

    public final boolean canUnderstandLanguage(Language language) {
        if (isGameMaster()) {
            return true;
        }

        for (var languageDesc : global.getLanguageMgr().getLanguageDescById(language)) {
            if (languageDesc.skillId != 0 && hasSkill(SkillType.forValue(languageDesc.skillId))) {
                return true;
            }
        }

        return hasAuraTypeWithMiscvalue(AuraType.ComprehendLanguage, language.getValue());
    }

    public final void loadCorpse(SQLResult result) {
        if (isAlive() || hasAtLoginFlag(AtLoginFlags.Resurrect)) {
            spawnCorpseBones(false);
        }

        if (!isAlive()) {
            if (hasAtLoginFlag(AtLoginFlags.Resurrect)) {
                resurrectPlayer(0.5f);
            } else if (!result.isEmpty()) {
                corpseLocation = new worldLocation(result.<SHORT>Read(0), result.<Float>Read(1), result.<Float>Read(2), result.<Float>Read(3), result.<Float>Read(4));

                if (!CliDB.MapStorage.get(corpseLocation.getMapId()).Instanceable()) {
                    setPlayerLocalFlag(PlayerLocalFlags.ReleaseTimer);
                } else {
                    removePlayerLocalFlag(PlayerLocalFlags.ReleaseTimer);
                }
            }
        }

        removeAtLoginFlag(AtLoginFlags.Resurrect);
    }

    public final void _LoadMail(SQLResult mailsResult, SQLResult mailItemsResult, SQLResult artifactResult, SQLResult azeriteItemResult, SQLResult azeriteItemMilestonePowersResult, SQLResult azeriteItemUnlockedEssencesResult, SQLResult azeriteEmpoweredItemResult) {
        HashMap<Long, MAIL> mailById = new HashMap<Long, MAIL>();

        if (!mailsResult.isEmpty()) {
            do {
                Mail m = new MAIL();

                m.messageID = mailsResult.<Long>Read(0);
                m.messageType = MailMessageType.forValue(mailsResult.<Byte>Read(1));
                m.sender = mailsResult.<Integer>Read(2);
                m.receiver = mailsResult.<Integer>Read(3);
                m.subject = mailsResult.<String>Read(4);
                m.body = mailsResult.<String>Read(5);
                m.expire_time = mailsResult.<Long>Read(6);
                m.deliver_time = mailsResult.<Long>Read(7);
                m.money = mailsResult.<Long>Read(8);
                m.COD = mailsResult.<Long>Read(9);
                m.checkMask = MailCheckMask.forValue(mailsResult.<Byte>Read(10));
                m.stationery = MailStationery.forValue(mailsResult.<Byte>Read(11));
                m.mailTemplateId = mailsResult.<SHORT>Read(12);

                if (m.mailTemplateId != 0 && !CliDB.MailTemplateStorage.containsKey(m.mailTemplateId)) {
                    Log.outError(LogFilter.player, String.format("Player:_LoadMail - MAIL (%1$s) have not existed mailTemplateId (%2$s), remove at load", m.messageID, m.mailTemplateId));
                    m.mailTemplateId = 0;
                }

                m.state = MailState.Unchanged;

                mail.add(m);
                mailById.put(m.messageID, m);
            } while (mailsResult.NextRow());
        }

        if (!mailItemsResult.isEmpty()) {
            HashMap<Long, ItemAdditionalLoadInfo> additionalData = new HashMap<Long, ItemAdditionalLoadInfo>();
            ItemAdditionalLoadInfo.init(additionalData, artifactResult, azeriteItemResult, azeriteItemMilestonePowersResult, azeriteItemUnlockedEssencesResult, azeriteEmpoweredItemResult);

            do {
                var mailId = mailItemsResult.<Long>Read(52);
                _LoadMailedItem(getGUID(), this, mailId, mailById.get(mailId), mailItemsResult.GetFields(), additionalData.get(mailItemsResult.<Long>Read(0)));
            } while (mailItemsResult.NextRow());
        }

        updateNextMailTimeAndUnreads();
    }

    public final void _SaveMail(SQLTransaction trans) {
        PreparedStatement stmt;

        for (var m : mail) {
            if (m.state == MailState.changed) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_MAIL);
                stmt.AddValue(0, m.hasItems() ? 1 : 0);
                stmt.AddValue(1, m.expire_time);
                stmt.AddValue(2, m.deliver_time);
                stmt.AddValue(3, m.money);
                stmt.AddValue(4, m.COD);
                stmt.AddValue(5, (byte) m.checkMask.getValue());
                stmt.AddValue(6, m.messageID);

                trans.append(stmt);

                if (!m.removedItems.isEmpty()) {
                    for (var id : m.removedItems) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_ITEM);
                        stmt.AddValue(0, id);
                        trans.append(stmt);
                    }

                    m.removedItems.clear();
                }

                m.state = MailState.Unchanged;
            } else if (m.state == MailState.Deleted) {
                if (m.hasItems()) {
                    for (var mailItemInfo : m.items) {
                        item.deleteFromDB(trans, mailItemInfo.item_guid);
                        azeriteItem.deleteFromDB(trans, mailItemInfo.item_guid);
                        azeriteEmpoweredItem.deleteFromDB(trans, mailItemInfo.item_guid);
                    }
                }

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_BY_ID);
                stmt.AddValue(0, m.messageID);
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_MAIL_ITEM_BY_ID);
                stmt.AddValue(0, m.messageID);
                trans.append(stmt);
            }
        }

        //deallocate deleted mails...
        for (var m : getMails()) {
            if (m.state == MailState.Deleted) {
                mail.remove(m);
            }
        }

        setMailsUpdated(false);
    }

    public final void saveGoldToDB(SQLTransaction trans) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_CHAR_MONEY);
        stmt.AddValue(0, getMoney());
        stmt.AddValue(1, getGUID().getCounter());
        trans.append(stmt);
    }

    public final void saveInventoryAndGoldToDB(SQLTransaction trans) {
        _SaveInventory(trans);
        _SaveCurrency(trans);
        saveGoldToDB(trans);
    }

    public final boolean loadFromDB(ObjectGuid guid, SQLQueryHolder<PlayerLoginQueryLoad> holder) {
        var result = holder.GetResult(PlayerLoginQueryLoad.from);

        if (result.isEmpty()) {
            String cacheName;
            tangible.OutObject<String> tempOut_cacheName = new tangible.OutObject<String>();
            global.getCharacterCacheStorage().getCharacterNameByGuid(guid, tempOut_cacheName);
            cacheName = tempOut_cacheName.outArgValue;
            Log.outError(LogFilter.player, "Player {0} {1} not found in table `character`, can't load. ", cacheName, guid.toString());

            return false;
        }

        var fieldIndex = 1;
        var accountId = result.<Integer>Read(fieldIndex++);
        var name = result.<String>Read(fieldIndex++);
        var race = race.forValue(result.<Byte>Read(fieldIndex++));
        var class_ = playerClass.forValue(result.<Byte>Read(fieldIndex++));
        var gender = gender.forValue(result.<Byte>Read(fieldIndex++));
        var level = result.<Byte>Read(fieldIndex++);
        var xp = result.<Integer>Read(fieldIndex++);
        var money = result.<Long>Read(fieldIndex++);
        var inventorySlots = result.<Byte>Read(fieldIndex++);
        var bankSlots = result.<Byte>Read(fieldIndex++);
        var restState = PlayerRestState.forValue(result.<Byte>Read(fieldIndex++));
        var playerFlags = playerFlags.forValue(result.<Integer>Read(fieldIndex++));
        var playerFlagsEx = playerFlagsEx.forValue(result.<Integer>Read(fieldIndex++));
        var position_x = result.<Float>Read(fieldIndex++);
        var position_y = result.<Float>Read(fieldIndex++);
        var position_z = result.<Float>Read(fieldIndex++);
        int mapId = result.<SHORT>Read(fieldIndex++);
        var orientation = result.<Float>Read(fieldIndex++);
        var taximask = result.<String>Read(fieldIndex++);
        var createTime = result.<Long>Read(fieldIndex++);
        var createMode = PlayerCreateMode.forValue(result.<Byte>Read(fieldIndex++));
        var cinematic = result.<Byte>Read(fieldIndex++);
        var totaltime = result.<Integer>Read(fieldIndex++);
        var leveltime = result.<Integer>Read(fieldIndex++);
        var rest_bonus = result.<Float>Read(fieldIndex++);
        var logout_time = result.<Long>Read(fieldIndex++);
        var is_logout_resting = result.<Byte>Read(fieldIndex++);
        var resettalents_cost = result.<Integer>Read(fieldIndex++);
        var resettalents_time = result.<Long>Read(fieldIndex++);
        var primarySpecialization = result.<Integer>Read(fieldIndex++);
        var trans_x = result.<Float>Read(fieldIndex++);
        var trans_y = result.<Float>Read(fieldIndex++);
        var trans_z = result.<Float>Read(fieldIndex++);
        var trans_o = result.<Float>Read(fieldIndex++);
        var transguid = result.<Long>Read(fieldIndex++);
        var extra_flags = PlayerExtraFlags.forValue(result.<SHORT>Read(fieldIndex++));
        var summonedPetNumber = result.<Integer>Read(fieldIndex++);
        var at_login = result.<SHORT>Read(fieldIndex++);
        var zone = result.<SHORT>Read(fieldIndex++);
        var online = result.<Byte>Read(fieldIndex++);
        var death_expire_time = result.<Long>Read(fieldIndex++);
        var taxi_path = result.<String>Read(fieldIndex++);
        var dungeonDifficulty = Difficulty.forValue(result.<Byte>Read(fieldIndex++));
        var totalKills = result.<Integer>Read(fieldIndex++);
        var todayKills = result.<SHORT>Read(fieldIndex++);
        var yesterdayKills = result.<SHORT>Read(fieldIndex++);
        var chosenTitle = result.<Integer>Read(fieldIndex++);
        var watchedFaction = result.<Integer>Read(fieldIndex++);
        var drunk = result.<Byte>Read(fieldIndex++);
        var health = result.<Integer>Read(fieldIndex++);

        var powers = new int[PowerType.MaxPerClass.getValue()];

        for (var i = 0; i < powers.length; ++i) {
            powers[i] = result.<Integer>Read(fieldIndex++);
        }

        var instance_id = result.<Integer>Read(fieldIndex++);
        var activeTalentGroup = result.<Byte>Read(fieldIndex++);
        var lootSpecId = result.<Integer>Read(fieldIndex++);
        var exploredZones = result.<String>Read(fieldIndex++);
        var knownTitles = result.<String>Read(fieldIndex++);
        var actionBars = result.<Byte>Read(fieldIndex++);
        var raidDifficulty = Difficulty.forValue(result.<Byte>Read(fieldIndex++));
        var legacyRaidDifficulty = Difficulty.forValue(result.<Byte>Read(fieldIndex++));
        var fishingSteps = result.<Byte>Read(fieldIndex++);
        var honor = result.<Integer>Read(fieldIndex++);
        var honorLevel = result.<Integer>Read(fieldIndex++);
        var honorRestState = PlayerRestState.forValue(result.<Byte>Read(fieldIndex++));
        var honorRestBonus = result.<Float>Read(fieldIndex++);
        var numRespecs = result.<Byte>Read(fieldIndex++);


        // check if the character's account in the db and the logged in account match.
        // player should be able to load/delete character only with correct account!
        if (accountId != getSession().getAccountId()) {
            Log.outError(LogFilter.player, "Player (GUID: {0}) loading from wrong account (is: {1}, should be: {2})", getGUID().toString(), getSession().getAccountId(), accountId);

            return false;
        }

        var banResult = holder.GetResult(PlayerLoginQueryLoad.Banned);

        if (!banResult.isEmpty()) {
            Log.outError(LogFilter.player, "{0} is banned, can't load.", guid.toString());

            return false;
        }

        create(guid);

        setName(name);

        // check name limitations
        if (ObjectManager.checkPlayerName(getName(), getSession().getSessionDbcLocale()) != ResponseCodes.CharNameSuccess || (!getSession().hasPermission(RBACPermissions.SkipCheckCharacterCreationReservedname) && global.getObjectMgr().isReservedName(getName()))) {
            var stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_ADD_AT_LOGIN_FLAG);
            stmt.AddValue(0, (short) AtLoginFlags.Rename.getValue());
            stmt.AddValue(1, guid.getCounter());
            DB.characters.execute(stmt);

            return false;
        }


        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().wowAccount), getSession().getAccountGUID());
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().bnetAccount), getSession().getBattlenetAccountGUID());

        if (gender.getValue() >= getGender().getValue().NONE) {
            Log.outError(LogFilter.player, "Player {0} has wrong gender ({1}), can't be loaded.", guid.toString(), gender);

            return false;
        }

        setRace(race);
        setClass(class_);
        setGender(gender);

        // check if race/class combination is valid
        var info = global.getObjectMgr().getPlayerInfo(getRace(), getClass());

        if (info == null) {
            Log.outError(LogFilter.player, "Player {0} has wrong race/class ({1}/{2}), can't be loaded.", guid.toString(), getRace(), getClass());

            return false;
        }

        setLevel(level);
        setXP(xp);

        LocalizedString exploredZonesStrings = new LocalizedString();

        for (var i = 0; i < exploredZonesStrings.length && i / 2 < com.github.azeroth.game.entity.activePlayerData.EXPLOREDZONESSIZE; ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldFlagValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().exploredZones, i / 2), (long) ((Long.parseLong(exploredZonesStrings.get(i))) << (32 * (i % 2))));
        }

        LocalizedString knownTitlesStrings = new LocalizedString();

        if ((knownTitlesStrings.Length % 2) == 0) {
            for (var i = 0; i < knownTitlesStrings.length; ++i) {
                setUpdateFieldFlagValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().knownTitles, i / 2), (Long.parseLong(knownTitlesStrings.get(i))) << (32 * (i % 2)));
            }
        }

        setObjectScale(1.0f);
        setHoverHeight(1.0f);

        // load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateAchievementCriteria)
        _AchievementSys.loadFromDB(holder.GetResult(PlayerLoginQueryLoad.Achievements), holder.GetResult(PlayerLoginQueryLoad.criteriaProgress));
        questObjectiveCriteriaManager.loadFromDB(holder.GetResult(PlayerLoginQueryLoad.QuestStatusObjectivesCriteria), holder.GetResult(PlayerLoginQueryLoad.QuestStatusObjectivesCriteriaProgress));

        setMoney(Math.min(money, PlayerConst.MaxMoneyAmount));

        ArrayList<ChrCustomizationChoice> customizations = new ArrayList<>();
        var customizationsResult = holder.GetResult(PlayerLoginQueryLoad.customizations);

        if (!customizationsResult.isEmpty()) {
            do {
                ChrCustomizationChoice choice = new ChrCustomizationChoice();
                choice.chrCustomizationOptionID = customizationsResult.<Integer>Read(0);
                choice.chrCustomizationChoiceID = customizationsResult.<Integer>Read(1);
                customizations.add(choice);
            } while (customizationsResult.NextRow());
        }

        setCustomizations(customizations, false);
        setInventorySlotCount(inventorySlots);
        setBankBagSlotCount(bankSlots);
        setNativeGender(gender);
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().inebriation), drunk);
        replaceAllPlayerFlags(playerFlags);
        replaceAllPlayerFlagsEx(playerFlagsEx);
        setWatchedFactionIndex(watchedFaction);

        setLoginFlags(AtLoginFlags.forValue(at_login));

        if (!getSession().validateAppearance(getRace(), getClass(), gender, customizations)) {
            Log.outError(LogFilter.player, "Player {0} has wrong Appearance values (Hair/Skin/Color), can't be loaded.", guid.toString());

            return false;
        }

        // set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)
        setMultiActionBars(actionBars);

        fishingSteps = fishingSteps;

        initDisplayIds();

        //Need to call it to initialize m_team (m_team can be calculated from race)
        //Other way is to saves m_team into character table.
        setFactionForRace(getRace());

        // load home bind and check in same time class/race pair, it used later for restore broken positions
        if (!_LoadHomeBind(holder.GetResult(PlayerLoginQueryLoad.HomeBind))) {
            return false;
        }

        initializeSkillFields();
        initPrimaryProfessions(); // to max set before any spell loaded

        // init saved position, and fix it later if problematic
        getLocation().relocate(position_x, position_y, position_z, orientation);

        setDungeonDifficultyId(checkLoadedDungeonDifficultyId(dungeonDifficulty));
        setRaidDifficultyId(checkLoadedRaidDifficultyId(raidDifficulty));
        setLegacyRaidDifficultyId(checkLoadedLegacyRaidDifficultyId(legacyRaidDifficulty));

        var RelocateToHomebind = () ->
        {
            mapId = homeBind.getMapId();
            instance_id = 0;
            getLocation().relocate(homeBind);
        };

        _LoadGroup(holder.GetResult(PlayerLoginQueryLoad.group));

        _LoadCurrency(holder.GetResult(PlayerLoginQueryLoad.currency));
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().lifetimeHonorableKills), totalKills);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().todayHonorableKills), todayKills);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().yesterdayHonorableKills), yesterdayKills);

        _LoadInstanceTimeRestrictions(holder.GetResult(PlayerLoginQueryLoad.InstanceLockTimes));
        _LoadBGData(holder.GetResult(PlayerLoginQueryLoad.BgData));

        getSession().setPlayer(this);

        Map map = null;
        var player_at_bg = false;
        var mapEntry = CliDB.MapStorage.get(mapId);

        if (mapEntry == null || !getLocation().isPositionValid()) {
            Log.outError(LogFilter.player, "Player (guidlow {0}) have invalid coordinates (MapId: {1} {2}). Teleport to default race/class locations.", guid.toString(), mapId, getLocation());
            RelocateToHomebind.invoke();
        } else if (mapEntry.IsBattlegroundOrArena()) {
            Battleground currentBg = null;

            if (bgData.getBgInstanceId() != 0) //saved in Battleground
            {
                currentBg = global.getBattlegroundMgr().getBattleground(bgData.getBgInstanceId(), BattlegroundTypeId.NONE);
            }

            player_at_bg = currentBg != null && currentBg.isPlayerInBattleground(getGUID());

            if (player_at_bg && currentBg.getStatus() != BattlegroundStatus.WaitLeave) {
                map = currentBg.getBgMap();

                var bgQueueTypeId = currentBg.getQueueId();
                addBattlegroundQueueId(bgQueueTypeId);

                bgData.setBgTypeId(currentBg.getTypeID());

                //join player to Battlegroundgroup
                currentBg.eventPlayerLoggedIn(this);

                setInviteForBattlegroundQueueType(bgQueueTypeId, currentBg.getInstanceID());
                setMercenaryForBattlegroundQueueType(bgQueueTypeId, currentBg.isPlayerMercenaryInBattleground(getGUID()));
            }
            // Bg was not found - go to Entry Point
            else {
                // leave bg
                if (player_at_bg) {
                    player_at_bg = false;
                    currentBg.removePlayerAtLeave(getGUID(), false, true);
                }

                // Do not look for instance if bg not found
                var _loc = getBattlegroundEntryPoint();
                mapId = _loc.getMapId();
                instance_id = 0;

                if (mapId == 0xFFFFFFFF) // BattlegroundEntry Point not found (???)
                {
                    Log.outError(LogFilter.player, "Player (guidlow {0}) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid.toString());
                    RelocateToHomebind.invoke();
                } else {
                    getLocation().relocate(_loc);
                }

                // We are not in BG anymore
                bgData.setBgInstanceId(0);
            }
        }
        // currently we do not support transport in bg
        else if (transguid != 0) {
            var transGUID = ObjectGuid.create(HighGuid.Transport, transguid);

            Transport transport = null;
            var transportMap = global.getMapMgr().CreateMap(mapId, this);

            if (transportMap != null) {
                var transportOnMap = transportMap.getTransport(transGUID);

                if (transportOnMap != null) {
                    if (transportOnMap.getExpectedMapId() != mapId) {
                        mapId = transportOnMap.getExpectedMapId();
                        setInstanceId(0);
                        transportMap = global.getMapMgr().CreateMap(mapId, this);

                        if (transportMap) {
                            transport = transportMap.getTransport(transGUID);
                        }
                    } else {
                        transport = transportOnMap;
                    }
                }
            }

            if (transport) {
                var pos = new Position(trans_x, trans_y, trans_z, trans_o);

                getMovementInfo().transport.pos = pos.Copy();
                transport.calculatePassengerPosition(pos);

                if (!MapDefine.isValidMapCoordinatei(pos) || Math.abs(getMovementInfo().transport.pos.getX()) > 250.0f || Math.abs(getMovementInfo().transport.pos.getY()) > 250.0f || Math.abs(getMovementInfo().transport.pos.getZ()) > 250.0f) {
                    Log.outError(LogFilter.player, "Player (guidlow {0}) have invalid transport coordinates ({1}). Teleport to bind location.", guid.toString(), pos.toString());

                    getMovementInfo().transport.reset();
                    RelocateToHomebind.invoke();
                } else {
                    getLocation().relocate(pos);
                    mapId = transport.getLocation().getMapId();

                    transport.addPassenger(this);
                }
            } else {
                Log.outError(LogFilter.player, "Player (guidlow {0}) have problems with transport guid ({1}). Teleport to bind location.", guid.toString(), transguid);

                RelocateToHomebind.invoke();
            }
        }
        // currently we do not support taxi in instance
        else if (!taxi_path.isEmpty()) {
            instance_id = 0;

            // Not finish taxi flight path
            if (bgData.hasTaxiPath()) {
                for (var i = 0; i < 2; ++i) {
                    getTaxi().addTaxiDestination(bgData.getTaxiPath()[i]);
                }
            }

            if (!getTaxi().loadTaxiDestinationsFromString(taxi_path, getTeam())) {
                // problems with taxi path loading
                TaxiNodesRecord nodeEntry = null;
                var node_id = getTaxi().getTaxiSource();

                if (node_id != 0) {
                    nodeEntry = CliDB.TaxiNodesStorage.get(node_id);
                }

                if (nodeEntry == null) // don't know taxi start node, to homebind
                {
                    Log.outError(LogFilter.player, "Character {0} have wrong data in taxi destination list, teleport to homebind.", getGUID().toString());
                    RelocateToHomebind.invoke();
                } else // have start node, to it
                {
                    Log.outError(LogFilter.player, "Character {0} have too short taxi destination list, teleport to original node.", getGUID().toString());
                    mapId = nodeEntry.ContinentID;
                    getLocation().relocate(nodeEntry.pos.X, nodeEntry.pos.Y, nodeEntry.pos.Z, 0.0f);
                }

                getTaxi().clearTaxiDestinations();
            }

            var nodeid = getTaxi().getTaxiSource();

            if (nodeid != 0) {
                // save source node as recall coord to prevent recall and fall from sky
                var nodeEntry = CliDB.TaxiNodesStorage.get(nodeid);

                if (nodeEntry != null && nodeEntry.ContinentID == getLocation().getMapId()) {
                    mapId = nodeEntry.ContinentID;
                    getLocation().relocate(nodeEntry.pos.X, nodeEntry.pos.Y, nodeEntry.pos.Z, 0.0f);
                }

                // flight will started later
            }
        } else if (mapEntry.IsDungeon() && getInstanceId() != 0) {
            // try finding instance by id first
            map = global.getMapMgr().findMap(mapId, getInstanceId());
        }

        // Map could be changed before
        mapEntry = CliDB.MapStorage.get(mapId);

        // client without expansion support
        if (mapEntry != null) {
            if (getSession().getExpansion().getValue() < mapEntry.expansion()) {
                Log.outDebug(LogFilter.player, "Player {0} using client without required expansion tried login at non accessible map {1}", getName(), mapId);
                RelocateToHomebind.invoke();
            }
        }

        // NOW player must have valid map
        // load the player's map here if it's not already loaded
        if (!map) {
            map = global.getMapMgr().CreateMap(mapId, this);
        }

        AreaTriggerStruct areaTrigger = null;
        var check = false;

        if (!map) {
            areaTrigger = global.getObjectMgr().getGoBackTrigger(mapId);
            check = true;
        } else if (map.isDungeon()) // if map is dungeon...
        {
            var denyReason = map.cannotEnter(this); // ... and can't enter map, then look for entry point.

            if (denyReason != null) {
                sendTransferAborted(map.getId(), denyReason.getReason(), denyReason.getArg(), denyReason.getMapDifficultyXConditionId());
                areaTrigger = global.getObjectMgr().getGoBackTrigger(mapId);
                check = true;
            } else if (instance_id != 0 && global.getInstanceLockMgr().findActiveInstanceLock(guid, new MapDb2Entries(mapId, map.getDifficultyID())) != null) // ... and instance is reseted then look for entrance.
            {
                areaTrigger = global.getObjectMgr().getMapEntranceTrigger(mapId);
                check = true;
            }
        }

        if (check) // in case of special event when creating map...
        {
            if (areaTrigger != null) // ... if we have an areatrigger, then relocate to new map/coordinates.
            {
                getLocation().relocate(areaTrigger.target_X, areaTrigger.target_Y, areaTrigger.target_Z, getLocation().getO());

                if (mapId != areaTrigger.target_mapId) {
                    mapId = areaTrigger.target_mapId;
                    map = global.getMapMgr().CreateMap(mapId, this);
                }
            }
        }

        if (!map) {
            RelocateToHomebind.invoke();
            map = global.getMapMgr().CreateMap(mapId, this);

            if (!map) {
                Log.outError(LogFilter.player, "Player {0} {1} Map: {2}, {3}. Invalid default map coordinates or instance couldn't be created.", getName(), guid.toString(), mapId, getLocation());

                return false;
            }
        }

        setMap(map);
        updatePositionData();

        // now that map position is determined, check instance validity
        if (!checkInstanceValidity(true) && !isInstanceLoginGameMasterException()) {
            setInstanceValid(false);
        }

        if (player_at_bg) {
            map.getToBattlegroundMap().getBG().addPlayer(this);
        }

        // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
        // this must help in case next save after mass player load after server startup
        nextSave = RandomUtil.URand(_nextSave / 2, _nextSave * 3 / 2);

        saveRecallPosition();

        var now = gameTime.GetGameTime();
        var logoutTime = logout_time;

        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().logoutTime), logoutTime);

        // since last logout (in seconds)
        var time_diff = now - logoutTime;

        // set second, including drunk invisibility detection
        // calculate sobering. after 15 minutes logged out, the player will be sober again
        if (time_diff < (int) getDrunkValue() * 9) {
            setDrunkValue((byte) (getDrunkValue() - time_diff / 9));
        } else {
            setDrunkValue((byte) 0);
        }

        createTime = createTime;
        createMode = createMode;
        cinematic = cinematic;
        playedTimeTotal = totaltime;
        playedTimeLevel = leveltime;

        setTalentResetCost(resettalents_cost);
        setTalentResetTime(resettalents_time);

        getTaxi().loadTaxiMask(taximask); // must be before InitTaxiNodesForLevel

        _LoadPetStable(summonedPetNumber, holder.GetResult(PlayerLoginQueryLoad.PetSlots));

        // Honor system
        // Update Honor kills data
        lastHonorUpdateTime = logoutTime;
        updateHonorFields();

        deathExpireTime = death_expire_time;

        if (deathExpireTime > now + PlayerConst.MaxDeathCount * PlayerConst.DeathExpireStep) {
            deathExpireTime = now + PlayerConst.MaxDeathCount * PlayerConst.DeathExpireStep - 1;
        }

        removeUnitFlag2(UnitFlag2.ForceMovement);

        // make sure the unit is considered out of combat for proper loading
        clearInCombat();

        // reset stats before loading any modifiers
        initStatsForLevel();
        initTaxiNodesForLevel();
        initRunes();

        // rest bonus can only be calculated after initStatsForLevel()
        restMgr.loadRestBonus(RestTypes.XP, restState, rest_bonus);

        // load skills after InitStatsForLevel because it triggering aura apply also
        _LoadSkills(holder.GetResult(PlayerLoginQueryLoad.skills));
        updateSkillsForLevel();

        setNumRespecs(numRespecs);
        setPrimarySpecialization(primarySpecialization);
        setActiveTalentGroup(activeTalentGroup);
        var primarySpec = CliDB.ChrSpecializationStorage.get(getPrimarySpecialization());

        if (primarySpec == null || primarySpec.classID != (byte) getClass().getValue() || getActiveTalentGroup() >= PlayerConst.MaxSpecializations) {
            resetTalentSpecialization();
        }

        var chrSpec = CliDB.ChrSpecializationStorage.get(lootSpecId);

        if (chrSpec != null) {
            if (chrSpec.classID == (int) getClass().getValue()) {
                setLootSpecId(lootSpecId);
            }
        }

        updateDisplayPower();
        _LoadTalents(holder.GetResult(PlayerLoginQueryLoad.talents));
        _LoadPvpTalents(holder.GetResult(PlayerLoginQueryLoad.pvpTalents));
        _LoadSpells(holder.GetResult(PlayerLoginQueryLoad.spells), holder.GetResult(PlayerLoginQueryLoad.SpellFavorites));
        getSession().getCollectionMgr().loadToys();
        getSession().getCollectionMgr().loadHeirlooms();
        getSession().getCollectionMgr().loadMounts();
        getSession().getCollectionMgr().loadItemAppearances();
        getSession().getCollectionMgr().loadTransmogIllusions();

        learnSpecializationSpells();

        _LoadGlyphs(holder.GetResult(PlayerLoginQueryLoad.glyphs));
        _LoadAuras(holder.GetResult(PlayerLoginQueryLoad.auras), holder.GetResult(PlayerLoginQueryLoad.auraEffects), time_diff);
        _LoadGlyphAuras();

        // add ghost flag (must be after aura load: PLAYER_FLAGS_GHOST set in aura)
        if (hasPlayerFlag(playerFlags.Ghost)) {
            setDeathState(deathState.Dead);
        }

        // Load spell locations - must be after loading auras
        _LoadStoredAuraTeleportLocations(holder.GetResult(PlayerLoginQueryLoad.AuraStoredLocations));

        // after spell load, learn rewarded spell if need also
        _LoadQuestStatus(holder.GetResult(PlayerLoginQueryLoad.QuestStatus));
        _LoadQuestStatusObjectives(holder.GetResult(PlayerLoginQueryLoad.QuestStatusObjectives));
        _LoadQuestStatusRewarded(holder.GetResult(PlayerLoginQueryLoad.QuestStatusRew));
        _LoadDailyQuestStatus(holder.GetResult(PlayerLoginQueryLoad.DailyQuestStatus));
        _LoadWeeklyQuestStatus(holder.GetResult(PlayerLoginQueryLoad.WeeklyQuestStatus));
        _LoadSeasonalQuestStatus(holder.GetResult(PlayerLoginQueryLoad.SeasonalQuestStatus));
        _LoadRandomBGStatus(holder.GetResult(PlayerLoginQueryLoad.RandomBg));

        // after spell and quest load
        initTalentForLevel();
        learnDefaultSkills();
        learnCustomSpells();

        _LoadTraits(holder.GetResult(PlayerLoginQueryLoad.traitConfigs), holder.GetResult(PlayerLoginQueryLoad.TraitEntries)); // must be after loading spells

        // must be before inventory (some items required reputation check)
        reputationMgr.loadFromDB(holder.GetResult(PlayerLoginQueryLoad.Reputation));

        _LoadInventory(holder.GetResult(PlayerLoginQueryLoad.Inventory), holder.GetResult(PlayerLoginQueryLoad.Artifacts), holder.GetResult(PlayerLoginQueryLoad.Azerite), holder.GetResult(PlayerLoginQueryLoad.AzeriteMilestonePowers), holder.GetResult(PlayerLoginQueryLoad.AzeriteUnlockedEssences), holder.GetResult(PlayerLoginQueryLoad.AzeriteEmpowered), time_diff);

        if (isVoidStorageUnlocked()) {
            _LoadVoidStorage(holder.GetResult(PlayerLoginQueryLoad.VoidStorage));
        }

        // update items with duration and realtime
        updateItemDuration(time_diff, true);

        startLoadingActionButtons();

        // unread mails and next delivery time, actual mails not loaded
        _LoadMail(holder.GetResult(PlayerLoginQueryLoad.mails), holder.GetResult(PlayerLoginQueryLoad.MailItems), holder.GetResult(PlayerLoginQueryLoad.MailItemsArtifact), holder.GetResult(PlayerLoginQueryLoad.MailItemsAzerite), holder.GetResult(PlayerLoginQueryLoad.MailItemsAzeriteMilestonePower), holder.GetResult(PlayerLoginQueryLoad.MailItemsAzeriteUnlockedEssence), holder.GetResult(PlayerLoginQueryLoad.MailItemsAzeriteEmpowered));

        social = global.getSocialMgr().loadFromDB(holder.GetResult(PlayerLoginQueryLoad.SocialList), getGUID());

        // check PLAYER_CHOSEN_TITLE compatibility with PLAYER__FIELD_KNOWN_TITLES
        // note: PLAYER__FIELD_KNOWN_TITLES updated at quest status loaded
        if (chosenTitle != 0 && !hasTitle(chosenTitle)) {
            chosenTitle = 0;
        }

        setChosenTitle(chosenTitle);

        // has to be called after last relocate() in player.LoadFromDB
        setFallInformation(0, getLocation().getZ());

        getSpellHistory().<Player>LoadFromDb(holder.GetResult(PlayerLoginQueryLoad.spellCooldowns), holder.GetResult(PlayerLoginQueryLoad.spellCharges));

        var savedHealth = health;

        if (savedHealth == 0) {
            setDeathState(deathState.Corpse);
        }

        // Spell code allow apply any auras to dead character in load time in aura/spell/item loading
        // Do now before stats re-calculation cleanup for ghost state unexpected auras
        if (!isAlive()) {
            removeAllAurasOnDeath();
        } else {
            removeAllAurasRequiringDeadTarget();
        }

        //apply all stat bonuses from items and auras
        setCanModifyStats(true);
        updateAllStats();

        // restore remembered power/health values (but not more max values)
        setHealth(savedHealth > getMaxHealth() ? getMaxHealth() : savedHealth);
        var loadedPowers = 0;

        for (Power i = 0; i.getValue() < powerType.max.getValue(); ++i) {
            if (global.getDB2Mgr().GetPowerIndexByClass(i, getClass()) != powerType.max.getValue()) {
                var savedPower = powers[loadedPowers];
                var maxPower = getUnitData().maxPower.get(loadedPowers);
                setPower(i, savedPower > maxPower ? maxPower : savedPower);

                if (++loadedPowers >= powerType.MaxPerClass.getValue()) {
                    break;
                }
            }
        }

        for (; loadedPowers < powerType.MaxPerClass.getValue(); ++loadedPowers) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().power, loadedPowers), 0);
        }

        setPower(powerType.LunarPower, 0);

        // Init rune recharge
        if (getPowerIndex(powerType.runes) != powerType.max.getValue()) {
            var runes = getPower(powerType.runes);
            var maxRunes = getMaxPower(powerType.runes);
            var runeCooldown = getRuneBaseCooldown();

            while (runes < maxRunes) {
                setRuneCooldown((byte) runes, runeCooldown);
                ++runes;
            }
        }

        Log.outDebug(LogFilter.player, "The second of player {0} after load item and aura is: ", getName());

        // GM state
        if (getSession().hasPermission(RBACPermissions.RestoreSavedGmState)) {
            switch (WorldConfig.getIntValue(WorldCfg.GmLoginState)) {
                default:
                case 0:
                    break; // disable
                case 1:
                    setGameMaster(true);

                    break; // enable
                case 2: // save state
                    if (extra_flags.hasFlag(PlayerExtraFlags.GMOn)) {
                        setGameMaster(true);
                    }

                    break;
            }

            switch (WorldConfig.getIntValue(WorldCfg.GmVisibleState)) {
                default:
                case 0:
                    setGMVisible(false);

                    break; // invisible
                case 1:
                    break; // visible
                case 2: // save state
                    if (extra_flags.hasFlag(PlayerExtraFlags.GMInvisible)) {
                        setGMVisible(false);
                    }

                    break;
            }

            switch (WorldConfig.getIntValue(WorldCfg.GmChat)) {
                default:
                case 0:
                    break; // disable
                case 1:
                    setGMChat(true);

                    break; // enable
                case 2: // save state
                    if (extra_flags.hasFlag(PlayerExtraFlags.GMChat)) {
                        setGMChat(true);
                    }

                    break;
            }

            switch (WorldConfig.getIntValue(WorldCfg.GmWhisperingTo)) {
                default:
                case 0:
                    break; // disable
                case 1:
                    setAcceptWhispers(true);

                    break; // enable
                case 2: // save state
                    if (extra_flags.hasFlag(PlayerExtraFlags.AcceptWhispers)) {
                        setAcceptWhispers(true);
                    }

                    break;
            }
        }

        initPvP();

        // RaF stuff.
        if (getSession().isARecruiter() || (getSession().getRecruiterId() != 0)) {
            setDynamicFlag(UnitDynFlags.ReferAFriend);
        }

        _LoadDeclinedNames(holder.GetResult(PlayerLoginQueryLoad.declinedNames));

        _LoadEquipmentSets(holder.GetResult(PlayerLoginQueryLoad.EquipmentSets));
        _LoadTransmogOutfits(holder.GetResult(PlayerLoginQueryLoad.TransmogOutfits));

        _LoadCUFProfiles(holder.GetResult(PlayerLoginQueryLoad.CufProfiles));

        var garrison = new Garrison(this);

        if (garrison.loadFromDB(holder.GetResult(PlayerLoginQueryLoad.Garrison), holder.GetResult(PlayerLoginQueryLoad.GarrisonBlueprints), holder.GetResult(PlayerLoginQueryLoad.GarrisonBuildings), holder.GetResult(PlayerLoginQueryLoad.GarrisonFollowers), holder.GetResult(PlayerLoginQueryLoad.GarrisonFollowerAbilities))) {
            garrison = garrison;
        }

        _InitHonorLevelOnLoadFromDB(honor, honorLevel);

        restMgr.loadRestBonus(RestTypes.honor, honorRestState, honorRestBonus);

        if (time_diff > 0) {
            //speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
            var bubble0 = 0.031f;
            //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
            var bubble1 = 0.125f;

            var bubble = is_logout_resting > 0 ? bubble1 * WorldConfig.getFloatValue(WorldCfg.RateRestOfflineInTavernOrCity) : bubble0 * WorldConfig.getFloatValue(WorldCfg.RateRestOfflineInWilderness);

            restMgr.addRestBonus(RestTypes.XP, time_diff * restMgr.calcExtraPerSec(RestTypes.XP, bubble));
        }

        // Unlock battle pet system if it's enabled in bnet account
        if (getSession().getBattlePetMgr().isBattlePetSystemEnabled()) {
            learnSpell(SharedConst.SpellBattlePetTraining, false);
        }

        _AchievementSys.checkAllAchievementCriteria(this);
        questObjectiveCriteriaManager.checkAllQuestObjectiveCriteria(this);

        pushQuests();

        for (var transmogIllusion : CliDB.TransmogIllusionStorage.values()) {
            if (!transmogIllusion.getFlags().hasFlag(TransmogIllusionFlags.PlayerConditionGrantsOnLogin)) {
                continue;
            }

            if (getSession().getCollectionMgr().hasTransmogIllusion(transmogIllusion.id)) {
                continue;
            }

            var playerCondition = CliDB.PlayerConditionStorage.get(transmogIllusion.UnlockConditionID);

            if (playerCondition != null) {
                if (!ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                    continue;
                }
            }

            getSession().getCollectionMgr().addTransmogIllusion(transmogIllusion.id);
        }

        return true;
    }

    public final void saveToDB() {
        saveToDB(false);
    }

    public final void saveToDB(boolean create) {
        SQLTransaction loginTransaction = new SQLTransaction();
        SQLTransaction characterTransaction = new SQLTransaction();

        saveToDB(loginTransaction, characterTransaction, create);

        DB.characters.CommitTransaction(characterTransaction);
        DB.Login.CommitTransaction(loginTransaction);
    }

    public final void saveToDB(SQLTransaction loginTransaction, SQLTransaction characterTransaction) {
        saveToDB(loginTransaction, characterTransaction, false);
    }

    public final void saveToDB(SQLTransaction loginTransaction, SQLTransaction characterTransaction, boolean create) {
        // delay auto save at any saves (manual, in code, or autosave)
        nextSave = WorldConfig.getUIntValue(WorldCfg.IntervalSave);

        //lets allow only players in world to be saved
        if (isBeingTeleportedFar()) {
            scheduleDelayedOperation(PlayerDelayedOperations.SavePlayer);

            return;
        }

        // first save/honor gain after midnight will also update the player's honor fields
        updateHonorFields();

        Log.outDebug(LogFilter.player, String.format("Player::SaveToDB: The second of player %1$s at save: ", getName()));

        if (!create) {
            global.getScriptMgr().<IPlayerOnSave>ForEach(p -> p.OnSave(this));
        }

        PreparedStatement stmt;
        byte index = 0;

        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_FISHINGSTEPS);
        stmt.AddValue(0, getGUID().getCounter());
        characterTransaction.append(stmt);

// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		static float finiteAlways(float f)
//			{
//				return float.IsFinite(f) ? f : 0.0f;
//			}

        if (create) {
            //! Insert query
            /** @todo: Filter out more redundant fields that can take their default second at player create
             */
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER);
            stmt.AddValue(index++, getGUID().getCounter());
            stmt.AddValue(index++, getSession().getAccountId());
            stmt.AddValue(index++, getName());
            stmt.AddValue(index++, (byte) getRace().getValue());
            stmt.AddValue(index++, (byte) getClass().getValue());
            stmt.AddValue(index++, (byte) getNativeGender().getValue()); // save gender from PLAYER_BYTES_3, UNIT_BYTES_0 changes with every transform effect
            stmt.AddValue(index++, getLevel());
            stmt.AddValue(index++, getXP());
            stmt.AddValue(index++, getMoney());
            stmt.AddValue(index++, getInventorySlotCount());
            stmt.AddValue(index++, getBankBagSlotCount());
            stmt.AddValue(index++, getActivePlayerData().restInfo.get(RestTypes.XP.getValue()).stateID);
            stmt.AddValue(index++, getPlayerData().playerFlags);
            stmt.AddValue(index++, getPlayerData().playerFlagsEx);
            stmt.AddValue(index++, (short) getLocation().getMapId());
            stmt.AddValue(index++, getInstanceId());
            stmt.AddValue(index++, (byte) getDungeonDifficultyId().getValue());
            stmt.AddValue(index++, (byte) getRaidDifficultyId().getValue());
            stmt.AddValue(index++, (byte) getLegacyRaidDifficultyId().getValue());
            stmt.AddValue(index++, finiteAlways(getLocation().getX()));
            stmt.AddValue(index++, finiteAlways(getLocation().getY()));
            stmt.AddValue(index++, finiteAlways(getLocation().getZ()));
            stmt.AddValue(index++, finiteAlways(getLocation().getO()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetX()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetY()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetZ()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetO()));
            long transLowGUID = 0;
            var transport = this.<transport>GetTransport();

            if (transport != null) {
                transLowGUID = transport.getGUID().getCounter();
            }

            stmt.AddValue(index++, transLowGUID);

            StringBuilder ss = new StringBuilder();

            synchronized (getTaxi().getTaxiLock()) {
                for (var i = 0; i < getTaxi().taximask.length; ++i) {
                    ss.append(getTaxi().Taximask[i] + " ");
                }
            }

            stmt.AddValue(index++, ss.toString());
            stmt.AddValue(index++, createTime);
            stmt.AddValue(index++, (byte) createMode.getValue());
            stmt.AddValue(index++, cinematic);
            stmt.AddValue(index++, playedTimeTotal);
            stmt.AddValue(index++, playedTimeLevel);
            stmt.AddValue(index++, finiteAlways((float) restMgr.getRestBonus(RestTypes.XP)));
            stmt.AddValue(index++, gameTime.GetGameTime());
            stmt.AddValue(index++, (hasPlayerFlag(playerFlags.Resting) ? 1 : 0));
            //save, far from tavern/city
            //save, but in tavern/city
            stmt.AddValue(index++, getTalentResetCost());
            stmt.AddValue(index++, getTalentResetTime());
            stmt.AddValue(index++, getPrimarySpecialization());
            stmt.AddValue(index++, (short) extraFlags.getValue());
            stmt.AddValue(index++, 0); // summonedPetNumber
            stmt.AddValue(index++, (short) getLoginFlags().getValue());
            stmt.AddValue(index++, deathExpireTime);

            ss.setLength(0);
            ss.append(getTaxi().saveTaxiDestinationsToString());

            stmt.AddValue(index++, ss.toString());
            stmt.AddValue(index++, getActivePlayerData().lifetimeHonorableKills);
            stmt.AddValue(index++, getActivePlayerData().todayHonorableKills);
            stmt.AddValue(index++, getActivePlayerData().yesterdayHonorableKills);
            stmt.AddValue(index++, getPlayerData().playerTitle);
            stmt.AddValue(index++, getActivePlayerData().watchedFactionIndex);
            stmt.AddValue(index++, getDrunkValue());
            stmt.AddValue(index++, getHealth());

            var storedPowers = 0;

            for (Power powerType = 0; powerType.getValue() < powerType.max.getValue(); ++powerType) {
                if (getPowerIndex(powerType) != powerType.max.getValue()) {
                    stmt.AddValue(index++, getUnitData().power.get(storedPowers));

                    if (++storedPowers >= powerType.MaxPerClass.getValue()) {
                        break;
                    }
                }
            }

            for (; storedPowers < powerType.MaxPerClass.getValue(); ++storedPowers) {
                stmt.AddValue(index++, 0);
            }

            stmt.AddValue(index++, getSession().getLatency());
            stmt.AddValue(index++, getActiveTalentGroup());
            stmt.AddValue(index++, getLootSpecId());

            ss.setLength(0);

            for (var i = 0; i < PlayerConst.EXPLOREDZONESSIZE; ++i) {
                ss.append(String.format("%1$s %2$s ", (int) (getActivePlayerData().exploredZones.get(i) & 0xFFFFFFFF), (int) ((getActivePlayerData().exploredZones.get(i) >>> 32) & 0xFFFFFFFF)));
            }

            stmt.AddValue(index++, ss.toString());

            ss.setLength(0);

            // cache equipment...
            for (byte i = 0; i < InventorySlots.ReagentBagEnd; ++i) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    ss.append(String.format("%1$s %2$s ", (int) item.getTemplate().getInventoryType().getValue(), item.getDisplayId(this)));
                    var enchant = CliDB.SpellItemEnchantmentStorage.get(item.getVisibleEnchantmentId(this));

                    if (enchant != null) {
                        ss.append(enchant.itemVisual);
                    } else {
                        ss.append('0');
                    }

                    ss.append(String.format(" %1$s %2$s ", (int) CliDB.ItemStorage.get(item.getVisibleEntry(this)).SubclassID, item.getVisibleSecondaryModifiedAppearanceId(this)));
                } else {
                    ss.append("0 0 0 0 0 ");
                }
            }

            stmt.AddValue(index++, ss.toString());

            ss.setLength(0);

            for (var i = 0; i < getActivePlayerData().knownTitles.size(); ++i) {
                ss.append(String.format("%1$s %2$s ", (int) (getActivePlayerData().knownTitles.get(i) & 0xFFFFFFFF), (int) ((getActivePlayerData().knownTitles.get(i) >>> 32) & 0xFFFFFFFF)));
            }

            stmt.AddValue(index++, ss.toString());

            stmt.AddValue(index++, getActivePlayerData().multiActionBars);
            stmt.AddValue(index++, global.getRealmMgr().GetMinorMajorBugfixVersionForBuild(global.getWorldMgr().getRealm().Build));
        } else {
            // Update query
            stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_CHARACTER);
            stmt.AddValue(index++, getName());
            stmt.AddValue(index++, (byte) getRace().getValue());
            stmt.AddValue(index++, (byte) getClass().getValue());
            stmt.AddValue(index++, (byte) getNativeGender().getValue()); // save gender from PLAYER_BYTES_3, UNIT_BYTES_0 changes with every transform effect
            stmt.AddValue(index++, getLevel());
            stmt.AddValue(index++, getXP());
            stmt.AddValue(index++, getMoney());
            stmt.AddValue(index++, getInventorySlotCount());
            stmt.AddValue(index++, getBankBagSlotCount());
            stmt.AddValue(index++, getActivePlayerData().restInfo.get(RestTypes.XP.getValue()).stateID);
            stmt.AddValue(index++, getPlayerData().playerFlags);
            stmt.AddValue(index++, getPlayerData().playerFlagsEx);

            if (!isBeingTeleported()) {
                stmt.AddValue(index++, (short) getLocation().getMapId());
                stmt.AddValue(index++, getInstanceId());
                stmt.AddValue(index++, (byte) getDungeonDifficultyId().getValue());
                stmt.AddValue(index++, (byte) getRaidDifficultyId().getValue());
                stmt.AddValue(index++, (byte) getLegacyRaidDifficultyId().getValue());
                stmt.AddValue(index++, finiteAlways(getLocation().getX()));
                stmt.AddValue(index++, finiteAlways(getLocation().getY()));
                stmt.AddValue(index++, finiteAlways(getLocation().getZ()));
                stmt.AddValue(index++, finiteAlways(getLocation().getO()));
            } else {
                stmt.AddValue(index++, (short) getTeleportDest().getMapId());
                stmt.AddValue(index++, 0);
                stmt.AddValue(index++, (byte) getDungeonDifficultyId().getValue());
                stmt.AddValue(index++, (byte) getRaidDifficultyId().getValue());
                stmt.AddValue(index++, (byte) getLegacyRaidDifficultyId().getValue());
                stmt.AddValue(index++, finiteAlways(getTeleportDest().getX()));
                stmt.AddValue(index++, finiteAlways(getTeleportDest().getY()));
                stmt.AddValue(index++, finiteAlways(getTeleportDest().getZ()));
                stmt.AddValue(index++, finiteAlways(getTeleportDest().getO()));
            }

            stmt.AddValue(index++, finiteAlways(getTransOffsetX()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetY()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetZ()));
            stmt.AddValue(index++, finiteAlways(getTransOffsetO()));
            long transLowGUID = 0;
            var transport = this.<transport>GetTransport();

            if (transport != null) {
                transLowGUID = transport.getGUID().getCounter();
            }

            stmt.AddValue(index++, transLowGUID);

            StringBuilder ss = new StringBuilder();

            synchronized (getTaxi().getTaxiLock()) {
                for (var i = 0; i < getTaxi().taximask.length; ++i) {
                    ss.append(getTaxi().Taximask[i] + " ");
                }
            }

            stmt.AddValue(index++, ss.toString());
            stmt.AddValue(index++, cinematic);
            stmt.AddValue(index++, playedTimeTotal);
            stmt.AddValue(index++, playedTimeLevel);
            stmt.AddValue(index++, finiteAlways((float) restMgr.getRestBonus(RestTypes.XP)));
            stmt.AddValue(index++, gameTime.GetGameTime());
            stmt.AddValue(index++, (hasPlayerFlag(playerFlags.Resting) ? 1 : 0));
            //save, far from tavern/city
            //save, but in tavern/city
            stmt.AddValue(index++, getTalentResetCost());
            stmt.AddValue(index++, getTalentResetTime());
            stmt.AddValue(index++, getNumRespecs());
            stmt.AddValue(index++, getPrimarySpecialization());
            stmt.AddValue(index++, (short) extraFlags.getValue());
            var petStable = getPetStable1();

            if (petStable != null) {
                stmt.AddValue(index++, petStable.GetCurrentPet() != null && petStable.GetCurrentPet().health > 0 ? petStable.GetCurrentPet().PetNumber : 0); // summonedPetNumber
            } else {
                stmt.AddValue(index++, 0); // summonedPetNumber
            }

            stmt.AddValue(index++, (short) getLoginFlags().getValue());
            stmt.AddValue(index++, getZone());
            stmt.AddValue(index++, deathExpireTime);

            ss.setLength(0);
            ss.append(getTaxi().saveTaxiDestinationsToString());

            stmt.AddValue(index++, ss.toString());
            stmt.AddValue(index++, getActivePlayerData().lifetimeHonorableKills);
            stmt.AddValue(index++, getActivePlayerData().todayHonorableKills);
            stmt.AddValue(index++, getActivePlayerData().yesterdayHonorableKills);
            stmt.AddValue(index++, getPlayerData().playerTitle);
            stmt.AddValue(index++, getActivePlayerData().watchedFactionIndex);
            stmt.AddValue(index++, getDrunkValue());
            stmt.AddValue(index++, getHealth());

            var storedPowers = 0;

            for (Power powerType = 0; powerType.getValue() < powerType.max.getValue(); ++powerType) {
                if (getPowerIndex(powerType) != powerType.max.getValue()) {
                    stmt.AddValue(index++, getUnitData().power.get(storedPowers));

                    if (++storedPowers >= powerType.MaxPerClass.getValue()) {
                        break;
                    }
                }
            }

            for (; storedPowers < powerType.MaxPerClass.getValue(); ++storedPowers) {
                stmt.AddValue(index++, 0);
            }

            stmt.AddValue(index++, getSession().getLatency());
            stmt.AddValue(index++, getActiveTalentGroup());
            stmt.AddValue(index++, getLootSpecId());

            ss.setLength(0);

            for (var i = 0; i < PlayerConst.EXPLOREDZONESSIZE; ++i) {
                ss.append(String.format("%1$s %2$s ", (int) (getActivePlayerData().exploredZones.get(i) & 0xFFFFFFFF), (int) ((getActivePlayerData().exploredZones.get(i) >>> 32) & 0xFFFFFFFF)));
            }

            stmt.AddValue(index++, ss.toString());

            ss.setLength(0);

            // cache equipment...
            for (byte i = 0; i < InventorySlots.ReagentBagEnd; ++i) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    ss.append(String.format("%1$s %2$s ", (int) item.getTemplate().getInventoryType().getValue(), item.getDisplayId(this)));
                    var enchant = CliDB.SpellItemEnchantmentStorage.get(item.getVisibleEnchantmentId(this));

                    if (enchant != null) {
                        ss.append(enchant.itemVisual);
                    } else {
                        ss.append('0');
                    }

                    ss.append(String.format(" %1$s %2$s ", (int) CliDB.ItemStorage.get(item.getVisibleEntry(this)).SubclassID, item.getVisibleSecondaryModifiedAppearanceId(this)));
                } else {
                    ss.append("0 0 0 0 0 ");
                }
            }

            stmt.AddValue(index++, ss.toString());

            ss.setLength(0);

            for (var i = 0; i < getActivePlayerData().knownTitles.size(); ++i) {
                ss.append(String.format("%1$s %2$s ", (int) (getActivePlayerData().knownTitles.get(i) & 0xFFFFFFFF), (int) ((getActivePlayerData().knownTitles.get(i) >>> 32) & 0xFFFFFFFF)));
            }

            stmt.AddValue(index++, ss.toString());
            stmt.AddValue(index++, getActivePlayerData().multiActionBars);

            stmt.AddValue(index++, isInWorld() && !getSession().getPlayerLogout() ? 1 : 0);
            stmt.AddValue(index++, getActivePlayerData().honor);
            stmt.AddValue(index++, getHonorLevel());
            stmt.AddValue(index++, getActivePlayerData().restInfo.get(RestTypes.honor.getValue()).stateID);
            stmt.AddValue(index++, finiteAlways((float) restMgr.getRestBonus(RestTypes.honor)));
            stmt.AddValue(index++, global.getRealmMgr().GetMinorMajorBugfixVersionForBuild(global.getWorldMgr().getRealm().Build));

            // Index
            stmt.AddValue(index, getGUID().getCounter());
        }

        characterTransaction.append(stmt);

        if (fishingSteps != 0) {
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_FISHINGSTEPS);
            index = 0;
            stmt.AddValue(index++, getGUID().getCounter());
            stmt.AddValue(index++, fishingSteps);
            characterTransaction.append(stmt);
        }

        if (getMailsUpdated()) //save mails only when needed
        {
            _SaveMail(characterTransaction);
        }

        _SaveCustomizations(characterTransaction);
        _SaveBGData(characterTransaction);
        _SaveInventory(characterTransaction);
        _SaveVoidStorage(characterTransaction);
        _SaveQuestStatus(characterTransaction);
        _SaveDailyQuestStatus(characterTransaction);
        _SaveWeeklyQuestStatus(characterTransaction);
        _SaveSeasonalQuestStatus(characterTransaction);
        _SaveMonthlyQuestStatus(characterTransaction);
        _SaveGlyphs(characterTransaction);
        _SaveTalents(characterTransaction);
        _SaveTraits(characterTransaction);
        _SaveSpells(characterTransaction);
        getSpellHistory().<Player>SaveToDb(characterTransaction);
        _SaveActions(characterTransaction);
        _SaveAuras(characterTransaction);
        _SaveSkills(characterTransaction);
        _SaveStoredAuraTeleportLocations(characterTransaction);
        _AchievementSys.saveToDB(characterTransaction);
        reputationMgr.saveToDB(characterTransaction);
        questObjectiveCriteriaManager.saveToDB(characterTransaction);
        _SaveEquipmentSets(characterTransaction);
        getSession().saveTutorialsData(characterTransaction); // changed only while character in game
        _SaveInstanceTimeRestrictions(characterTransaction);
        _SaveCurrency(characterTransaction);
        _SaveCUFProfiles(characterTransaction);

        if (garrison != null) {
            garrison.saveToDB(characterTransaction);
        }

        // check if stats should only be saved on logout
        // save stats can be out of transaction
        if (getSession().isLogingOut() || !WorldConfig.getBoolValue(WorldCfg.StatsSaveOnlyOnLogout)) {
            _SaveStats(characterTransaction);
        }

        // TODO: Move this out
        getSession().getCollectionMgr().saveAccountToys(loginTransaction);

        getSession().getBattlePetMgr().saveToDB(loginTransaction);
        getSession().getCollectionMgr().saveAccountHeirlooms(loginTransaction);
        getSession().getCollectionMgr().saveAccountMounts(loginTransaction);
        getSession().getCollectionMgr().saveAccountItemAppearances(loginTransaction);
        getSession().getCollectionMgr().saveAccountTransmogIllusions(loginTransaction);

        stmt = DB.Login.GetPreparedStatement(LoginStatements.DEL_BNET_LAST_PLAYER_CHARACTERS);
        stmt.AddValue(0, getSession().getAccountId());
        stmt.AddValue(1, global.getWorldMgr().getRealmId().Region);
        stmt.AddValue(2, global.getWorldMgr().getRealmId().Site);
        loginTransaction.append(stmt);

        stmt = DB.Login.GetPreparedStatement(LoginStatements.INS_BNET_LAST_PLAYER_CHARACTERS);
        stmt.AddValue(0, getSession().getAccountId());
        stmt.AddValue(1, global.getWorldMgr().getRealmId().Region);
        stmt.AddValue(2, global.getWorldMgr().getRealmId().Site);
        stmt.AddValue(3, global.getWorldMgr().getRealmId().index);
        stmt.AddValue(4, getName());
        stmt.AddValue(5, getGUID().getCounter());
        stmt.AddValue(6, gameTime.GetGameTime());
        loginTransaction.append(stmt);

        // save pet (hunter pet level and experience and all type pets health/mana).
        var pet = getCurrentPet();

        if (pet) {
            pet.SavePetToDB(PetSaveMode.AsCurrent);
        }
    }


    private void _LoadInventory(SQLResult result, SQLResult artifactsResult, SQLResult azeriteResult, SQLResult azeriteItemMilestonePowersResult, SQLResult azeriteItemUnlockedEssencesResult, SQLResult azeriteEmpoweredItemResult, int timeDiff) {
        HashMap<Long, ItemAdditionalLoadInfo> additionalData = new HashMap<Long, ItemAdditionalLoadInfo>();
        ItemAdditionalLoadInfo.init(additionalData, artifactsResult, azeriteResult, azeriteItemMilestonePowersResult, azeriteItemUnlockedEssencesResult, azeriteEmpoweredItemResult);

        if (!result.isEmpty()) {
            var zoneId = getZone();
            HashMap<ObjectGuid, bag> bagMap = new HashMap<ObjectGuid, bag>(); // fast guid lookup for bags
            HashMap<ObjectGuid, item> invalidBagMap = new HashMap<ObjectGuid, item>(); // fast guid lookup for bags
            LinkedList<item> problematicItems = new LinkedList<item>();
            SQLTransaction trans = new SQLTransaction();

            // Prevent items from being added to the queue while loading
            setItemUpdateQueueBlocked(true);

            do {
                var item = _LoadItem(trans, zoneId, timeDiff, result.GetFields());

                if (item != null) {
                    var addionalData = additionalData.get(item.getGUID().getCounter());

                    if (addionalData != null) {
                        if (item.getTemplate().getArtifactID() != 0 && addionalData.artifact != null) {
                            item.loadArtifactData(this, addionalData.artifact.xp, addionalData.artifact.artifactAppearanceId, addionalData.artifact.artifactTierId, addionalData.artifact.artifactPowers);
                        }

                        if (addionalData.azeriteItem != null) {
                            var azeriteItem = item.getAsAzeriteItem();

                            if (azeriteItem != null) {
                                azeriteItem.LoadAzeriteItemData(this, addionalData.azeriteItem);
                            }
                        }

                        if (addionalData.azeriteEmpoweredItem != null) {
                            var azeriteEmpoweredItem = item.getAsAzeriteEmpoweredItem();

                            if (azeriteEmpoweredItem != null) {
                                azeriteEmpoweredItem.LoadAzeriteEmpoweredItemData(this, addionalData.azeriteEmpoweredItem);
                            }
                        }
                    }


                    var counter = result.<Long>Read(51);
                    var bagGuid = counter != 0 ? ObjectGuid.create(HighGuid.Item, counter) : ObjectGuid.Empty;
                    var slot = result.<Byte>Read(52);

                    getSession().getCollectionMgr().checkHeirloomUpgrades(item);
                    getSession().getCollectionMgr().addItemAppearance(item);

                    var err = InventoryResult.Ok;

                    if (item.hasItemFlag(ItemFieldFlags.Child)) {
                        var parent = getItemByGuid(item.getCreator());

                        if (parent) {
                            parent.setChildItem(item.getGUID());
                            item.copyArtifactDataFromParent(parent);
                        } else {
                            Log.outError(LogFilter.player, String.format("Player._LoadInventory: Player '%1$s' (%2$s) has child item (%3$s, entry: %4$s) which can't be loaded into inventory because parent item was not found (Bag %5$s, slot: %6$s). Item will be sent by mail.", getName(), getGUID(), item.getGUID(), item.getEntry(), bagGuid, slot));
                            item.deleteFromInventoryDB(trans);
                            problematicItems.offer(item);

                            continue;
                        }
                    }

                    // Item is not in bag
                    if (bagGuid.isEmpty()) {
                        item.setContainer(null);
                        item.setSlot(slot);

                        if (isInventoryPos(InventorySlots.Bag0, slot)) {
                            ArrayList<ItemPosCount> dest = new ArrayList<>();
                            err = canStoreItem(InventorySlots.Bag0, slot, dest, item, false);

                            if (err == InventoryResult.Ok) {
                                item = storeItem(dest, item, true);
                            }
                        } else if (isEquipmentPos(InventorySlots.Bag0, slot)) {
                            short dest;
                            tangible.OutObject<SHORT> tempOut_dest = new tangible.OutObject<SHORT>();
                            err = canEquipItem(slot, tempOut_dest, item, false, false);
                            dest = tempOut_dest.outArgValue;

                            if (err == InventoryResult.Ok) {
                                quickEquipItem(dest, item);
                            }
                        } else if (isBankPos(InventorySlots.Bag0, slot)) {
                            ArrayList<ItemPosCount> dest = new ArrayList<>();
                            err = canBankItem(InventorySlots.Bag0, slot, dest, item, false, false);

                            if (err == InventoryResult.Ok) {
                                item = bankItem(dest, item, true);
                            }
                        }

                        // Remember bags that may contain items in them
                        if (err == InventoryResult.Ok) {
                            if (isBagPos(item.getPos())) {
                                var pBag = item.getAsBag();

                                if (pBag != null) {
                                    bagMap.put(item.getGUID(), pBag);
                                }
                            }
                        } else if (isBagPos(item.getPos())) {
                            if (item.isBag()) {
                                invalidBagMap.put(item.getGUID(), item);
                            }
                        }
                    } else {
                        item.setSlot(ItemConst.NullSlot);
                        // Item is in the bag, find the bag
                        var bag = bagMap.get(bagGuid);

                        if (bag != null) {
                            ArrayList<ItemPosCount> dest = new ArrayList<>();
                            err = canStoreItem(bag.slot, slot, dest, item);

                            if (err == InventoryResult.Ok) {
                                item = storeItem(dest, item, true);
                            }
                        } else if (invalidBagMap.containsKey(bagGuid)) {
                            var invalidBag = invalidBagMap.get(bagGuid);

                            if (problematicItems.contains(invalidBag)) {
                                err = InventoryResult.InternalBagError;
                            }
                        } else {
                            Log.outError(LogFilter.player, "LoadInventory: player (GUID: {0}, name: '{1}') has item (GUID: {2}, entry: {3}) which doesnt have a valid bag (Bag GUID: {4}, slot: {5}). Possible cheat?", getGUID().toString(), getName(), item.getGUID().toString(), item.getEntry(), bagGuid, slot);

                            item.deleteFromInventoryDB(trans);

                            continue;
                        }
                    }

                    // Item's state may have changed after storing
                    if (err == InventoryResult.Ok) {
                        item.setState(ItemUpdateState.Unchanged, this);
                    } else {
                        Log.outError(LogFilter.player, "LoadInventory: player (GUID: {0}, name: '{1}') has item (GUID: {2}, entry: {3}) which can't be loaded into inventory (Bag GUID: {4}, slot: {5}) by reason {6}. " + "Item will be sent by mail.", getGUID().toString(), getName(), item.getGUID().toString(), item.getEntry(), bagGuid, slot, err);

                        item.deleteFromInventoryDB(trans);
                        problematicItems.offer(item);
                    }
                }
            } while (result.NextRow());

            setItemUpdateQueueBlocked(false);

            // Send problematic items by mail
            while (!problematicItems.isEmpty()) {
                var subject = global.getObjectMgr().getCypherString(CypherStrings.NotEquippedItem);
                MailDraft draft = new MailDraft(subject, "There were problems with equipping item(s).");

                for (var i = 0; !problematicItems.isEmpty() && i < SharedConst.MaxMailItems; ++i) {
                    draft.addItem(problematicItems.poll());
                }

                draft.sendMailTo(trans, this, new MailSender(this, MailStationery.gm), MailCheckMask.Copied);
            }

            DB.characters.CommitTransaction(trans);
        }

        _ApplyAllItemMods();
        // Apply all azerite item mods, azerite empowered item mods will get applied through its spell script
        applyAllAzeriteItemMods(true);
    }


    private Item _LoadItem(SQLTransaction trans, int zoneId, int timeDiff, SQLFields fields) {
        Item item = null;
        var itemGuid = fields.<Long>Read(0);
        var itemEntry = fields.<Integer>Read(1);
        var proto = global.getObjectMgr().getItemTemplate(itemEntry);

        if (proto != null) {
            var remove = false;
            item = item.newItemOrBag(proto);

            if (item.loadFromDB(itemGuid, getGUID(), fields, itemEntry)) {
                PreparedStatement stmt;

                // Do not allow to have item limited to another map/zone in alive state
                if (isAlive() && item.isLimitedToAnotherMapOrZone(getLocation().getMapId(), zoneId)) {
                    Log.outDebug(LogFilter.player, "LoadInventory: player (GUID: {0}, name: '{1}', map: {2}) has item (GUID: {3}, entry: {4}) limited to another map ({5}). Deleting item.", getGUID().toString(), getName(), getLocation().getMapId(), item.getGUID().toString(), item.getEntry(), zoneId);

                    remove = true;
                }
                // "Conjured items disappear if you are logged out for more than 15 minutes"
                else if (timeDiff > 15 * time.Minute && proto.hasFlag(ItemFlags.Conjured)) {
                    Log.outDebug(LogFilter.player, "LoadInventory: player (GUID: {0}, name: {1}, diff: {2}) has conjured item (GUID: {3}, entry: {4}) with expired lifetime (15 minutes). Deleting item.", getGUID().toString(), getName(), timeDiff, item.getGUID().toString(), item.getEntry());

                    remove = true;
                }

                if (item.isRefundable()) {
                    if (item.getPlayedTime() > (2 * time.Hour)) {
                        Log.outDebug(LogFilter.player, "LoadInventory: player (GUID: {0}, name: {1}) has item (GUID: {2}, entry: {3}) with expired refund time ({4}). Deleting refund data and removing " + "efundable flag.", getGUID().toString(), getName(), item.getGUID().toString(), item.getEntry(), item.getPlayedTime());

                        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ITEM_REFUND_INSTANCE);
                        stmt.AddValue(0, item.getGUID().toString());
                        trans.append(stmt);

                        item.removeItemFlag(ItemFieldFlags.refundable);
                    } else {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_ITEM_REFUNDS);
                        stmt.AddValue(0, item.getGUID().getCounter());
                        stmt.AddValue(1, getGUID().getCounter());
                        var result = DB.characters.query(stmt);

                        if (!result.isEmpty()) {
                            item.setRefundRecipient(getGUID());
                            item.setPaidMoney(result.<Long>Read(0));
                            item.setPaidExtendedCost(result.<SHORT>Read(1));
                            addRefundReference(item.getGUID());
                        } else {
                            Log.outDebug(LogFilter.player, "LoadInventory: player (GUID: {0}, name: {1}) has item (GUID: {2}, entry: {3}) with refundable flags, but without data in item_refund_instance. Removing flag.", getGUID().toString(), getName(), item.getGUID().toString(), item.getEntry());

                            item.removeItemFlag(ItemFieldFlags.refundable);
                        }
                    }
                } else if (item.isBOPTradeable()) {
                    stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_ITEM_BOP_TRADE);
                    stmt.AddValue(0, item.getGUID().toString());
                    var result = DB.characters.query(stmt);

                    if (!result.isEmpty()) {
                        var strGUID = result.<String>Read(0);
                        var GUIDlist = new LocalizedString();
                        ArrayList<ObjectGuid> looters = new ArrayList<>();

                        for (var i = 0; i < GUIDlist.length; ++i) {
                            long guid;
                            tangible.OutObject<Long> tempOut_guid = new tangible.OutObject<Long>();
                            if (tangible.TryParseHelper.tryParseLong(GUIDlist.get(i), tempOut_guid)) {
                                guid = tempOut_guid.outArgValue;
                                looters.add(ObjectGuid.create(HighGuid.Item, guid));
                            } else {
                                guid = tempOut_guid.outArgValue;
                            }
                        }

                        if (looters.size() > 1 && item.getTemplate().getMaxStackSize() == 1 && item.isSoulBound()) {
                            item.setSoulboundTradeable(looters);
                            addTradeableItem(item);
                        } else {
                            item.clearSoulboundTradeable(this);
                        }
                    } else {
                        Log.outDebug(LogFilter.ServerLoading, "LoadInventory: player ({0}, name: {1}) has item ({2}, entry: {3}) with ITEM_FLAG_BOP_TRADEABLE flag, " + "but without data in item_soulbound_trade_data. Removing flag.", getGUID().toString(), getName(), item.getGUID().toString(), item.getEntry());

                        item.removeItemFlag(ItemFieldFlags.BopTradeable);
                    }
                } else if (proto.getHolidayID() != 0) {
                    remove = true;
                    var events = global.getGameEventMgr().getEventMap();
                    var activeEventsList = global.getGameEventMgr().getActiveEventList();

                    for (var id : activeEventsList) {
                        if (events[id].holiday_id == proto.getHolidayID()) {
                            remove = false;

                            break;
                        }
                    }
                }
            } else {
                Log.outError(LogFilter.player, "LoadInventory: player (GUID: {0}, name: {1}) has broken item (GUID: {2}, entry: {3}) in inventory. Deleting item.", getGUID().toString(), getName(), itemGuid, itemEntry);

                remove = true;
            }

            // Remove item from inventory if necessary
            if (remove) {
                item.deleteFromInventoryDB(trans, itemGuid);
                item.FSetState(ItemUpdateState.removed);
                item.saveToDB(trans); // it also deletes item object!
                item = null;
            }
        } else {
            Log.outError(LogFilter.player, "LoadInventory: player (GUID: {0}, name: {1}) has unknown item (entry: {2}) in inventory. Deleting item.", getGUID().toString(), getName(), itemEntry);

            item.deleteFromInventoryDB(trans, itemGuid);
            item.deleteFromDB(trans, itemGuid);
            azeriteItem.deleteFromDB(trans, itemGuid);
            azeriteEmpoweredItem.deleteFromDB(trans, itemGuid);
        }

        return item;
    }

    private void _LoadSkills(SQLResult result) {
        var race = getRace();
        int count = 0;
        HashMap<Integer, Integer> loadedSkillValues = new HashMap<Integer, Integer>();
        ArrayList<SHORT> loadedProfessionsWithoutSlot = new ArrayList<>(); // fixup old character

        if (!result.isEmpty()) {
            do {
                if (skillStatus.size() >= SkillConst.MaxPlayerSkills) // client limit
                {
                    Log.outError(LogFilter.player, String.format("Player::_LoadSkills: Player '%1$s' (%2$s) has more than %3$s skills.", getName(), getGUID(), SkillConst.MaxPlayerSkills));

                    break;
                }

                var skill = result.<SHORT>Read(0);
                var value = result.<SHORT>Read(1);
                var max = result.<SHORT>Read(2);
                var professionSlot = result.<Byte>Read(3);

                var rcEntry = global.getDB2Mgr().GetSkillRaceClassInfo(skill, race, getClass());

                if (rcEntry == null) {
                    Log.outError(LogFilter.player, String.format("Player::_LoadSkills: Player '%1$s' (%2$s, Race: %3$s, Class: %4$s) has forbidden skill %5$s for his race/class combination", getName(), getGUID(), race, getClass(), skill));
                    skillStatus.put(skill, new SkillStatusData((int) skillStatus.size(), SkillState.Deleted));

                    continue;
                }

                // set fixed skill ranges
                switch (global.getSpellMgr().getSkillRangeType(rcEntry)) {
                    case Language:
                        value = max = 300;

                        break;
                    case Mono:
                        value = max = 1;

                        break;
                    case Level:
                        max = getMaxSkillValueForLevel();

                        break;
                    default:
                        break;
                }

                if (!skillStatus.containsKey(skill)) {
                    skillStatus.put(skill, new SkillStatusData((int) skillStatus.size(), SkillState.Unchanged));
                }

                var skillStatusData = skillStatus.get(skill);
                short step = 0;

                var skillLine = CliDB.SkillLineStorage.get(rcEntry.SkillID);

                if (skillLine != null) {
                    if (skillLine.categoryID == SkillCategory.Secondary) {
                        step = (short) (max / 75);
                    }

                    if (skillLine.categoryID == SkillCategory.profession) {
                        step = (short) (max / 75);

                        if (skillLine.ParentSkillLineID != 0 && skillLine.ParentTierIndex != 0) {
                            if (professionSlot != -1) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
                                setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().professionSkillLine, professionSlot), skill);
                            } else {
                                loadedProfessionsWithoutSlot.add(skill);
                            }
                        }
                    }
                }

                setSkillLineId(skillStatusData.pos, skill);
                setSkillStep(skillStatusData.pos, step);
                setSkillRank(skillStatusData.pos, value);
                setSkillStartingRank(skillStatusData.pos, (short) 1);
                setSkillMaxRank(skillStatusData.pos, max);
                setSkillTempBonus(skillStatusData.pos, (short) 0);
                setSkillPermBonus(skillStatusData.pos, (short) 0);

                loadedSkillValues.put(skill, value);
            } while (result.NextRow());
        }

        // Learn skill rewarded spells after all skills have been loaded to prevent learning a skill from them before its loaded with proper second from DB
        for (var skill : loadedSkillValues.entrySet()) {
            learnSkillRewardedSpells(skill.getKey(), skill.getValue(), race);
            var childSkillLines = global.getDB2Mgr().GetSkillLinesForParentSkill(skill.getKey());

            if (childSkillLines != null) {
                for (var childItr : childSkillLines) {
                    if (skillStatus.size() >= SkillConst.MaxPlayerSkills) {
                        break;
                    }

                    if (!skillStatus.containsKey(childItr.id)) {
                        setSkillLineId(count, (short) childItr.id);
                        setSkillStartingRank(count, (short) 1);
                        skillStatus.put(childItr.id, new SkillStatusData(count, SkillState.Unchanged));
                    }
                }
            }
        }

        for (var skill : loadedProfessionsWithoutSlot) {
            var emptyProfessionSlot = findEmptyProfessionSlotFor(skill);

            if (emptyProfessionSlot != -1) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
                setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().professionSkillLine, emptyProfessionSlot), skill);
                skillStatus.get(skill).state = SkillState.changed;
            }
        }

        if (hasSkill(SkillType.FistWeapons)) {
            setSkill(SkillType.FistWeapons, 0, getSkillValue(SkillType.Unarmed), getMaxSkillValueForLevel());
        }
    }

    private void _LoadSpells(SQLResult result, SQLResult favoritesResult) {
        if (!result.isEmpty()) {
            do {
                addSpell(result.<Integer>Read(0), result.<Boolean>Read(1), false, false, result.<Boolean>Read(2), true);
            } while (result.NextRow());
        }

        if (!favoritesResult.isEmpty()) {
            do {
                var spell = spells.get(favoritesResult.<Integer>Read(0));

                if (spell != null) {
                    spell.favorite = true;
                }
            } while (favoritesResult.NextRow());
        }
    }


    private void _LoadAuras(SQLResult auraResult, SQLResult effectResult, int timediff) {
        Log.outDebug(LogFilter.player, "Loading auras for player {0}", getGUID().toString());

        ObjectGuid casterGuid = ObjectGuid.EMPTY;
        ObjectGuid itemGuid = ObjectGuid.EMPTY;
        HashMap<AuraKey, AuraLoadEffectInfo> effectInfo = new HashMap<AuraKey, AuraLoadEffectInfo>();

        if (!effectResult.isEmpty()) {
            do {
                int effectIndex = effectResult.<Byte>Read(4);
                casterGuid.SetRawValue(effectResult.<byte[]>Read(0));
                itemGuid.SetRawValue(effectResult.<byte[]>Read(1));

                AuraKey key = new AuraKey(casterGuid, itemGuid, effectResult.<Integer>Read(2), effectResult.<Integer>Read(3));

                if (!effectInfo.containsKey(key)) {
                    effectInfo.put(key, new AuraLoadEffectInfo());
                }

                var info = effectInfo.get(key);
                info.amounts.put(effectIndex, effectResult.<Integer>Read(5));
                info.baseAmounts.put(effectIndex, effectResult.<Integer>Read(6));
            } while (effectResult.NextRow());
        }

        if (!auraResult.isEmpty()) {
            do {
                casterGuid.SetRawValue(auraResult.<byte[]>Read(0));
                itemGuid.SetRawValue(auraResult.<byte[]>Read(1));
                AuraKey key = new AuraKey(casterGuid, itemGuid, auraResult.<Integer>Read(2), auraResult.<Integer>Read(3));
                var recalculateMask = auraResult.<Integer>Read(4);
                var difficulty = Difficulty.forValue(auraResult.<Byte>Read(5));
                var stackCount = auraResult.<Byte>Read(6);
                var maxDuration = auraResult.<Integer>Read(7);
                var remainTime = auraResult.<Integer>Read(8);
                var remainCharges = auraResult.<Byte>Read(9);
                var castItemId = auraResult.<Integer>Read(10);
                var castItemLevel = auraResult.<Integer>Read(11);

                var spellInfo = global.getSpellMgr().getSpellInfo(key.spellId, difficulty);

                if (spellInfo == null) {
                    Log.outError(LogFilter.player, "Unknown aura (spellid {0}), ignore.", key.spellId);

                    continue;
                }

                if (difficulty != Difficulty.NONE && !CliDB.DifficultyStorage.containsKey(difficulty)) {
                    Log.outError(LogFilter.player, String.format("Player._LoadAuras: Player '%1$s' (%2$s) has an invalid aura difficulty %3$s (SpellID: %4$s), ignoring.", getName(), getGUID(), difficulty, key.spellId));

                    continue;
                }

                // negative effects should continue counting down after logout
                if (remainTime != -1 && (!spellInfo.isPositive() || spellInfo.hasAttribute(SpellAttr4.AuraExpiresOffline))) {
                    if (remainTime / time.InMilliseconds <= timediff) {
                        continue;
                    }

                    remainTime -= (int) (timediff * time.InMilliseconds);
                }

                // prevent wrong values of remaincharges
                if (spellInfo.getProcCharges() != 0) {
                    // we have no control over the order of applying auras and modifiers allow auras
                    // to have more charges than second in SpellInfo
                    if (remainCharges <= 0) {
                        remainCharges = (byte) spellInfo.getProcCharges();
                    }
                } else {
                    remainCharges = 0;
                }

                var info = effectInfo.get(key);
                var castId = ObjectGuid.create(HighGuid.Cast, SpellCastSource.NORMAL, getLocation().getMapId(), spellInfo.getId(), getMap().generateLowGuid(HighGuid.Cast));

                AuraCreateInfo createInfo = new AuraCreateInfo(castId, spellInfo, difficulty, system.Extentions.ExplodeMask(key.effectMask, SpellConst.MaxEffects), this);
                createInfo.setCasterGuid(casterGuid);
                createInfo.setBaseAmount(info.baseAmounts);
                createInfo.setCastItem(itemGuid, castItemId, castItemLevel);

                var aura = aura.tryCreate(createInfo);

                if (aura != null) {
                    if (!aura.canBeSaved()) {
                        aura.remove();

                        continue;
                    }

                    aura.setLoadedState(maxDuration, remainTime, remainCharges, stackCount, recalculateMask, info.amounts);
                    aura.applyForTargets();
                    Log.outInfo(LogFilter.player, "Added aura spellid {0}, effectmask {1}", spellInfo.getId(), key.effectMask);
                }
            } while (auraResult.NextRow());
        }
    }

    private boolean _LoadHomeBind(SQLResult result) {
        var info = global.getObjectMgr().getPlayerInfo(getRace(), getClass());

        if (info == null) {
            Log.outError(LogFilter.player, "Player (Name {0}) has incorrect race/class ({1}/{2}) pair. Can't be loaded.", getName(), getRace(), getClass());

            return false;
        }

        var ok = false;

        if (!result.isEmpty()) {
            homeBind.WorldRelocate(result.<Integer>Read(0), result.<Float>Read(2), result.<Float>Read(3), result.<Float>Read(4), result.<Float>Read(5));
            homebindAreaId = result.<Integer>Read(1);

            var map = CliDB.MapStorage.get(homeBind.getMapId());

            // accept saved data only for valid position (and non instanceable), and accessable
            if (MapDefine.isValidMapCoordinatei(homeBind) && !map.Instanceable() && getSession().getExpansion().getValue() >= map.expansion()) {
                ok = true;
            } else {
                var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_PLAYER_HOMEBIND);
                stmt.AddValue(0, getGUID().getCounter());
                DB.characters.execute(stmt);
            }
        }

// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		void saveHomebindToDb()
//			{
//				var stmt = DB.character.GetPreparedStatement(CharStatements.INS_PLAYER_HOMEBIND);
//				stmt.AddValue(0, GUID.counter);
//				stmt.AddValue(1, homebind.mapId);
//				stmt.AddValue(2, homebindAreaId);
//				stmt.AddValue(3, homebind.X);
//				stmt.AddValue(4, homebind.Y);
//				stmt.AddValue(5, homebind.Z);
//				stmt.AddValue(6, homebind.orientation);
//				DB.character.execute(stmt);
//			}

        if (!ok && hasAtLoginFlag(AtLoginFlags.firstLogin)) {
            var createPosition = createMode == PlayerCreateMode.NPE && info.createPositionNpe != null ? info.createPositionNpe.getValue() : info.createPosition;

            if (!createPosition.transportGuid.HasValue) {
                homeBind.WorldRelocate(createPosition.loc);
                homebindAreaId = global.getTerrainMgr().getAreaId(PhasingHandler.EMPTY_PHASE_SHIFT, homeBind);

                saveHomebindToDb();
                ok = true;
            }
        }

        if (!ok) {
            var loc = global.getObjectMgr().getDefaultGraveYard(getTeam());

            if (loc == null && getRace() == race.PandarenNeutral) {
                loc = global.getObjectMgr().getWorldSafeLoc(3295); // The Wandering Isle, Starting Area GY
            }

            homeBind.WorldRelocate(loc.loc);
            homebindAreaId = global.getTerrainMgr().getAreaId(PhasingHandler.EMPTY_PHASE_SHIFT, loc.loc);

            saveHomebindToDb();
        }

        Log.outDebug(LogFilter.player, String.format("Setting player home position - mapid: %1$s, areaid: %2$s, %3$s", homeBind.getMapId(), homebindAreaId, homeBind));

        return true;
    }

    private void _LoadCurrency(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        do {
            var currencyID = result.<SHORT>Read(0);

            var currency = CliDB.CurrencyTypesStorage.get(currencyID);

            if (currency == null) {
                continue;
            }

            PlayerCurrency cur = new PlayerCurrency();
            cur.setState(PlayerCurrencyState.Unchanged);
            cur.setQuantity(result.<Integer>Read(1));
            cur.setWeeklyQuantity(result.<Integer>Read(2));
            cur.setTrackedQuantity(result.<Integer>Read(3));
            cur.setIncreasedCapQuantity(result.<Integer>Read(4));
            cur.setEarnedQuantity(result.<Integer>Read(5));
            cur.setFlags(CurrencyDbFlags.forValue(result.<Byte>Read(6)));

            currencyStorage.put(currencyID, cur);
        } while (result.NextRow());
    }

    private void loadActions(SQLResult result) {
        _LoadActions(result);

        sendActionButtons(1);
    }

    private void _LoadActions(SQLResult result) {
        actionButtons.clear();

        if (!result.isEmpty()) {
            do {
                var button = result.<Byte>Read(0);
                var action = result.<Long>Read(1);
                var type = result.<Byte>Read(2);

                var ab = addActionButton(button, action, type);

                if (ab != null) {
                    ab.UState = ActionButtonUpdateState.UnChanged;
                } else {
                    Log.outError(LogFilter.player, String.format("Player::_LoadActions: Player '%1$s' (%2$s) has an invalid action button (Button: %3$s, Action: %4$s, Type: %5$s). It will be deleted at next save. This can be due to a player changing their talents.", getName(), getGUID(), button, action, type));

                    // Will deleted in DB at next save (it can create data until save but marked as deleted)
                    actionButtons.put(button, new ActionButton());
                    actionButtons.get(button).UState = ActionButtonUpdateState.Deleted;
                }
            } while (result.NextRow());
        }
    }

    private void _LoadQuestStatus(SQLResult result) {
        short slot = 0;

        if (!result.isEmpty()) {
            do {
                var questId = result.<Integer>Read(0);
                // used to be new, no delete?
                var quest = global.getObjectMgr().getQuestTemplate(questId);

                if (quest != null) {
                    // find or create
                    QuestStatusData questStatusData = new QuestStatusData();

                    var qstatus = result.<Byte>Read(1);

                    if (qstatus < (byte) QuestStatus.max.getValue()) {
                        questStatusData.status = QuestStatus.forValue(qstatus);
                    } else {
                        questStatusData.status = QuestStatus.INCOMPLETE;

                        Log.outError(LogFilter.player, "Player {0} (GUID: {1}) has invalid quest {2} status ({3}), replaced by QUEST_STATUS_INCOMPLETE(3).", getName(), getGUID().toString(), questId, qstatus);
                    }

                    questStatusData.explored = result.<Byte>Read(2) > 0;

                    var acceptTime = result.<Long>Read(3);
                    var endTime = result.<Long>Read(4);

                    if (quest.limitTime != 0 && !getQuestRewardStatus(questId)) {
                        addTimedQuest(questId);

                        if (endTime <= gameTime.GetGameTime()) {
                            questStatusData.timer = 1;
                        } else {
                            questStatusData.timer = (int) ((endTime - gameTime.GetGameTime()) * time.InMilliseconds);
                        }
                    } else {
                        endTime = 0;
                    }

                    // add to quest log
                    if (slot < SharedConst.MaxQuestLogSize && questStatusData.status != QuestStatus.NONE) {
                        questStatusData.slot = slot;

                        for (var obj : quest.objectives) {
                            QuestObjectiveStatusData tempVar = new QuestObjectiveStatusData();
                            tempVar.questStatusPair = (questId, questStatusData)
                            tempVar.objective = obj;
                            _questObjectiveStatus.add((obj.type, obj.objectID), tempVar)
                        }

                        setQuestSlot(slot, questId);
                        setQuestSlotEndTime(slot, endTime);
                        setQuestSlotAcceptTime(slot, acceptTime);

                        if (questStatusData.status == QuestStatus.Complete) {
                            setQuestSlotState(slot, QuestSlotStateMask.Complete);
                        } else if (questStatusData.status == QuestStatus.Failed) {
                            setQuestSlotState(slot, QuestSlotStateMask.Fail);
                        }

                        ++slot;
                    }

                    mQuestStatus.put(questId, questStatusData);
                    Log.outDebug(LogFilter.ServerLoading, "Quest status is {0} for quest {1} for player (GUID: {2})", questStatusData.status, questId, getGUID().toString());
                }
            } while (result.NextRow());
        }

        // clear quest log tail
        for (var i = slot; i < SharedConst.MaxQuestLogSize; ++i) {
            setQuestSlot(i, 0);
        }
    }

    private void _LoadQuestStatusObjectives(SQLResult result) {
        if (!result.isEmpty()) {
            do {
                var questID = result.<Integer>Read(0);

                var quest = global.getObjectMgr().getQuestTemplate(questID);

                var questStatusData = mQuestStatus.get(questID);

                if (questStatusData != null && questStatusData.slot < SharedConst.MaxQuestLogSize && quest != null) {
                    var storageIndex = result.<Byte>Read(1);

                    var objective = quest.objectives.FirstOrDefault(objective -> objective.storageIndex == storageIndex);

                    if (objective != null) {
                        var data = result.<Integer>Read(2);

                        if (!objective.isStoringFlag()) {
                            setQuestSlotCounter(questStatusData.slot, storageIndex, (short) data);
                        } else if (data != 0) {
                            setQuestSlotObjectiveFlag(questStatusData.slot, (byte) storageIndex);
                        }
                    } else {
                        Log.outError(LogFilter.player, String.format("Player %1$s (%2$s) has quest %3$s out of range objective index %4$s.", getName(), getGUID(), questID, storageIndex));
                    }
                } else {
                    Log.outError(LogFilter.player, String.format("Player %1$s (%2$s) does not have quest %3$s but has objective data for it.", getName(), getGUID(), questID));
                }
            } while (result.NextRow());
        }
    }

    private void _LoadQuestStatusRewarded(SQLResult result) {
        if (!result.isEmpty()) {
            do {
                var quest_id = result.<Integer>Read(0);
                // used to be new, no delete?
                var quest = global.getObjectMgr().getQuestTemplate(quest_id);

                if (quest != null) {
                    // learn rewarded spell if unknown
                    learnQuestRewardedSpells(quest);

                    // set rewarded title if any
                    if (quest.getRewardTitleId() != 0) {
                        var titleEntry = CliDB.CharTitlesStorage.get(quest.getRewardTitleId());

                        if (titleEntry != null) {
                            setTitle(titleEntry);
                        }
                    }

                    // Skip loading special quests - they are also added to rewarded quests but only once and remain there forever
                    // instead add them separately from load daily/weekly/monthly/seasonal
                    if (!quest.isDailyOrWeekly() && !quest.isMonthly() && !quest.isSeasonal()) {
                        var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(quest_id);

                        if (questBit != 0) {
                            setQuestCompletedBit(questBit, true);
                        }
                    }

                    for (int i = 0; i < quest.getRewChoiceItemsCount(); ++i) {
                        getSession().getCollectionMgr().addItemAppearance(quest.RewardChoiceItemId[i]);
                    }

                    for (int i = 0; i < quest.getRewItemsCount(); ++i) {
                        getSession().getCollectionMgr().addItemAppearance(quest.RewardItemId[i]);
                    }

                    var questPackageItems = global.getDB2Mgr().GetQuestPackageItems(quest.packageID);

                    if (questPackageItems != null) {
                        for (var questPackageItem : questPackageItems) {
                            var rewardProto = global.getObjectMgr().getItemTemplate(questPackageItem.itemID);

                            if (rewardProto != null) {
                                if (rewardProto.getItemSpecClassMask().hasFlag(getClassMask())) {
                                    getSession().getCollectionMgr().addItemAppearance(questPackageItem.itemID);
                                }
                            }
                        }
                    }

                    if (quest.canIncreaseRewardedQuestCounters()) {
                        rewardedQuests.add(quest_id);
                    }
                }
            } while (result.NextRow());
        }
    }

    private void _LoadDailyQuestStatus(SQLResult result) {
        dfQuests.clear();

        //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time FROM character_queststatus_daily WHERE guid = '{0}'");
        if (!result.isEmpty()) {
            do {
                var quest_id = result.<Integer>Read(0);
                var qQuest = global.getObjectMgr().getQuestTemplate(quest_id);

                if (qQuest != null) {
                    if (qQuest.isDFQuest()) {
                        dfQuests.add(qQuest.id);
                        lastDailyQuestTime = result.<Integer>Read(1);

                        continue;
                    }
                }

                // save _any_ from daily quest times (it must be after last reset anyway)
                lastDailyQuestTime = result.<Long>Read(1);

                var quest = global.getObjectMgr().getQuestTemplate(quest_id);

                if (quest == null) {
                    continue;
                }

                addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().dailyQuestsCompleted), quest_id);
                var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(quest_id);

                if (questBit != 0) {
                    setQuestCompletedBit(questBit, true);
                }

                Log.outDebug(LogFilter.player, "Daily quest ({0}) cooldown for player (GUID: {1})", quest_id, getGUID().toString());
            } while (result.NextRow());
        }

        dailyQuestChanged = false;
    }

    private void _LoadWeeklyQuestStatus(SQLResult result) {
        weeklyquests.clear();

        if (!result.isEmpty()) {
            do {
                var quest_id = result.<Integer>Read(0);
                var quest = global.getObjectMgr().getQuestTemplate(quest_id);

                if (quest == null) {
                    continue;
                }

                weeklyquests.add(quest_id);
                var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(quest_id);

                if (questBit != 0) {
                    setQuestCompletedBit(questBit, true);
                }

                Log.outDebug(LogFilter.player, "Weekly quest {0} cooldown for player (GUID: {1})", quest_id, getGUID().toString());
            } while (result.NextRow());
        }

        weeklyQuestChanged = false;
    }

    private void _LoadSeasonalQuestStatus(SQLResult result) {
        seasonalquests.clear();

        if (!result.isEmpty()) {
            do {
                var quest_id = result.<Integer>Read(0);
                var event_id = result.<Integer>Read(1);
                var completedTime = result.<Long>Read(2);
                var quest = global.getObjectMgr().getQuestTemplate(quest_id);

                if (quest == null) {
                    continue;
                }

                if (!seasonalquests.containsKey(event_id)) {
                    seasonalquests.put(event_id, new HashMap<Integer, Long>());
                }

                seasonalquests.get(event_id).put(quest_id, completedTime);

                var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(quest_id);

                if (questBit != 0) {
                    setQuestCompletedBit(questBit, true);
                }

                Log.outDebug(LogFilter.player, "Seasonal quest {0} cooldown for player (GUID: {1})", quest_id, getGUID().toString());
            } while (result.NextRow());
        }

        seasonalQuestChanged = false;
    }

    private void _LoadMonthlyQuestStatus() {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHARACTER_QUESTSTATUS_MONTHLY);
        stmt.AddValue(0, getGUID().getCounter());
        var result = DB.characters.query(stmt);

        monthlyquests.clear();

        if (!result.isEmpty()) {
            do {
                var quest_id = result.<Integer>Read(0);
                var quest = global.getObjectMgr().getQuestTemplate(quest_id);

                if (quest == null) {
                    continue;
                }

                monthlyquests.add(quest_id);
                var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(quest_id);

                if (questBit != 0) {
                    setQuestCompletedBit(questBit, true);
                }

                Log.outDebug(LogFilter.player, "Monthly quest {0} cooldown for player (GUID: {1})", quest_id, getGUID().toString());
            } while (result.NextRow());
        }

        monthlyQuestChanged = false;
    }

    private void _LoadTalents(SQLResult result) {
        if (!result.isEmpty()) {
            do {
                var talent = CliDB.TalentStorage.get(result.<Integer>Read(0));

                if (talent != null) {
                    addTalent(talent, result.<Byte>Read(1), false);
                }
            } while (result.NextRow());
        }
    }

    private void _LoadPvpTalents(SQLResult result) {
        // "SELECT talentID0, talentID1, talentID2, talentID3, talentGroup FROM character_pvp_talent WHERE guid = ?"
        if (!result.isEmpty()) {
            do {
                for (byte slot = 0; slot < PlayerConst.MaxPvpTalentSlots; ++slot) {
                    var talent = CliDB.PvpTalentStorage.get(result.<Integer>Read(slot));

                    if (talent != null) {
                        addPvpTalent(talent, result.<Byte>Read(4), slot);
                    }
                }
            } while (result.NextRow());
        }
    }

    private void _LoadTraits(SQLResult configsResult, SQLResult entriesResult) {
        MultiMap<Integer, TraitEntryPacket> traitEntriesByConfig = new MultiMap<Integer, TraitEntryPacket>();

        if (!entriesResult.isEmpty()) {
            //                    0            1,                2     3             4
            // SELECT traitConfigId, traitNodeId, traitNodeEntryId, rank, grantedRanks FROM character_trait_entry WHERE guid = ?
            do {
                TraitEntryPacket traitEntry = new TraitEntryPacket();
                traitEntry.traitNodeID = entriesResult.<Integer>Read(1);
                traitEntry.traitNodeEntryID = entriesResult.<Integer>Read(2);
                traitEntry.rank = entriesResult.<Integer>Read(3);
                traitEntry.grantedRanks = entriesResult.<Integer>Read(4);

                if (!TraitMgr.isValidEntry(traitEntry)) {
                    continue;
                }

                traitEntriesByConfig.add(entriesResult.<Integer>Read(0), traitEntry);
            } while (entriesResult.NextRow());
        }

        if (!configsResult.isEmpty()) {
            //                    0     1                    2                  3                4            5              6      7
            // SELECT traitConfigId, type, chrSpecializationId, combatConfigFlags, localIdentifier, skillLineId, traitSystemId, `name` FROM character_trait_config WHERE guid = ?
            do {
                TraitConfigPacket traitConfig = new traitConfigPacket();
                traitConfig.ID = configsResult.<Integer>Read(0);
                traitConfig.type = TraitConfigType.forValue(configsResult.<Integer>Read(1));

                switch (traitConfig.type) {
                    case Combat:
                        traitConfig.chrSpecializationID = configsResult.<Integer>Read(2);
                        traitConfig.combatConfigFlags = TraitCombatConfigFlags.forValue(configsResult.<Integer>Read(3));
                        traitConfig.localIdentifier = configsResult.<Integer>Read(4);

                        break;
                    case Profession:
                        traitConfig.skillLineID = configsResult.<Integer>Read(5);

                        break;
                    case Generic:
                        traitConfig.traitSystemID = configsResult.<Integer>Read(6);

                        break;
                    default:
                        break;
                }

                traitConfig.name = configsResult.<String>Read(7);

                for (var traitEntry : traitEntriesByConfig.get(traitConfig.ID)) {
                    traitConfig.addEntry(traitEntry);
                }

                if (TraitMgr.validateConfig(traitConfig, this) != TalentLearnResult.LearnOk) {
                    traitConfig.entries.clear();

                    for (var grantedEntry : TraitMgr.getGrantedTraitEntriesForConfig(traitConfig, this)) {
                        traitConfig.addEntry(new TraitEntryPacket(grantedEntry));
                    }
                }

                addTraitConfig(traitConfig);
            } while (configsResult.NextRow());
        }

// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		bool hasConfigForSpec(int specId)
//			{
//				return activePlayerData.traitConfigs.FindIndexIf(traitConfig =>
//				{
//					return traitConfig.type == (int)TraitConfigType.Combat && traitConfig.chrSpecializationID == specId && (traitConfig.combatConfigFlags & (int)TraitCombatConfigFlags.ActiveForSpec) != 0;
//				}
//				) >= 0;
//			}

// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		int findFreeLocalIdentifier(int specId)
//			{
//				var index = 1;
//
//				while (activePlayerData.traitConfigs.FindIndexIf(traitConfig => { return traitConfig.type == (int)TraitConfigType.Combat && traitConfig.chrSpecializationID == specId && traitConfig.localIdentifier == index; }) >= 0)
//					++index;
//
//				return index;
//			}

        for (int i = 0; i < PlayerConst.MaxSpecializations - 1; ++i) {
            var spec = global.getDB2Mgr().GetChrSpecializationByIndex(getClass(), i);

            if (spec != null) {
                if (hasConfigForSpec((int) spec.id)) {
                    continue;
                }

                TraitConfigPacket traitConfig = new traitConfigPacket();
                traitConfig.type = TraitConfigType.Combat;
                traitConfig.chrSpecializationID = (int) spec.id;
                traitConfig.combatConfigFlags = TraitCombatConfigFlags.ActiveForSpec;
                traitConfig.localIdentifier = findFreeLocalIdentifier((int) spec.id);
                traitConfig.name = spec.name.charAt(getSession().getSessionDbcLocale());

                createTraitConfig(traitConfig);
            }
        }

        var activeConfig = getActivePlayerData().traitConfigs.FindIndexIf(traitConfig ->
        {
            return traitConfig.type == TraitConfigType.Combat.getValue() && traitConfig.chrSpecializationID == getPrimarySpecialization() && (traitConfig.combatConfigFlags & TraitCombatConfigFlags.ActiveForSpec.getValue()) != 0;
        });

        if (activeConfig >= 0) {
            setActiveCombatTraitConfigID(getActivePlayerData().traitConfigs.get(activeConfig).ID);
        }

        for (var traitConfig : getActivePlayerData().traitConfigs) {
            switch (TraitConfigType.forValue((int) traitConfig.type)) {
                case Combat:
                    if (traitConfig.ID != getActivePlayerData().activeCombatTraitConfigID) {
                        continue;
                    }

                    break;
                case Profession:
                    if (!hasSkill((int) traitConfig.skillLineID)) {
                        continue;
                    }

                    break;
                default:
                    break;
            }

            applyTraitConfig(traitConfig.ID, true);
        }
    }

    private void _LoadGlyphs(SQLResult result) {
        // SELECT talentGroup, glyphId from character_glyphs WHERE guid = ?
        if (result.isEmpty()) {
            return;
        }

        do {
            var spec = result.<Byte>Read(0);

            if (spec >= PlayerConst.MaxSpecializations || global.getDB2Mgr().GetChrSpecializationByIndex(getClass(), spec) == null) {
                continue;
            }

            var glyphId = result.<SHORT>Read(1);

            if (!CliDB.GlyphPropertiesStorage.containsKey(glyphId)) {
                continue;
            }

            getGlyphs(spec).add(glyphId);
        } while (result.NextRow());
    }

    private void _LoadGlyphAuras() {
        for (var glyphId : getGlyphs(getActiveTalentGroup())) {
            castSpell(this, CliDB.GlyphPropertiesStorage.get(glyphId).spellID, true);
        }
    }

    private void _LoadVoidStorage(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        do {
            // SELECT itemId, itemEntry, slot, creatorGuid, randomBonusListId, fixedScalingLevel, artifactKnowledgeLevel, context, bonusListIDs FROM character_void_storage WHERE playerGuid = ?
            var itemId = result.<Long>Read(0);
            var itemEntry = result.<Integer>Read(1);
            var slot = result.<Byte>Read(2);
            var creatorGuid = result.<Long>Read(3) != 0 ? ObjectGuid.create(HighGuid.Player, result.<Long>Read(3)) : ObjectGuid.Empty;
            var randomBonusListId = result.<Integer>Read(4);
            var fixedScalingLevel = result.<Integer>Read(5);
            var artifactKnowledgeLevel = result.<Integer>Read(6);
            var context = itemContext.forValue(result.<Byte>Read(7));
            ArrayList<Integer> bonusListIDs = new ArrayList<>();
            var bonusListIdTokens = new LocalizedString();

            for (var i = 0; i < bonusListIdTokens.length; ++i) {
                int id;
                tangible.OutObject<Integer> tempOut_id = new tangible.OutObject<Integer>();
                if (tangible.TryParseHelper.tryParseInt(bonusListIdTokens.get(i), tempOut_id)) {
                    id = tempOut_id.outArgValue;
                    bonusListIDs.add(id);
                } else {
                    id = tempOut_id.outArgValue;
                }
            }

            if (itemId == 0) {
                Log.outError(LogFilter.player, "Player:_LoadVoidStorage - player (GUID: {0}, name: {1}) has an item with an invalid id (item id: item id: {2}, entry: {3}).", getGUID().toString(), getName(), itemId, itemEntry);

                continue;
            }

            if (global.getObjectMgr().getItemTemplate(itemEntry) == null) {
                Log.outError(LogFilter.player, "Player:_LoadVoidStorage - player (GUID: {0}, name: {1}) has an item with an invalid entry (item id: item id: {2}, entry: {3}).", getGUID().toString(), getName(), itemId, itemEntry);

                continue;
            }

            if (slot >= SharedConst.VoidStorageMaxSlot) {
                Log.outError(LogFilter.player, "Player:_LoadVoidStorage - player (GUID: {0}, name: {1}) has an item with an invalid slot (item id: item id: {2}, entry: {3}, slot: {4}).", getGUID().toString(), getName(), itemId, itemEntry, slot);

                continue;
            }

            _voidStorageItems[slot] = new VoidStorageItem(itemId, itemEntry, creatorGuid, randomBonusListId, fixedScalingLevel, artifactKnowledgeLevel, context, bonusListIDs);

            BonusData bonus = new bonusData(new itemInstance(_voidStorageItems[slot]));
            getSession().getCollectionMgr().addItemAppearance(itemEntry, bonus.appearanceModID);
        } while (result.NextRow());
    }

    private void _LoadDeclinedNames(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        declinedname = new declinedName();

        for (byte i = 0; i < SharedConst.MaxDeclinedNameCases; ++i) {
            declinedname.name.charAt(i) = result.<String>Read(i);
        }
    }

    private void _LoadArenaTeamInfo(SQLResult result) {
        // arenateamid, played_week, played_season, personal_rating
        short[] personalRatingCache = {0, 0, 0};

        if (!result.isEmpty()) {
            do {
                var arenaTeamId = result.<Integer>Read(0);

                var arenaTeam = global.getArenaTeamMgr().getArenaTeamById(arenaTeamId);

                if (arenaTeam == null) {
                    Log.outError(LogFilter.player, "Player:_LoadArenaTeamInfo: couldn't load arenateam {0}", arenaTeamId);

                    continue;
                }

                var arenaSlot = arenaTeam.getSlot();

                personalRatingCache[arenaSlot] = result.<SHORT>Read(4);

                setArenaTeamInfoField(arenaSlot, ArenaTeamInfoType.id, arenaTeamId);
                setArenaTeamInfoField(arenaSlot, ArenaTeamInfoType.type, arenaTeam.getArenaType());
                setArenaTeamInfoField(arenaSlot, ArenaTeamInfoType.member, (int) (Objects.equals(arenaTeam.getCaptain(), getGUID()) ? 0 : 1));
                setArenaTeamInfoField(arenaSlot, ArenaTeamInfoType.GamesWeek, result.<SHORT>Read(1));
                setArenaTeamInfoField(arenaSlot, ArenaTeamInfoType.GamesSeason, result.<SHORT>Read(2));
                setArenaTeamInfoField(arenaSlot, ArenaTeamInfoType.WinsSeason, result.<SHORT>Read(3));
            } while (result.NextRow());
        }

        for (byte slot = 0; slot <= 2; ++slot) {
            setArenaTeamInfoField(slot, ArenaTeamInfoType.personalRating, personalRatingCache[slot]);
        }
    }

    private void _LoadStoredAuraTeleportLocations(SQLResult result) {
        //                                                       0      1      2          3          4          5
        //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, mapId, positionX, positionY, positionZ, Orientation FROM character_spell_location WHERE guid = ?", GetGUIDLow());

        storedAuraTeleportLocations.clear();

        if (!result.isEmpty()) {
            do {
                var spellId = result.<Integer>Read(0);

                if (!global.getSpellMgr().hasSpellInfo(spellId, Difficulty.NONE)) {
                    Log.outError(LogFilter.spells, String.format("Player._LoadStoredAuraTeleportLocations: Player %1$s (%2$s) spell (ID: %3$s) does not exist", getName(), getGUID(), spellId));

                    continue;
                }

                WorldLocation location = new worldLocation(result.<Integer>Read(1), result.<Float>Read(2), result.<Float>Read(3), result.<Float>Read(4), result.<Float>Read(5));

                if (!MapDefine.isValidMapCoordinatei(location)) {
                    Log.outError(LogFilter.spells, String.format("Player._LoadStoredAuraTeleportLocations: Player %1$s (%2$s) spell (ID: %3$s) has invalid position on map %4$s, %5$s.", getName(), getGUID(), spellId, location.getMapId(), location));

                    continue;
                }

                StoredAuraTeleportLocation storedLocation = new StoredAuraTeleportLocation();
                storedLocation.setLoc(location);
                storedLocation.setCurrentState(StoredAuraTeleportLocation.state.Unchanged);

                storedAuraTeleportLocations.put(spellId, storedLocation);
            } while (result.NextRow());
        }
    }

    private void _LoadGroup(SQLResult result) {
        if (!result.isEmpty()) {
            var group = global.getGroupMgr().getGroupByDbStoreId(result.<Integer>Read(0));

            if (group) {
                if (group.isLeader(getGUID())) {
                    setPlayerFlag(playerFlags.GroupLeader);
                }

                var subgroup = group.getMemberGroup(getGUID());
                setGroup(group, subgroup);
                setPartyType(group.getGroupCategory(), GroupType.NORMAL);
                resetGroupUpdateSequenceIfNeeded(group);

                // the group leader may change the instance difficulty while the player is offline
                setDungeonDifficultyId(group.getDungeonDifficultyID());
                setRaidDifficultyId(group.getRaidDifficultyID());
                setLegacyRaidDifficultyId(group.getLegacyRaidDifficultyID());
            }
        }

        if (!getGroup() || !getGroup().isLeader(getGUID())) {
            removePlayerFlag(playerFlags.GroupLeader);
        }
    }

    private void _LoadInstanceTimeRestrictions(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        do {
            instanceResetTimes.put(result.<Integer>Read(0), result.<Long>Read(1));
        } while (result.NextRow());
    }

    private void _LoadEquipmentSets(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        do {
            EquipmentSetInfo eqSet = new EquipmentSetInfo();
            eqSet.getData().setGuid(result.<Long>Read(0));
            eqSet.getData().setType(EquipmentSetInfo.EquipmentSetType.Equipment);
            eqSet.getData().setId(result.<Byte>Read(1));
            eqSet.getData().setName(result.<String>Read(2));
            eqSet.getData().setIcon(result.<String>Read(3));
            eqSet.getData().setIgnoreMask(result.<Integer>Read(4));
            eqSet.getData().setAssignedSpecIndex(result.<Integer>Read(5));
            eqSet.setState(EquipmentSetUpdateState.Unchanged);

            for (int i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                long guid = result.<Integer>Read(6 + i);

                if (guid != 0) {
                    eqSet.getData().getPieces()[i] = ObjectGuid.create(HighGuid.Item, guid);
                }
            }

            if (eqSet.getData().getSetId() >= ItemConst.MaxEquipmentSetIndex) // client limit
            {
                continue;
            }

            equipmentSets.put(eqSet.getData().getGuid(), eqSet);
        } while (result.NextRow());
    }

    private void _LoadTransmogOutfits(SQLResult result) {
        //             0         1     2         3            4            5            6            7            8            9
        //SELECT setguid, setindex, name, iconname, ignore_mask, appearance0, appearance1, appearance2, appearance3, appearance4,
        //             10           11           12           13           14            15            16            17            18            19            20            21
        //    appearance5, appearance6, appearance7, appearance8, appearance9, appearance10, appearance11, appearance12, appearance13, appearance14, appearance15, appearance16,
        //              22            23               24              25
        //    appearance17, appearance18, mainHandEnchant, offHandEnchant FROM character_transmog_outfits WHERE guid = ? ORDER BY setindex
        if (result.isEmpty()) {
            return;
        }

        do {
            EquipmentSetInfo eqSet = new EquipmentSetInfo();

            eqSet.getData().setGuid(result.<Long>Read(0));
            eqSet.getData().setType(EquipmentSetInfo.EquipmentSetType.transmog);
            eqSet.getData().setId(result.<Byte>Read(1));
            eqSet.getData().setName(result.<String>Read(2));
            eqSet.getData().setIcon(result.<String>Read(3));
            eqSet.getData().setIgnoreMask(result.<Integer>Read(4));
            eqSet.setState(EquipmentSetUpdateState.Unchanged);

            for (int i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                eqSet.getData().getAppearances()[i] = result.<Integer>Read(5 + i);
            }

            for (var i = 0; i < eqSet.getData().getEnchants().length; ++i) {
                eqSet.getData().getEnchants()[i] = result.<Integer>Read(24 + i);
            }

            if (eqSet.getData().getSetId() >= ItemConst.MaxEquipmentSetIndex) // client limit
            {
                continue;
            }

            equipmentSets.put(eqSet.getData().getGuid(), eqSet);
        } while (result.NextRow());
    }

    private void _LoadCUFProfiles(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        do {
            var id = result.<Byte>Read(0);
            var name = result.<String>Read(1);
            var frameHeight = result.<SHORT>Read(2);
            var frameWidth = result.<SHORT>Read(3);
            var sortBy = result.<Byte>Read(4);
            var healthText = result.<Byte>Read(5);
            var boolOptions = result.<Integer>Read(6);
            var topPoint = result.<Byte>Read(7);
            var bottomPoint = result.<Byte>Read(8);
            var leftPoint = result.<Byte>Read(9);
            var topOffset = result.<SHORT>Read(10);
            var bottomOffset = result.<SHORT>Read(11);
            var leftOffset = result.<SHORT>Read(12);

            if (id > PlayerConst.MaxCUFProfiles) {
                Log.outError(LogFilter.player, "Player._LoadCUFProfiles - player (GUID: {0}, name: {1}) has an CUF profile with invalid id (id: {2}), max is {3}.", getGUID().toString(), getName(), id, PlayerConst.MaxCUFProfiles);

                continue;
            }

            _cufProfiles[id] = new CufProfile(name, frameHeight, frameWidth, sortBy, healthText, boolOptions, topPoint, bottomPoint, leftPoint, topOffset, bottomOffset, leftOffset);
        } while (result.NextRow());
    }

    private void _LoadRandomBGStatus(SQLResult result) {
        if (!result.isEmpty()) {
            isBgRandomWinner = true;
        }
    }

    private void _LoadBGData(SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        // Expecting only one row
        //        0           1     2      3      4      5      6          7          8        9
        // SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell FROM character_Battleground_data WHERE guid = ?
        bgData.setBgInstanceId(result.<Integer>Read(0));
        bgData.setBgTeam(result.<SHORT>Read(1));
        bgData.setJoinPos(new worldLocation(result.<SHORT>Read(6), result.<Float>Read(2), result.<Float>Read(3), result.<Float>Read(4), result.<Float>Read(5)));
        bgData.getTaxiPath()[0] = result.<Integer>Read(7);
        bgData.getTaxiPath()[1] = result.<Integer>Read(8);
        bgData.setMountSpell(result.<Integer>Read(9));
    }


    private void _LoadPetStable(int summonedPetNumber, SQLResult result) {
        if (result.isEmpty()) {
            return;
        }

        petStable = new PetStable();

        //         0      1        2      3    4           5     6     7        8          9       10      11        12              13       14              15
        // SELECT id, entry, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, createdBySpell, PetType, specialization FROM character_pet WHERE owner = ?
        if (!result.isEmpty()) {
            do {
                PetStable.PetInfo petInfo = new PetStable.petInfo();
                petInfo.petNumber = result.<Integer>Read(0);
                petInfo.creatureId = result.<Integer>Read(1);
                petInfo.displayId = result.<Integer>Read(2);
                petInfo.level = result.<Byte>Read(3);
                petInfo.experience = result.<Integer>Read(4);
                petInfo.reactState = ReactStates.forValue(result.<Byte>Read(5));
                var slot = PetSaveMode.forValue(result.<SHORT>Read(6));
                petInfo.name = result.<String>Read(7);
                petInfo.WasRenamed = result.<Boolean>Read(8);
                petInfo.health = result.<Integer>Read(9);
                petInfo.mana = result.<Integer>Read(10);
                petInfo.ActionBar = result.<String>Read(11);
                petInfo.LastSaveTime = result.<Integer>Read(12);
                petInfo.CreatedBySpellId = result.<Integer>Read(13);
                petInfo.type = PetType.forValue(result.<Byte>Read(14));
                petInfo.specializationId = result.<SHORT>Read(15);

                if (slot.getValue() >= PetSaveMode.FirstActiveSlot.getValue() && slot.getValue() < PetSaveMode.LastActiveSlot.getValue()) {
                    petStable.ActivePets[slot.getValue()] = petInfo;
                } else if (slot.getValue() >= PetSaveMode.FirstStableSlot.getValue() && slot.getValue() < PetSaveMode.LastStableSlot.getValue()) {
                    petStable.StabledPets[slot - PetSaveMode.FirstStableSlot] = petInfo;
                } else if (slot == PetSaveMode.NotInSlot) {
                    petStable.UnslottedPets.add(petInfo);
                }
            } while (result.NextRow());
        }

        if (pet.GetLoadPetInfo(petStable, 0, summonedPetNumber, null).Item1 != null) {
            temporaryUnsummonedPetNumber = summonedPetNumber;
        }
    }

    private void _SaveInventory(SQLTransaction trans) {
        PreparedStatement stmt;

        // force items in buyback slots to new state
        // and remove those that aren't already
        for (var i = InventorySlots.BuyBackStart; i < InventorySlots.BuyBackEnd; ++i) {
            var item = _items[i];

            if (item == null) {
                continue;
            }

            var itemTemplate = item.getTemplate();

            if (item.getState() == ItemUpdateState.New) {
                if (itemTemplate != null) {
                    if (itemTemplate.hasFlag(ItemFlags.HasLoot)) {
                        global.getLootItemStorage().removeStoredLootForContainer(item.getGUID().getCounter());
                    }
                }

                continue;
            }

            item.deleteFromInventoryDB(trans);
            item.deleteFromDB(trans);
            _items[i].FSetState(ItemUpdateState.New);

            if (itemTemplate != null) {
                if (itemTemplate.hasFlag(ItemFlags.HasLoot)) {
                    global.getLootItemStorage().removeStoredLootForContainer(item.getGUID().getCounter());
                }
            }
        }

        // Updated played time for refundable items. We don't do this in player.Update because there's simply no need for it,
        // the client auto counts down in real time after having received the initial played time on the first
        // SMSG_ITEM_REFUND_INFO_RESPONSE packet.
        // item.UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
        for (var guid : refundableItems) {
            var item = getItemByGuid(guid);

            if (item != null) {
                item.updatePlayedTime(this);

                continue;
            } else {
                Log.outError(LogFilter.player, "Can't find item guid {0} but is in refundable storage for player {1} ! Removing.", guid, getGUID().toString());
                refundableItems.remove(guid);
            }
        }

        // update enchantment durations
        for (var enchant : enchantDurations) {
            enchant.getItem().setEnchantmentDuration(enchant.getSlot(), enchant.getLeftduration(), this);
        }

        // if no changes
        if (getItemUpdateQueue().isEmpty()) {
            return;
        }

        for (var i = 0; i < getItemUpdateQueue().size(); ++i) {
            var item = getItemUpdateQueue().get(i);

            if (item == null) {
                continue;
            }

            var container = item.getContainer();

            if (item.getState() != ItemUpdateState.removed) {
                var test = getItemByPos(item.getBagSlot(), item.getSlot());

                if (test == null) {
                    long bagTestGUID = 0;
                    var test2 = getItemByPos(InventorySlots.Bag0, item.getBagSlot());

                    if (test2 != null) {
                        bagTestGUID = test2.getGUID().getCounter();
                    }

                    Log.outError(LogFilter.player, "Player(GUID: {0} Name: {1}).SaveInventory - the bag({2}) and slot({3}) values for the item with guid {4} (state {5}) are incorrect, " + "the player doesn't have an item at that position!", getGUID().toString(), getName(), item.getBagSlot(), item.getSlot(), item.getGUID().toString(), item.getState());

                    // according to the test that was just performed nothing should be in this slot, delete
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_INVENTORY_BY_BAG_SLOT);
                    stmt.AddValue(0, bagTestGUID);
                    stmt.AddValue(1, item.getSlot());
                    stmt.AddValue(2, getGUID().getCounter());
                    trans.append(stmt);

                    removeTradeableItem(item);
                    removeEnchantmentDurationsReferences(item);
                    removeItemDurations(item);

                    // also THIS item should be somewhere else, cheat attempt
                    item.FSetState(ItemUpdateState.removed); // we are IN updateQueue right now, can't use SetState which modifies the queue
                    deleteRefundReference(item.getGUID());
                } else if (test != item) {
                    Log.outError(LogFilter.player, "Player(GUID: {0} Name: {1}).SaveInventory - the bag({2}) and slot({3}) values for the item with guid {4} are incorrect, " + "the item with guid {5} is there instead!", getGUID().toString(), getName(), item.getBagSlot(), item.getSlot(), item.getGUID().toString(), test.getGUID().toString());

                    // save all changes to the item...
                    if (item.getState() != ItemUpdateState.New) // only for existing items, no dupes
                    {
                        item.saveToDB(trans);
                    }

                    // ...but do not save position in inventory
                    continue;
                }
            }

            switch (item.getState()) {
                case New:
                case Changed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.REP_INVENTORY_ITEM);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, container ? container.getGUID().getCounter() : 0);
                    stmt.AddValue(2, item.getSlot());
                    stmt.AddValue(3, item.getGUID().getCounter());
                    trans.append(stmt);

                    break;
                case Removed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_INVENTORY_BY_ITEM);
                    stmt.AddValue(0, item.getGUID().getCounter());
                    trans.append(stmt);

                    break;
                case Unchanged:
                    break;
            }

            item.saveToDB(trans); // item have unchanged inventory record and can be save standalone
        }

        getItemUpdateQueue().clear();
    }

    private void _SaveSkills(SQLTransaction trans) {
        PreparedStatement stmt; // = null;

        SkillInfo skillInfoField = getActivePlayerData().skill;

        for (var pair : skillStatus.ToList()) {
            if (pair.value.state == SkillState.Unchanged) {
                continue;
            }

            var value = skillInfoField.skillRank.get(pair.value.pos);
            var max = skillInfoField.skillMaxRank.get(pair.value.pos);
            var professionSlot = (byte) getProfessionSlotFor(pair.key);

            switch (pair.value.state) {
                case SkillState.New:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_SKILLS);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, (short) pair.key);
                    stmt.AddValue(2, value);
                    stmt.AddValue(3, max);
                    stmt.AddValue(4, professionSlot);
                    trans.append(stmt);

                    break;
                case SkillState.Changed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_CHAR_SKILLS);
                    stmt.AddValue(0, value);
                    stmt.AddValue(1, max);
                    stmt.AddValue(2, professionSlot);
                    stmt.AddValue(3, getGUID().getCounter());
                    stmt.AddValue(4, (short) pair.key);
                    trans.append(stmt);

                    break;
                case SkillState.Deleted:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SKILL_BY_SKILL);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, pair.key);
                    trans.append(stmt);

                    break;
                default:
                    break;
            }

            pair.value.state = SkillState.Unchanged;
        }
    }

    private void _SaveSpells(SQLTransaction trans) {
        PreparedStatement stmt;

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(id, spell) : spells.ToList()) {
            if (spell.state == PlayerSpellState.removed || spell.state == PlayerSpellState.changed) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SPELL_BY_SPELL);
                stmt.AddValue(0, id);
                stmt.AddValue(1, getGUID().getCounter());
                trans.append(stmt);
            }

            if (spell.state == PlayerSpellState.New || spell.state == PlayerSpellState.changed) {
                // add only changed/new not dependent spells
                if (!spell.dependent) {
                    stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_SPELL);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, id);
                    stmt.AddValue(2, spell.active);
                    stmt.AddValue(3, spell.disabled);
                    trans.append(stmt);
                }

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_SPELL_FAVORITE);
                stmt.AddValue(0, id);
                stmt.AddValue(1, getGUID().getCounter());
                trans.append(stmt);

                if (spell.favorite) {
                    stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_SPELL_FAVORITE);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, id);
                    trans.append(stmt);
                }
            }

            if (spell.state == PlayerSpellState.removed) {
                spells.remove(id);

                continue;
            }

            if (spell.state != PlayerSpellState.Temporary) {
                spell.state = PlayerSpellState.Unchanged;
            }
        }
    }

    private void _SaveAuras(SQLTransaction trans) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_AURA_EFFECT);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_AURA);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        byte index;

        for (var aura : getAuraQuery().canBeSaved().getResults()) {
            int recalculateMask;
            tangible.OutObject<Integer> tempOut_recalculateMask = new tangible.OutObject<Integer>();
            var key = aura.generateKey(tempOut_recalculateMask);
            recalculateMask = tempOut_recalculateMask.outArgValue;

            index = 0;
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_AURA);
            stmt.AddValue(index++, getGUID().getCounter());
            stmt.AddValue(index++, key.caster.GetRawValue());
            stmt.AddValue(index++, key.item.GetRawValue());
            stmt.AddValue(index++, key.spellId);
            stmt.AddValue(index++, key.effectMask);
            stmt.AddValue(index++, recalculateMask);
            stmt.AddValue(index++, (byte) aura.getCastDifficulty().getValue());
            stmt.AddValue(index++, aura.getStackAmount());
            stmt.AddValue(index++, aura.getMaxDuration());
            stmt.AddValue(index++, aura.getDuration());
            stmt.AddValue(index++, aura.getCharges());
            stmt.AddValue(index++, aura.getCastItemId());
            stmt.AddValue(index, aura.getCastItemLevel());
            trans.append(stmt);

            for (var effect : aura.getAuraEffects().entrySet()) {
                index = 0;
                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_AURA_EFFECT);
                stmt.AddValue(index++, getGUID().getCounter());
                stmt.AddValue(index++, key.caster.GetRawValue());
                stmt.AddValue(index++, key.item.GetRawValue());
                stmt.AddValue(index++, key.spellId);
                stmt.AddValue(index++, key.effectMask);
                stmt.AddValue(index++, effect.getValue().effIndex);
                stmt.AddValue(index++, effect.getValue().amount);
                stmt.AddValue(index++, effect.getValue().baseAmount);
                trans.append(stmt);
            }
        }
    }

    private void _SaveGlyphs(SQLTransaction trans) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_GLYPHS);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        for (byte spec = 0; spec < PlayerConst.MaxSpecializations; ++spec) {
            for (var glyphId : getGlyphs(spec)) {
                byte index = 0;

                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_GLYPHS);
                stmt.AddValue(index++, getGUID().getCounter());
                stmt.AddValue(index++, spec);
                stmt.AddValue(index++, glyphId);

                trans.append(stmt);
            }
        }
    }

    private void _SaveCurrency(SQLTransaction trans) {
        PreparedStatement stmt;

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(id, currency) : currencyStorage) {
            var entry = CliDB.CurrencyTypesStorage.get(id);

            if (entry == null) // should never happen
            {
                continue;
            }

            switch (currency.state) {
                case PlayerCurrencyState.New:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.REP_PLAYER_CURRENCY);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, id);
                    stmt.AddValue(2, currency.quantity);
                    stmt.AddValue(3, currency.weeklyQuantity);
                    stmt.AddValue(4, currency.trackedQuantity);
                    stmt.AddValue(5, currency.increasedCapQuantity);
                    stmt.AddValue(6, currency.earnedQuantity);
                    stmt.AddValue(7, (byte) currency.flags);
                    trans.append(stmt);

                    break;
                case PlayerCurrencyState.Changed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_PLAYER_CURRENCY);
                    stmt.AddValue(0, currency.quantity);
                    stmt.AddValue(1, currency.weeklyQuantity);
                    stmt.AddValue(2, currency.trackedQuantity);
                    stmt.AddValue(3, currency.increasedCapQuantity);
                    stmt.AddValue(4, currency.earnedQuantity);
                    stmt.AddValue(5, (byte) currency.flags);
                    stmt.AddValue(6, getGUID().getCounter());
                    stmt.AddValue(7, id);
                    trans.append(stmt);

                    break;
                default:
                    break;
            }

            currency.state = PlayerCurrencyState.Unchanged;
        }
    }

    private void _SaveCustomizations(SQLTransaction trans) {
        if (!customizationsChanged) {
            return;
        }

        customizationsChanged = false;

        savePlayerCustomizations(trans, getGUID().getCounter(), getPlayerData().customizations);
    }

    private void _SaveActions(SQLTransaction trans) {
        var traitConfigId = 0;

        var traitConfig = getTraitConfig((int) getActivePlayerData().activeCombatTraitConfigID);

        if (traitConfig != null) {
            var usedSavedTraitConfigIndex = getActivePlayerData().traitConfigs.FindIndexIf(savedConfig ->
            {
                return TraitConfigType.forValue((int) savedConfig.type) == TraitConfigType.Combat && (TraitCombatConfigFlags.forValue((int) savedConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) == TraitCombatConfigFlags.NONE.getValue() && (TraitCombatConfigFlags.forValue((int) savedConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.SharedActionBars.getValue()) == TraitCombatConfigFlags.NONE.getValue() && savedConfig.localIdentifier == traitConfig.localIdentifier;
            });

            if (usedSavedTraitConfigIndex >= 0) {
                traitConfigId = getActivePlayerData().traitConfigs.get(usedSavedTraitConfigIndex).ID;
            }
        }

        PreparedStatement stmt;

        for (var pair : actionButtons.ToList()) {
            switch (pair.value.UState) {
                case ActionButtonUpdateState.New:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_ACTION);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, getActiveTalentGroup());
                    stmt.AddValue(2, traitConfigId);
                    stmt.AddValue(3, pair.key);
                    stmt.AddValue(4, pair.value.getAction());
                    stmt.AddValue(5, (byte) pair.value.getButtonType());
                    trans.append(stmt);

                    pair.value.UState = ActionButtonUpdateState.UnChanged;

                    break;
                case ActionButtonUpdateState.Changed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_CHAR_ACTION);
                    stmt.AddValue(0, pair.value.getAction());
                    stmt.AddValue(1, (byte) pair.value.getButtonType());
                    stmt.AddValue(2, getGUID().getCounter());
                    stmt.AddValue(3, pair.key);
                    stmt.AddValue(4, getActiveTalentGroup());
                    stmt.AddValue(5, traitConfigId);
                    trans.append(stmt);

                    pair.value.UState = ActionButtonUpdateState.UnChanged;

                    break;
                case ActionButtonUpdateState.Deleted:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_ACTION_BY_BUTTON_SPEC);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, pair.key);
                    stmt.AddValue(2, getActiveTalentGroup());
                    stmt.AddValue(3, traitConfigId);
                    trans.append(stmt);

                    actionButtons.remove(pair.key);

                    break;
                default:
                    break;
            }
        }
    }

    private void _SaveQuestStatus(SQLTransaction trans) {
        var isTransaction = trans != null;

        if (!isTransaction) {
            trans = new SQLTransaction();
        }

        PreparedStatement stmt;
        var keepAbandoned = !global.getWorldMgr().getCleaningFlags().hasFlag(CleaningFlags.QUESTSTATUS);

        for (var save : questStatusSave.entrySet()) {
            if (save.getValue() == QuestSaveType.Default) {
                var data = mQuestStatus.get(save.getKey());

                if (data != null && (keepAbandoned || data.status != QuestStatus.NONE)) {
                    stmt = DB.characters.GetPreparedStatement(CharStatements.REP_CHAR_QUESTSTATUS);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, save.getKey());
                    stmt.AddValue(2, (byte) data.status);
                    stmt.AddValue(3, data.explored);
                    stmt.AddValue(4, (long) getQuestSlotAcceptTime(data.slot));
                    stmt.AddValue(5, (long) getQuestSlotEndTime(data.slot));
                    trans.append(stmt);

                    // Save objectives
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS_OBJECTIVES_BY_QUEST);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, save.getKey());
                    trans.append(stmt);

                    var quest = global.getObjectMgr().getQuestTemplate(save.getKey());

                    for (var obj : quest.objectives) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.REP_CHAR_QUESTSTATUS_OBJECTIVES);
                        stmt.AddValue(0, getGUID().getCounter());
                        stmt.AddValue(1, save.getKey());
                        stmt.AddValue(2, obj.storageIndex);
                        stmt.AddValue(3, getQuestSlotObjectiveData(data.slot, obj));
                        trans.append(stmt);
                    }
                }
            } else {
                // Delete
                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS_BY_QUEST);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, save.getKey());
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS_OBJECTIVES_BY_QUEST);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, save.getKey());
                trans.append(stmt);
            }
        }

        questStatusSave.clear();

        for (var save : rewardedQuestsSave.entrySet()) {
            if (save.getValue() == QuestSaveType.Default) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_QUESTSTATUS_REWARDED);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, save.getKey());
                trans.append(stmt);
            } else if (save.getValue() == QuestSaveType.ForceDelete || !keepAbandoned) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, save.getKey());
                trans.append(stmt);
            }
        }

        rewardedQuestsSave.clear();

        if (!isTransaction) {
            DB.characters.CommitTransaction(trans);
        }
    }

    private void _SaveDailyQuestStatus(SQLTransaction trans) {
        if (!dailyQuestChanged) {
            return;
        }

        dailyQuestChanged = false;

        // save last daily quest time for all quests: we need only mostly reset time for reset check anyway

        // we don't need transactions here.
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_DAILY);
        stmt.AddValue(0, getGUID().getCounter());

        for (int questId : getActivePlayerData().dailyQuestsCompleted) {
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_QUESTSTATUS_DAILY);
            stmt.AddValue(0, getGUID().getCounter());
            stmt.AddValue(1, questId);
            stmt.AddValue(2, lastDailyQuestTime);
            trans.append(stmt);
        }

        if (!dfQuests.isEmpty()) {
            for (var id : dfQuests) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_QUESTSTATUS_DAILY);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, id);
                stmt.AddValue(2, lastDailyQuestTime);
                trans.append(stmt);
            }
        }
    }

    private void _SaveWeeklyQuestStatus(SQLTransaction trans) {
        if (!weeklyQuestChanged || weeklyquests.isEmpty()) {
            return;
        }

        // we don't need transactions here.
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_WEEKLY);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        for (var quest_id : weeklyquests) {
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_QUESTSTATUS_WEEKLY);
            stmt.AddValue(0, getGUID().getCounter());
            stmt.AddValue(1, quest_id);
            trans.append(stmt);
        }

        weeklyQuestChanged = false;
    }

    private void _SaveSeasonalQuestStatus(SQLTransaction trans) {
        if (!seasonalQuestChanged) {
            return;
        }

        // we don't need transactions here.
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_SEASONAL);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        seasonalQuestChanged = false;

        if (seasonalquests.isEmpty()) {
            return;
        }

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(eventId, dictionary) : seasonalquests) {
// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(questId, completedTime) : dictionary) {
                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_QUESTSTATUS_SEASONAL);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, questId);
                stmt.AddValue(2, eventId);
                stmt.AddValue(3, completedTime);
                trans.append(stmt);
            }
        }
    }

    private void _SaveMonthlyQuestStatus(SQLTransaction trans) {
        if (!monthlyQuestChanged || monthlyquests.isEmpty()) {
            return;
        }

        // we don't need transactions here.
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_QUESTSTATUS_MONTHLY);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        for (var questId : monthlyquests) {
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_QUESTSTATUS_MONTHLY);
            stmt.AddValue(0, getGUID().getCounter());
            stmt.AddValue(1, questId);
            trans.append(stmt);
        }

        monthlyQuestChanged = false;
    }

    private void _SaveTalents(SQLTransaction trans) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TALENT);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        for (byte group = 0; group < PlayerConst.MaxSpecializations; ++group) {
            var talents = getTalentMap(group);

            for (var pair : talents.ToList()) {
                if (pair.value == PlayerSpellState.removed) {
                    talents.remove(pair.key);

                    continue;
                }

                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_TALENT);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, pair.key);
                stmt.AddValue(2, group);
                trans.append(stmt);
            }
        }

        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_PVP_TALENT);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        for (byte group = 0; group < PlayerConst.MaxSpecializations; ++group) {
            var talents = getPvpTalentMap(group);
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_PVP_TALENT);
            stmt.AddValue(0, getGUID().getCounter());
            stmt.AddValue(1, talents[0]);
            stmt.AddValue(2, talents[1]);
            stmt.AddValue(3, talents[2]);
            stmt.AddValue(4, talents[3]);
            stmt.AddValue(5, group);
            trans.append(stmt);
        }
    }

    private void _SaveTraits(SQLTransaction trans) {
        PreparedStatement stmt = null;

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(traitConfigId, state) : traitConfigStates) {
            switch (state) {
                case PlayerSpellState.Changed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRAIT_ENTRIES);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, traitConfigId);
                    trans.append(stmt);

                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRAIT_CONFIGS);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, traitConfigId);
                    trans.append(stmt);

                    var traitConfig = getTraitConfig(traitConfigId);

                    if (traitConfig != null) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_TRAIT_CONFIGS);
                        stmt.AddValue(0, getGUID().getCounter());
                        stmt.AddValue(1, traitConfig.ID);
                        stmt.AddValue(2, traitConfig.type);

                        switch (TraitConfigType.forValue((int) traitConfig.type)) {
                            case Combat:
                                stmt.AddValue(3, traitConfig.chrSpecializationID);
                                stmt.AddValue(4, traitConfig.combatConfigFlags);
                                stmt.AddValue(5, traitConfig.localIdentifier);
                                stmt.AddNull(6);
                                stmt.AddNull(7);

                                break;
                            case Profession:
                                stmt.AddNull(3);
                                stmt.AddNull(4);
                                stmt.AddNull(5);
                                stmt.AddValue(6, traitConfig.skillLineID);
                                stmt.AddNull(7);

                                break;
                            case Generic:
                                stmt.AddNull(3);
                                stmt.AddNull(4);
                                stmt.AddNull(5);
                                stmt.AddNull(6);
                                stmt.AddValue(7, traitConfig.traitSystemID);

                                break;
                            default:
                                break;
                        }

                        stmt.AddValue(8, traitConfig.name);
                        trans.append(stmt);

                        for (var traitEntry : traitConfig.entries) {
                            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_TRAIT_ENTRIES);
                            stmt.AddValue(0, getGUID().getCounter());
                            stmt.AddValue(1, traitConfig.ID);
                            stmt.AddValue(2, traitEntry.traitNodeID);
                            stmt.AddValue(3, traitEntry.traitNodeEntryID);
                            stmt.AddValue(4, traitEntry.rank);
                            stmt.AddValue(5, traitEntry.grantedRanks);
                            trans.append(stmt);
                        }
                    }

                    break;
                case PlayerSpellState.Removed:
                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRAIT_ENTRIES);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, traitConfigId);
                    trans.append(stmt);

                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_TRAIT_CONFIGS);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, traitConfigId);
                    trans.append(stmt);

                    stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_ACTION_BY_TRAIT_CONFIG);
                    stmt.AddValue(0, getGUID().getCounter());
                    stmt.AddValue(1, traitConfigId);
                    trans.append(stmt);

                    break;
                default:
                    break;
            }
        }

        traitConfigStates.clear();
    }

    private void _SaveStoredAuraTeleportLocations(SQLTransaction trans) {
        for (var pair : storedAuraTeleportLocations.ToList()) {
            var storedLocation = pair.value;

            if (storedLocation.currentState == StoredAuraTeleportLocation.state.Deleted) {
                var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_AURA_STORED_LOCATION);
                stmt.AddValue(0, getGUID().getCounter());
                trans.append(stmt);
                storedAuraTeleportLocations.remove(pair.key);

                continue;
            }

            if (storedLocation.currentState == StoredAuraTeleportLocation.state.changed) {
                var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHARACTER_AURA_STORED_LOCATION);
                stmt.AddValue(0, getGUID().getCounter());
                trans.append(stmt);

                stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHARACTER_AURA_STORED_LOCATION);
                stmt.AddValue(0, getGUID().getCounter());
                stmt.AddValue(1, pair.key);
                stmt.AddValue(2, storedLocation.loc.mapId);
                stmt.AddValue(3, storedLocation.loc.X);
                stmt.AddValue(4, storedLocation.loc.Y);
                stmt.AddValue(5, storedLocation.loc.Z);
                stmt.AddValue(6, storedLocation.loc.orientation);
                trans.append(stmt);
            }
        }
    }

    private void _SaveStats(SQLTransaction trans) {
        // check if stat saving is enabled and if char level is high enough
        if (WorldConfig.getIntValue(WorldCfg.MinLevelStatSave) == 0 || getLevel() < WorldConfig.getIntValue(WorldCfg.MinLevelStatSave)) {
            return;
        }

        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_STATS);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        byte index = 0;
        stmt = DB.characters.GetPreparedStatement(CharStatements.INS_CHAR_STATS);
        stmt.AddValue(index++, getGUID().getCounter());
        stmt.AddValue(index++, getMaxHealth());

        for (byte i = 0; i < powerType.MaxPerClass.getValue(); ++i) {
            stmt.AddValue(index++, getUnitData().maxPower.get(i));
        }

        for (byte i = 0; i < stats.max.getValue(); ++i) {
            stmt.AddValue(index++, getStat(stats.forValue(i)));
        }

        for (var i = 0; i < SpellSchools.max.getValue(); ++i) {
            stmt.AddValue(index++, getResistance(SpellSchools.forValue(i)));
        }

        stmt.AddValue(index++, getActivePlayerData().blockPercentage);
        stmt.AddValue(index++, getActivePlayerData().dodgePercentage);
        stmt.AddValue(index++, getActivePlayerData().parryPercentage);
        stmt.AddValue(index++, getActivePlayerData().critPercentage);
        stmt.AddValue(index++, getActivePlayerData().rangedCritPercentage);
        stmt.AddValue(index++, getActivePlayerData().spellCritPercentage);
        stmt.AddValue(index++, getUnitData().attackPower);
        stmt.AddValue(index++, getUnitData().rangedAttackPower);
        stmt.AddValue(index++, getBaseSpellPowerBonus());
        stmt.AddValue(index, getActivePlayerData().combatRatings.get(CombatRating.ResiliencePlayerDamage.getValue()));

        trans.append(stmt);
    }

    private void _SaveEquipmentSets(SQLTransaction trans) {
        for (var pair : equipmentSets.entrySet()) {
            var eqSet = pair.getValue();
            PreparedStatement stmt;
            byte j = 0;

            switch (eqSet.state) {
                case EquipmentSetUpdateState.Unchanged:
                    break; // do nothing
                case EquipmentSetUpdateState.Changed:
                    if (eqSet.data.type == EquipmentSetInfo.EquipmentSetType.Equipment) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_EQUIP_SET);
                        stmt.AddValue(j++, eqSet.data.setName);
                        stmt.AddValue(j++, eqSet.data.setIcon);
                        stmt.AddValue(j++, eqSet.data.ignoreMask);
                        stmt.AddValue(j++, eqSet.data.assignedSpecIndex);

                        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                            stmt.AddValue(j++, eqSet.data.Pieces[i].counter);
                        }

                        stmt.AddValue(j++, getGUID().getCounter());
                        stmt.AddValue(j++, eqSet.data.guid);
                        stmt.AddValue(j, eqSet.data.setId);
                    } else {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.UPD_TRANSMOG_OUTFIT);
                        stmt.AddValue(j++, eqSet.data.setName);
                        stmt.AddValue(j++, eqSet.data.setIcon);
                        stmt.AddValue(j++, eqSet.data.ignoreMask);

                        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                            stmt.AddValue(j++, eqSet.data.Appearances[i]);
                        }

                        for (var i = 0; i < eqSet.data.enchants.length; ++i) {
                            stmt.AddValue(j++, eqSet.data.Enchants[i]);
                        }

                        stmt.AddValue(j++, getGUID().getCounter());
                        stmt.AddValue(j++, eqSet.data.guid);
                        stmt.AddValue(j, eqSet.data.setId);
                    }

                    trans.append(stmt);
                    eqSet.state = EquipmentSetUpdateState.Unchanged;

                    break;
                case EquipmentSetUpdateState.New:
                    if (eqSet.data.type == EquipmentSetInfo.EquipmentSetType.Equipment) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.INS_EQUIP_SET);
                        stmt.AddValue(j++, getGUID().getCounter());
                        stmt.AddValue(j++, eqSet.data.guid);
                        stmt.AddValue(j++, eqSet.data.setId);
                        stmt.AddValue(j++, eqSet.data.setName);
                        stmt.AddValue(j++, eqSet.data.setIcon);
                        stmt.AddValue(j++, eqSet.data.ignoreMask);
                        stmt.AddValue(j++, eqSet.data.assignedSpecIndex);

                        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                            stmt.AddValue(j++, eqSet.data.Pieces[i].counter);
                        }
                    } else {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.INS_TRANSMOG_OUTFIT);
                        stmt.AddValue(j++, getGUID().getCounter());
                        stmt.AddValue(j++, eqSet.data.guid);
                        stmt.AddValue(j++, eqSet.data.setId);
                        stmt.AddValue(j++, eqSet.data.setName);
                        stmt.AddValue(j++, eqSet.data.setIcon);
                        stmt.AddValue(j++, eqSet.data.ignoreMask);

                        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                            stmt.AddValue(j++, eqSet.data.Appearances[i]);
                        }

                        for (var i = 0; i < eqSet.data.enchants.length; ++i) {
                            stmt.AddValue(j++, eqSet.data.Enchants[i]);
                        }
                    }

                    trans.append(stmt);
                    eqSet.state = EquipmentSetUpdateState.Unchanged;

                    break;
                case EquipmentSetUpdateState.Deleted:
                    if (eqSet.data.type == EquipmentSetInfo.EquipmentSetType.Equipment) {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_EQUIP_SET);
                    } else {
                        stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_TRANSMOG_OUTFIT);
                    }

                    stmt.AddValue(0, eqSet.data.guid);
                    trans.append(stmt);
                    equipmentSets.remove(pair.getKey());

                    break;
            }
        }
    }

    private void _SaveVoidStorage(SQLTransaction trans) {
        PreparedStatement stmt;

        for (byte i = 0; i < SharedConst.VoidStorageMaxSlot; ++i) {
            if (_voidStorageItems[i] == null) // unused item
            {
                // DELETE FROM void_storage WHERE slot = ? AND playerGuid = ?
                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_VOID_STORAGE_ITEM_BY_SLOT);
                stmt.AddValue(0, i);
                stmt.AddValue(1, getGUID().getCounter());
            } else {
                // REPLACE INTO character_void_storage (itemId, playerGuid, itemEntry, slot, creatorGuid, randomPropertyType, randomProperty, upgradeId, fixedScalingLevel, artifactKnowledgeLevel, bonusListIDs) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                stmt = DB.characters.GetPreparedStatement(CharStatements.REP_CHAR_VOID_STORAGE_ITEM);
                stmt.AddValue(0, _voidStorageItems[i].getItemId());
                stmt.AddValue(1, getGUID().getCounter());
                stmt.AddValue(2, _voidStorageItems[i].getItemEntry());
                stmt.AddValue(3, i);
                stmt.AddValue(4, _voidStorageItems[i].getCreatorGuid().getCounter());
                stmt.AddValue(5, (byte) _voidStorageItems[i].getRandomBonusListId());
                stmt.AddValue(6, _voidStorageItems[i].getFixedScalingLevel());
                stmt.AddValue(7, _voidStorageItems[i].getArtifactKnowledgeLevel());
                stmt.AddValue(8, (byte) _voidStorageItems[i].getContext().getValue());

                StringBuilder bonusListIDs = new StringBuilder();

                for (var bonusListID : _voidStorageItems[i].getBonusListIDs()) {
                    bonusListIDs.append(String.format("%1$s ", bonusListID));
                }

                stmt.AddValue(9, bonusListIDs.toString());
            }

            trans.append(stmt);
        }
    }

    private void _SaveCUFProfiles(SQLTransaction trans) {
        PreparedStatement stmt;
        var lowGuid = getGUID().getCounter();

        for (byte i = 0; i < PlayerConst.MaxCUFProfiles; ++i) {
            if (_cufProfiles[i] == null) // unused profile
            {
                // DELETE FROM character_cuf_profiles WHERE guid = ? and id = ?
                stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_CUF_PROFILES_BY_ID);
                stmt.AddValue(0, lowGuid);
                stmt.AddValue(1, i);
            } else {
                // REPLACE INTO character_cuf_profiles (guid, id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                stmt = DB.characters.GetPreparedStatement(CharStatements.REP_CHAR_CUF_PROFILES);
                stmt.AddValue(0, lowGuid);
                stmt.AddValue(1, i);
                stmt.AddValue(2, _cufProfiles[i].getProfileName());
                stmt.AddValue(3, _cufProfiles[i].getFrameHeight());
                stmt.AddValue(4, _cufProfiles[i].getFrameWidth());
                stmt.AddValue(5, _cufProfiles[i].getSortBy());
                stmt.AddValue(6, _cufProfiles[i].getHealthText());
                stmt.AddValue(7, (int) _cufProfiles[i].getUlongOptionValue()); // 25 of 32 fields used, fits in an int
                stmt.AddValue(8, _cufProfiles[i].getTopPoint());
                stmt.AddValue(9, _cufProfiles[i].getBottomPoint());
                stmt.AddValue(10, _cufProfiles[i].getLeftPoint());
                stmt.AddValue(11, _cufProfiles[i].getTopOffset());
                stmt.AddValue(12, _cufProfiles[i].getBottomOffset());
                stmt.AddValue(13, _cufProfiles[i].getLeftOffset());
            }

            trans.append(stmt);
        }
    }

    private void _SaveInstanceTimeRestrictions(SQLTransaction trans) {
        if (instanceResetTimes.isEmpty()) {
            return;
        }

        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_ACCOUNT_INSTANCE_LOCK_TIMES);
        stmt.AddValue(0, getSession().getAccountId());
        trans.append(stmt);

        for (var pair : instanceResetTimes.entrySet()) {
            stmt = DB.characters.GetPreparedStatement(CharStatements.INS_ACCOUNT_INSTANCE_LOCK_TIMES);
            stmt.AddValue(0, getSession().getAccountId());
            stmt.AddValue(1, pair.getKey());
            stmt.AddValue(2, pair.getValue());
            trans.append(stmt);
        }
    }

    private void _SaveBGData(SQLTransaction trans) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_PLAYER_BGDATA);
        stmt.AddValue(0, getGUID().getCounter());
        trans.append(stmt);

        stmt = DB.characters.GetPreparedStatement(CharStatements.INS_PLAYER_BGDATA);
        stmt.AddValue(0, getGUID().getCounter());
        stmt.AddValue(1, bgData.getBgInstanceId());
        stmt.AddValue(2, bgData.getBgTeam());
        stmt.AddValue(3, bgData.getJoinPos().getX());
        stmt.AddValue(4, bgData.getJoinPos().getY());
        stmt.AddValue(5, bgData.getJoinPos().getZ());
        stmt.AddValue(6, bgData.getJoinPos().getO());
        stmt.AddValue(7, (short) bgData.getJoinPos().getMapId());
        stmt.AddValue(8, bgData.getTaxiPath()[0]);
        stmt.AddValue(9, bgData.getTaxiPath()[1]);
        stmt.AddValue(10, bgData.getMountSpell());
        trans.append(stmt);
    }


    private void deleteSpellFromAllPlayers(int spellId) {
        var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_INVALID_SPELL_SPELLS);
        stmt.AddValue(0, spellId);
        DB.characters.execute(stmt);
    }

    public final boolean getAutoAcceptQuickJoin() {
        return autoAcceptQuickJoin;
    }

    public final void setAutoAcceptQuickJoin(boolean value) {
        autoAcceptQuickJoin = value;
    }

    public final boolean getOverrideScreenFlash() {
        return overrideScreenFlash;
    }

    public final void setOverrideScreenFlash(boolean value) {
        overrideScreenFlash = value;
    }

    public final PlayerMenu getPlayerTalkClass() {
        return playerTalkClass;
    }

    public final void setPlayerTalkClass(PlayerMenu value) {
        playerTalkClass = value;
    }

    public final String getAutoReplyMsg() {
        return autoReplyMsg;
    }

    public final void setAutoReplyMsg(String value) {
        autoReplyMsg = value;
    }

    public final ArrayList<ItemSetEffect> getItemSetEff() {
        return itemSetEff;
    }

    public final ArrayList<item> getItemUpdateQueue() {
        return itemUpdateQueue;
    }

    public final boolean getInstanceValid() {
        return instanceValid;
    }

    public final void setInstanceValid(boolean value) {
        instanceValid = value;
    }

    public final PlayerTaxi getTaxi() {
        return taxi;
    }

    public final void setTaxi(PlayerTaxi value) {
        taxi = value;
    }


    public final byte[] getForcedSpeedChanges() {
        return forcedSpeedChanges;
    }


    public final void setForcedSpeedChanges(byte[] value) {
        forcedSpeedChanges = value;
    }


    public final byte getMovementForceModMagnitudeChanges() {
        return movementForceModMagnitudeChanges;
    }


    public final void setMovementForceModMagnitudeChanges(byte value) {
        movementForceModMagnitudeChanges = value;
    }

    public final Spell getSpellModTakingSpell() {
        return spellModTakingSpell;
    }

    public final void setSpellModTakingSpell(Spell value) {
        spellModTakingSpell = value;
    }

    public final float getEmpoweredSpellMinHoldPct() {
        return empoweredSpellMinHoldPct;
    }

    public final void setEmpoweredSpellMinHoldPct(float value) {
        empoweredSpellMinHoldPct = value;
    }


    public final byte getUnReadMails() {
        return unReadMails;
    }


    public final void setUnReadMails(byte value) {
        unReadMails = value;
    }

    public final boolean getMailsUpdated() {
        return mailsUpdated;
    }

    public final void setMailsUpdated(boolean value) {
        mailsUpdated = value;
    }

    public final ArrayList<PetAura> getPetAuras() {
        return petAuras;
    }

    public final void setPetAuras(ArrayList<PetAura> value) {
        petAuras = value;
    }

    public final DuelInfo getDuel() {
        return duel;
    }

    public final void setDuel(DuelInfo value) {
        duel = value;
    }

    public final PlayerData getPlayerData() {
        return playerData;
    }

    public final void setPlayerData(PlayerData value) {
        playerData = value;
    }

    public final ActivePlayerData getActivePlayerData() {
        return activePlayerData;
    }

    public final void setActivePlayerData(ActivePlayerData value) {
        activePlayerData = value;
    }

    public final ArrayList<ObjectGuid> getClientGuiDs() {
        return clientGuiDs;
    }

    public final void setClientGuiDs(ArrayList<ObjectGuid> value) {
        clientGuiDs = value;
    }

    public final ArrayList<ObjectGuid> getVisibleTransports() {
        return visibleTransports;
    }

    public final void setVisibleTransports(ArrayList<ObjectGuid> value) {
        visibleTransports = value;
    }

    public final WorldObject getSeerView() {
        return seerView;
    }

    public final void setSeerView(WorldObject value) {
        seerView = value;
    }

    public final AtLoginFlags getLoginFlags() {
        return loginFlags;
    }

    public final void setLoginFlags(AtLoginFlags value) {
        loginFlags = value;
    }

    public final boolean getItemUpdateQueueBlocked() {
        return itemUpdateQueueBlocked;
    }

    public final void setItemUpdateQueueBlocked(boolean value) {
        itemUpdateQueueBlocked = value;
    }

    public final boolean isDebugAreaTriggers() {
        return isDebugAreaTriggers;
    }

    public final void setDebugAreaTriggers(boolean value) {
        isDebugAreaTriggers = value;
    }

    public final WorldSession getSession() {
        return session;
    }

    public final PlayerSocial getSocial() {
        return social;
    }

    public final boolean isUsingLfg() {
        return global.getLFGMgr().getState(getGUID()) != LfgState.NONE;
    }

    public final PlayerGroup getGroupInvite() {
        return groupInvite;
    }

    public final void setGroupInvite(PlayerGroup value) {
        groupInvite = value;
    }

    public final PlayerGroup getGroup() {
        return group.refManager();
    }

    public final void setGroup(PlayerGroup group) {
        setGroup(group, 0);
    }

    public final GroupReference getGroupRef() {
        return group;
    }

    public final byte getSubGroup() {
        return group.getSubGroup();
    }

    public final GroupUpdateFlags getGroupUpdateFlag() {
        return groupUpdateFlags;
    }

    public final void setGroupUpdateFlag(GroupUpdateFlags flag) {
        groupUpdateFlags = GroupUpdateFlags.forValue(groupUpdateFlags.getValue() | flag.getValue());
    }

    public final PlayerGroup getOriginalGroup() {
        return originalGroup.getTarget();
    }

    public final void setOriginalGroup(PlayerGroup group) {
        setOriginalGroup(group, 0);
    }

    public final GroupReference getOriginalGroupRef() {
        return originalGroup;
    }

    public final byte getOriginalSubGroup() {
        return originalGroup.getSubGroup();
    }

    public final boolean getPassOnGroupLoot() {
        return bPassOnGroupLoot;
    }

    public final void setPassOnGroupLoot(boolean value) {
        bPassOnGroupLoot = value;
    }

    public final boolean getInRandomLfgDungeon() {
        if (global.getLFGMgr().selectedRandomLfgDungeon(getGUID())) {
            var map = getMap();

            return global.getLFGMgr().inLfgDungeonMap(getGUID(), map.getId(), map.getDifficultyID());
        }

        return false;
    }

    public final PartyResult canUninviteFromGroup() {
        return canUninviteFromGroup(null);
    }

    public final PartyResult canUninviteFromGroup(ObjectGuid guidMember) {
        var grp = getGroup();

        if (!grp) {
            return PartyResult.NotInGroup;
        }

        if (grp.isLFGGroup()) {
            var gguid = grp.getGUID();

            if (global.getLFGMgr().getKicksLeft(gguid) == 0) {
                return PartyResult.PartyLfgBootLimit;
            }

            var state = global.getLFGMgr().getState(gguid);

            if (global.getLFGMgr().isVoteKickActive(gguid)) {
                return PartyResult.PartyLfgBootInProgress;
            }

            if (grp.getMembersCount() <= SharedConst.LFGKickVotesNeeded) {
                return PartyResult.PartyLfgBootTooFewPlayers;
            }

            if (state == LfgState.FinishedDungeon) {
                return PartyResult.PartyLfgBootDungeonComplete;
            }

            var player = global.getObjAccessor().findConnectedPlayer(guidMember);

            if (!player.lootRolls.isEmpty()) {
                return PartyResult.PartyLfgBootLootRolls;
            }

            // @todo Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
            for (var refe = grp.getFirstMember(); refe != null; refe = refe.next()) {
                if (refe.getSource() && refe.getSource().isInMap(this) && refe.getSource().isInCombat()) {
                    return PartyResult.PartyLfgBootInCombat;
                }
            }

			/* Missing support for these types
			    return ERR_PARTY_LFG_BOOT_COOLDOWN_S;
			    return ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S;
			*/
        } else {
            if (!grp.isLeader(getGUID()) && !grp.isAssistant(getGUID())) {
                return PartyResult.NotLeader;
            }

            if (getInBattleground()) {
                return PartyResult.InviteRestricted;
            }

            if (grp.isLeader(guidMember)) {
                return PartyResult.NotLeader;
            }
        }

        return PartyResult.Ok;
    }

    public final void setBattlegroundOrBattlefieldRaid(PlayerGroup group, byte subgroup) {
        //we must move references from m_group to m_originalGroup
        setOriginalGroup(getGroup(), getSubGroup());

        group.Unlink();
        group.link(group, this);
        group.setSubGroup(subgroup);
    }

    public final void removeFromBattlegroundOrBattlefieldRaid() {
        //remove existing reference
        group.Unlink();
        var group = getOriginalGroup();

        if (group) {
            group.link(group, this);
            group.setSubGroup(getOriginalSubGroup());
        }

        setOriginalGroup(null);
    }

    public final void setOriginalGroup(PlayerGroup group, byte subgroup) {
        if (!group) {
            originalGroup.Unlink();
        } else {
            originalGroup.link(group, this);
            originalGroup.setSubGroup(subgroup);
        }
    }

    public final boolean isInGroup(ObjectGuid groupGuid) {
        var group = getGroup();

        if (group != null) {
            if (Objects.equals(group.getGUID(), groupGuid)) {
                return true;
            }
        }

        var originalGroup = getOriginalGroup();

        if (originalGroup != null) {
            return Objects.equals(originalGroup.getGUID(), groupGuid);
        }

        return false;
    }

    public final void setGroup(PlayerGroup group, byte subgroup) {
        if (!group) {
            group.Unlink();
        } else {
            group.link(group, this);
            group.setSubGroup(subgroup);
        }

        updateObjectVisibility(false);
    }

    public final void setPartyType(GroupCategory category, GroupType type) {
        byte value = getPlayerData().partyType;
        value &= (byte) ~(0xFF << ((byte) category.getValue() * 4));
        value |= (byte) ((byte) type.getValue() << ((byte) category.getValue() * 4));
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().partyType), value);
    }

    public final void resetGroupUpdateSequenceIfNeeded(PlayerGroup group) {
        var category = group.getGroupCategory();

        // Rejoining the last group should not reset the sequence
        if (ObjectGuid.opNotEquals(_groupUpdateSequences[category.getValue()].groupGuid, group.getGUID())) {
            GroupUpdateCounter groupUpdate = new GroupUpdateCounter();
            groupUpdate.groupGuid = group.getGUID();
            groupUpdate.updateSequenceNumber = 1;
            _groupUpdateSequences[category.getValue()] = groupUpdate;
        }
    }

    public final int nextGroupUpdateSequenceNumber(GroupCategory category) {
        return _groupUpdateSequences[category.getValue()].updateSequenceNumber++;
    }

    public final boolean isAtGroupRewardDistance(WorldObject pRewardSource) {
        if (!pRewardSource || !isInMap(pRewardSource)) {
            return false;
        }

        WorldObject player = getCorpse();

        if (!player || isAlive()) {
            player = this;
        }

        if (player.getMap().isDungeon()) {
            return true;
        }

        return pRewardSource.getDistance(player) <= WorldConfig.getFloatValue(WorldCfg.GroupXpDistance);
    }

    public final void removeGroupUpdateFlag(GroupUpdateFlags flag) {
        groupUpdateFlags = GroupUpdateFlags.forValue(groupUpdateFlags.getValue() & ~flag.getValue());
    }

    public final boolean isGroupVisibleFor(Player p) {
        switch (WorldConfig.getIntValue(WorldCfg.GroupVisibility)) {
            default:
                return isInSameGroupWith(p);
            case 1:
                return isInSameRaidWith(p);
            case 2:
                return getTeam() == p.getTeam();
            case 3:
                return false;
        }
    }

    public final boolean isInSameGroupWith(Player p) {
        return p == this || (getGroup() && getGroup() == p.getGroup() && getGroup().sameSubGroup(this, p));
    }

    public final boolean isInSameRaidWith(Player p) {
        return p == this || (getGroup() != null && getGroup() == p.getGroup());
    }

    public final void uninviteFromGroup() {
        var group = getGroupInvite();

        if (!group) {
            return;
        }

        group.removeInvite(this);

        if (group.isCreated()) {
            if (group.getMembersCount() <= 1) // group has just 1 member => disband
            {
                group.disband(true);
            }
        } else {
            if (group.getInviteeCount() <= 1) {
                group.removeAllInvites();
            }
        }
    }

    public final void removeFromGroup() {
        removeFromGroup(RemoveMethod.Default);
    }

    public final void removeFromGroup(RemoveMethod method) {
        removeFromGroup(getGroup(), getGUID(), method);
    }

    private Player getNextRandomRaidMember(float radius) {
        var group = getGroup();

        if (!group) {
            return null;
        }

        ArrayList<Player> nearMembers = new ArrayList<>();

        for (var refe = group.getFirstMember(); refe != null; refe = refe.next()) {
            var target = refe.getSource();

            // IsHostileTo check duel and controlled by enemy
            if (target && target != this && isWithinDistInMap(target, radius) && !target.getHasInvisibilityAura() && !isHostileTo(target)) {
                nearMembers.add(target);
            }
        }

        if (nearMembers.isEmpty()) {
            return null;
        }

        var randTarget = RandomUtil.IRand(0, nearMembers.size() - 1);

        return nearMembers.get(randTarget);
    }

    private void sendUpdateToOutOfRangeGroupMembers() {
        if (groupUpdateFlags == GroupUpdateFlags.NONE) {
            return;
        }

        var group = getGroup();

        if (group) {
            group.updatePlayerOutOfRange(this);
        }

        groupUpdateFlags = GroupUpdateFlags.NONE;

        var pet = getCurrentPet();

        if (pet) {
            pet.ResetGroupUpdateFlag();
        }
    }

    public final void deleteRefundReference(ObjectGuid it) {
        refundableItems.remove(it);
    }

    //Store Item

    public final void refundItem(Item item) {
        if (!item.isRefundable()) {
            Log.outDebug(LogFilter.player, "Item refund: item not refundable!");

            return;
        }

        if (item.isRefundExpired()) // item refund has expired
        {
            item.setNotRefundable(this);
            sendItemRefundResult(item, null, (byte) 10);

            return;
        }

        if (ObjectGuid.opNotEquals(getGUID(), item.getRefundRecipient())) // Formerly refundable item got traded
        {
            Log.outDebug(LogFilter.player, "Item refund: item was traded!");
            item.setNotRefundable(this);

            return;
        }

        var iece = CliDB.ItemExtendedCostStorage.get(item.getPaidExtendedCost());

        if (iece == null) {
            Log.outDebug(LogFilter.player, "Item refund: cannot find extendedcost data.");

            return;
        }

        var store_error = false;

        for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) {
            int count = iece.ItemCount[i];
            var itemid = iece.ItemID[i];

            if (count != 0 && itemid != 0) {
                ArrayList<ItemPosCount> dest = new ArrayList<>();
                var msg = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, itemid, count);

                if (msg != InventoryResult.Ok) {
                    store_error = true;

                    break;
                }
            }
        }

        if (store_error) {
            sendItemRefundResult(item, iece, (byte) 10);

            return;
        }

        sendItemRefundResult(item, iece, (byte) 0);

        var moneyRefund = item.getPaidMoney(); // item. will be invalidated in DestroyItem

        // Save all relevant data to DB to prevent desynchronisation exploits
        SQLTransaction trans = new SQLTransaction();

        // Delete any references to the refund data
        item.setNotRefundable(this, true, trans, false);
        getSession().getCollectionMgr().removeTemporaryAppearance(item);

        // Destroy item
        destroyItem(item.getBagSlot(), item.getSlot(), true);

        // Grant back extendedcost items
        for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) {
            int count = iece.ItemCount[i];
            var itemid = iece.ItemID[i];

            if (count != 0 && itemid != 0) {
                ArrayList<ItemPosCount> dest = new ArrayList<>();
                var msg = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, itemid, count);
                var it = storeNewItem(dest, itemid, true);
                sendNewItem(it, count, true, false, true);
            }
        }

        // Grant back currencies
        for (byte i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) {
            if (iece.flags.hasFlag((byte) (ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                continue;
            }

            var count = iece.CurrencyCount[i];
            int currencyid = iece.CurrencyID[i];

            if (count != 0 && currencyid != 0) {
                addCurrency(currencyid, count, CurrencyGainSource.ItemRefund);
            }
        }

        // Grant back money
        if (moneyRefund != 0) {
            modifyMoney(moneyRefund); // Saved in SaveInventoryAndGoldToDB
        }

        saveInventoryAndGoldToDB(trans);

        DB.characters.CommitTransaction(trans);
    }

    public final void sendRefundInfo(Item item) {
        // This function call unsets ITEM_FLAGS_REFUNDABLE if played time is over 2 hours.
        item.updatePlayedTime(this);

        if (!item.isRefundable()) {
            Log.outDebug(LogFilter.player, "Item refund: item not refundable!");

            return;
        }

        if (ObjectGuid.opNotEquals(getGUID(), item.getRefundRecipient())) // Formerly refundable item got traded
        {
            Log.outDebug(LogFilter.player, "Item refund: item was traded!");
            item.setNotRefundable(this);

            return;
        }

        var iece = CliDB.ItemExtendedCostStorage.get(item.getPaidExtendedCost());

        if (iece == null) {
            Log.outDebug(LogFilter.player, "Item refund: cannot find extendedcost data.");

            return;
        }

        SetItemPurchaseData setItemPurchaseData = new SetItemPurchaseData();
        setItemPurchaseData.itemGUID = item.getGUID();
        setItemPurchaseData.purchaseTime = getTotalPlayedTime() - item.getPlayedTime();
        setItemPurchaseData.contents.money = item.getPaidMoney();

        for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) // item cost data
        {
            setItemPurchaseData.contents.Items[i].itemCount = iece.ItemCount[i];
            setItemPurchaseData.contents.Items[i].itemID = iece.ItemID[i];
        }

        for (byte i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) // currency cost data
        {
            if (iece.flags.hasFlag((byte) (ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                continue;
            }

            setItemPurchaseData.contents.Currencies[i].currencyCount = iece.CurrencyCount[i];
            setItemPurchaseData.contents.Currencies[i].currencyID = iece.CurrencyID[i];
        }

        sendPacket(setItemPurchaseData);
    }


    public final void sendItemRefundResult(Item item, ItemExtendedCostRecord iece, byte error) {
        ItemPurchaseRefundResult itemPurchaseRefundResult = new ItemPurchaseRefundResult();
        itemPurchaseRefundResult.itemGUID = item.getGUID();
        itemPurchaseRefundResult.result = error;

        if (error == 0) {
            itemPurchaseRefundResult.contents = new itemPurchaseContents();
            itemPurchaseRefundResult.contents.money = item.getPaidMoney();

            for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) // item cost data
            {
                itemPurchaseRefundResult.contents.Items[i].itemCount = iece.ItemCount[i];
                itemPurchaseRefundResult.contents.Items[i].itemID = iece.ItemID[i];
            }

            for (byte i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) // currency cost data
            {
                if (iece.flags.hasFlag((byte) ((int) ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                    continue;
                }

                itemPurchaseRefundResult.contents.Currencies[i].currencyCount = iece.CurrencyCount[i];
                itemPurchaseRefundResult.contents.Currencies[i].currencyID = iece.CurrencyID[i];
            }
        }

        sendPacket(itemPurchaseRefundResult);
    }

    public final void removeTradeableItem(Item item) {
        itemSoulboundTradeable.remove(item.getGUID());
    }

    public final Player getTrader() {
        return (trade == null ? null : trade.getTrader());
    }

    public final TradeData getTradeData() {
        return trade;
    }

    public final void setTradeData(TradeData data) {
        trade = data;
    }

    public final void tradeCancel(boolean sendback) {
        if (trade != null) {
            var trader = trade.getTrader();

            // send yellow "Trade canceled" message to both traders
            if (sendback) {
                getSession().sendCancelTrade();
            }

            trader.getSession().sendCancelTrade();

            // cleanup
            trade = null;
            trader.trade = null;
        }
    }

    //Durability
    public final void durabilityLossAll(double percent, boolean inventory) {
        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem != null) {
                durabilityLoss(pItem, percent);
            }
        }

        if (inventory) {
            var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

            for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
                var pItem = getItemByPos(InventorySlots.Bag0, i);

                if (pItem != null) {
                    durabilityLoss(pItem, percent);
                }
            }

            for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
                var pBag = getBagByPos(i);

                if (pBag != null) {
                    for (byte j = 0; j < pBag.getBagSize(); j++) {
                        var pItem = getItemByPos(i, j);

                        if (pItem != null) {
                            durabilityLoss(pItem, percent);
                        }
                    }
                }
            }
        }
    }

    public final void durabilityLoss(Item item, double percent) {
        if (item == null) {
            return;
        }

        int pMaxDurability = item.getItemData().maxDurability;

        if (pMaxDurability == 0) {
            return;
        }

        percent /= getTotalAuraMultiplier(AuraType.ModDurabilityLoss);

        var pDurabilityLoss = (int) (pMaxDurability * percent);

        if (pDurabilityLoss < 1) {
            pDurabilityLoss = 1;
        }

        durabilityPointsLoss(item, pDurabilityLoss);
    }

    public final void durabilityPointsLossAll(double points, boolean inventory) {
        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem != null) {
                durabilityPointsLoss(pItem, points);
            }
        }

        if (inventory) {
            var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

            for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
                var pItem = getItemByPos(InventorySlots.Bag0, i);

                if (pItem != null) {
                    durabilityPointsLoss(pItem, points);
                }
            }

            for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
                var pBag = (bag) getItemByPos(InventorySlots.Bag0, i);

                if (pBag != null) {
                    for (byte j = 0; j < pBag.getBagSize(); j++) {
                        var pItem = getItemByPos(i, j);

                        if (pItem != null) {
                            durabilityPointsLoss(pItem, points);
                        }
                    }
                }
            }
        }
    }

    public final void durabilityPointsLoss(Item item, double points) {
        if (hasAuraType(AuraType.PreventDurabilityLoss)) {
            return;
        }

        int pMaxDurability = item.getItemData().maxDurability;
        int pOldDurability = item.getItemData().durability;
        var pNewDurability = (int) (pOldDurability - points);

        if (pNewDurability < 0) {
            pNewDurability = 0;
        } else if (pNewDurability > pMaxDurability) {
            pNewDurability = pMaxDurability;
        }

        if (pOldDurability != pNewDurability) {
            // modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
            if (pNewDurability == 0 && pOldDurability > 0 && item.isEquipped()) {
                _ApplyItemMods(item, item.getSlot(), false);
            }

            item.setDurability(pNewDurability);

            // modify item stats _after_ restore durability to pass _ApplyItemMods internal check
            if (pNewDurability > 0 && pOldDurability == 0 && item.isEquipped()) {
                _ApplyItemMods(item, item.getSlot(), true);
            }

            item.setState(ItemUpdateState.changed, this);
        }
    }


    public final void durabilityPointLossForEquipSlot(byte slot) {
        if (hasAuraType(AuraType.PreventDurabilityLossFromCombat)) {
            return;
        }

        var pItem = getItemByPos(InventorySlots.Bag0, slot);

        if (pItem != null) {
            durabilityPointsLoss(pItem, 1);
        }
    }

    //UseItem

    public final void durabilityRepairAll(boolean takeCost, float discountMod, boolean guildBank) {
        // Collecting all items that can be repaired and repair costs
        ArrayList < (Item item,long cost)>itemRepairCostStore = new ArrayList<(Item item, long cost)>();

        // equipped, backpack, bags itself
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = EquipmentSlot.start; i < inventoryEnd; i++) {
            var item = getItemByPos((short) ((InventorySlots.Bag0 << 8) | i));

            if (item != null) {
                var cost = item.calculateDurabilityRepairCost(discountMod);

                if (cost != 0) {
                    itemRepairCostStore.add((item, cost))
                }
            }
        }

        // items in inventory bags
        for (var j = InventorySlots.BagStart; j < InventorySlots.BagEnd; j++) {
            for (byte i = 0; i < ItemConst.MaxBagSize; i++) {
                var item = getItemByPos((short) ((j << 8) | i));

                if (item != null) {
                    var cost = item.calculateDurabilityRepairCost(discountMod);

                    if (cost != 0) {
                        itemRepairCostStore.add((item, cost))
                    }
                }
            }
        }

        // Handling a free repair case - just repair every item without taking cost.
        if (!takeCost) {
// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(item, _) : itemRepairCostStore) {
                durabilityRepair(item.pos, false, 0.0f);
            }

            return;
        }

        if (guildBank) {
            // Handling a repair for guild money case.
            // We have to repair items one by one until the guild bank has enough money available for withdrawal or until all items are repaired.

            var guild = getGuild();

            if (guild == null) {
                return; // silent return, client shouldn't display this button for players without guild.
            }

            var availableGuildMoney = guild.getMemberAvailableMoneyForRepairItems(getGUID());

            if (availableGuildMoney == 0) {
                return;
            }

            // Sort the items by repair cost from lowest to highest
            itemRepairCostStore.OrderByDescending(a -> a.cost);

            // We must calculate total repair cost and take money once to avoid spam in the guild bank log and reduce number of transactions in the database
            long totalCost = 0;

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(item, cost) : itemRepairCostStore) {
                var newTotalCost = totalCost + cost;

                if (newTotalCost > availableGuildMoney || newTotalCost > PlayerConst.MaxMoneyAmount) {
                    break;
                }

                totalCost = newTotalCost;
                // Repair item without taking cost. We'll do it later.
                durabilityRepair(item.pos, false, 0.0f);
            }

            // Take money for repairs from the guild bank
            guild.handleMemberWithdrawMoney(getSession(), totalCost, true);
        } else {
            // Handling a repair for player's money case.
            // Unlike repairing for guild money, in this case we must first check if player has enough money to repair all the items at once.

            long totalCost = 0;

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(_, cost) : itemRepairCostStore) {
                totalCost += cost;
            }

            if (!hasEnoughMoney(totalCost)) {
                return; // silent return, client should display error by itself and not send opcode.
            }

            modifyMoney(-(int) totalCost);

            // Payment for repair has already been taken, so just repair every item without taking cost.
// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(item, cost) : itemRepairCostStore) {
                durabilityRepair(item.pos, false, 0.0f);
            }
        }
    }


    public final void durabilityRepair(short pos, boolean takeCost, float discountMod) {
        var item = getItemByPos(pos);

        if (item == null) {
            return;
        }


        if (takeCost) {
            var cost = item.calculateDurabilityRepairCost(discountMod);

            if (!hasEnoughMoney(cost)) {
                Log.outDebug(LogFilter.PlayerItems, String.format("Player::DurabilityRepair: Player '%1$s' (%2$s) has not enough money to repair item", getName(), getGUID()));

                return;
            }

            modifyMoney(-(int) cost);
        }

        var isBroken = item.isBroken();

        item.setDurability(item.getItemData().maxDurability);
        item.setState(ItemUpdateState.changed, this);

        // reapply mods for total broken and repaired item if equipped
        if (isEquipmentPos(pos) && isBroken) {
            _ApplyItemMods(item, (byte) (pos & 255), true);
        }
    }

    public final InventoryResult canStoreItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, Item pItem) {
        return canStoreItem(bag, slot, dest, pItem, false);
    }

    public final InventoryResult canStoreItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, Item pItem, boolean swap) {
        if (pItem == null) {
            return InventoryResult.ItemNotFound;
        }

        return canStoreItem(bag, slot, dest, pItem.getEntry(), pItem.getCount(), pItem, swap);
    }


    public final InventoryResult canStoreItems(ArrayList<item> items, int count, tangible.RefObject<Integer> offendingItemId) {
        return canStoreItems(items.toArray(new Item[0]), count, offendingItemId);
    }


    public final InventoryResult canStoreItems(Item[] items, int count, tangible.RefObject<Integer> offendingItemId) {
        Item item2;

        // fill space tables, creating a mock-up of the player's inventory

        // counts
        var inventoryCounts = new int[InventorySlots.ItemEnd - InventorySlots.ItemStart];
        var bagCounts = new int[InventorySlots.BagEnd - InventorySlots.BagStart][];

        // Item array
        var inventoryPointers = new Item[InventorySlots.ItemEnd - InventorySlots.ItemStart];
        var bagPointers = new Item[InventorySlots.BagEnd - InventorySlots.BagStart][];

        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        // filling inventory
        for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
            // build items in stock backpack
            item2 = getItemByPos(InventorySlots.Bag0, i);

            if (item2 && !item2.isInTrade()) {
                inventoryCounts[i - InventorySlots.ItemStart] = item2.getCount();
                inventoryPointers[i - InventorySlots.ItemStart] = item2;
            }
        }

        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            var pBag = getBagByPos(i);

            if (pBag) {
                bagCounts[i - InventorySlots.BagStart] = new int[ItemConst.MaxBagSize];
                bagPointers[i - InventorySlots.BagStart] = new Item[ItemConst.MaxBagSize];

                for (byte j = 0; j < pBag.getBagSize(); j++) {
                    // build item counts in equippable bags
                    item2 = getItemByPos(i, j);

                    if (item2 && !item2.isInTrade()) {
                        bagCounts[i - InventorySlots.BagStart][j] = item2.getCount();
                        bagPointers[i - InventorySlots.BagStart][j] = item2;
                    }
                }
            }
        }

        // check free space for all items that we wish to add
        for (var k = 0; k < count; ++k) {
            // Incoming item
            var item = items[k];

            // no item
            if (!item) {
                continue;
            }

            var remaining_count = item.getCount();

            Log.outDebug(LogFilter.player, String.format("STORAGE: CanStoreItems %1$s. item = %2$s, count = %3$s", k + 1, item.getEntry(), remaining_count));
            var pProto = item.getTemplate();

            // strange item
            if (pProto == null) {
                return InventoryResult.ItemNotFound;
            }

            // item used
            if (item.getLootGenerated()) {
                return InventoryResult.LootGone;
            }

            // item it 'bind'
            if (item.isBindedNotWith(this)) {
                return InventoryResult.NotOwner;
            }

            ItemTemplate pBagProto;

            // item is 'one item only'
            var res = canTakeMoreSimilarItems(item, offendingItemId);

            if (res != InventoryResult.Ok) {
                return res;
            }

            var b_found = false;

            // search stack for merge to
            if (pProto.getMaxStackSize() != 1) {
                for (var t = InventorySlots.ItemStart; t < inventoryEnd; ++t) {
                    item2 = inventoryPointers[t - InventorySlots.ItemStart];

                    if (item2 && item2.canBeMergedPartlyWith(pProto) == InventoryResult.Ok && inventoryCounts[t - InventorySlots.ItemStart] < pProto.getMaxStackSize()) {
                        inventoryCounts[t - InventorySlots.ItemStart] += remaining_count;
                        remaining_count = inventoryCounts[t - InventorySlots.ItemStart] < pProto.getMaxStackSize() ? 0 : inventoryCounts[t - InventorySlots.ItemStart] - pProto.getMaxStackSize();

                        b_found = remaining_count == 0;

                        // if no pieces of the stack remain, then stop checking stock bag
                        if (b_found) {
                            break;
                        }
                    }
                }

                if (b_found) {
                    continue;
                }

                for (var t = InventorySlots.BagStart; !b_found && t < InventorySlots.BagEnd; ++t) {
                    var bag = getBagByPos(t);

                    if (bag) {
                        if (!item.itemCanGoIntoBag(item.getTemplate(), bag.getTemplate())) {
                            continue;
                        }

                        for (byte j = 0; j < bag.getBagSize(); j++) {
                            item2 = bagPointers[t - InventorySlots.BagStart][j];

                            if (item2 && item2.canBeMergedPartlyWith(pProto) == InventoryResult.Ok && bagCounts[t - InventorySlots.BagStart][j] < pProto.getMaxStackSize()) {
                                // add count to stack so that later items in the list do not double-book
                                bagCounts[t - InventorySlots.BagStart][j] += remaining_count;
                                remaining_count = bagCounts[t - InventorySlots.BagStart][j] < pProto.getMaxStackSize() ? 0 : bagCounts[t - InventorySlots.BagStart][j] - pProto.getMaxStackSize();

                                b_found = remaining_count == 0;

                                // if no pieces of the stack remain, then stop checking equippable bags
                                if (b_found) {
                                    break;
                                }
                            }
                        }
                    }
                }

                if (b_found) {
                    continue;
                }
            }

            b_found = false;

            // special bag case
            if (pProto.getBagFamily() != 0) {
                for (var t = InventorySlots.BagStart; !b_found && t < InventorySlots.BagEnd; ++t) {
                    var bag = getBagByPos(t);

                    if (bag) {
                        pBagProto = bag.getTemplate();

                        // not plain container check
                        if (pBagProto != null && (pBagProto.getClass() != itemClass.Container || pBagProto.getSubClass() != (int) ItemSubClassContainer.Container.getValue()) && item.itemCanGoIntoBag(pProto, pBagProto)) {
                            for (int j = 0; j < bag.getBagSize(); j++) {
                                if (bagCounts[t - InventorySlots.BagStart][j] == 0) {
                                    bagCounts[t - InventorySlots.BagStart][j] = remaining_count;
                                    bagPointers[t - InventorySlots.BagStart][j] = item;

                                    b_found = true;

                                    break;
                                }
                            }
                        }
                    }
                }

                if (b_found) {
                    continue;
                }
            }

            // search free slot
            b_found = false;

            for (int t = InventorySlots.ItemStart; t < inventoryEnd; ++t) {
                if (inventoryCounts[t - InventorySlots.ItemStart] == 0) {
                    inventoryCounts[t - InventorySlots.ItemStart] = 1;
                    inventoryPointers[t - InventorySlots.ItemStart] = item;

                    b_found = true;

                    break;
                }
            }

            if (b_found) {
                continue;
            }

            // search free slot in bags
            for (var t = InventorySlots.BagStart; !b_found && t < InventorySlots.BagEnd; ++t) {
                var bag = getBagByPos(t);

                if (bag) {
                    pBagProto = bag.getTemplate();

                    // special bag already checked
                    if (pBagProto != null && (pBagProto.getClass() != itemClass.Container || pBagProto.getSubClass() != (int) ItemSubClassContainer.Container.getValue())) {
                        continue;
                    }

                    for (int j = 0; j < bag.getBagSize(); j++) {
                        if (bagCounts[t - InventorySlots.BagStart][j] == 0) {
                            bagCounts[t - InventorySlots.BagStart][j] = remaining_count;
                            bagPointers[t - InventorySlots.BagStart][j] = item;

                            b_found = true;

                            break;
                        }
                    }
                }
            }

            // if no free slot found for all pieces of the item, then return an error
            if (!b_found) {
                return InventoryResult.BagFull;
            }
        }

        return InventoryResult.Ok;
    }


    public final InventoryResult canStoreNewItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, int item, int count, tangible.OutObject<Integer> no_space_count) {
        return canStoreItem(bag, slot, dest, item, count, null, false, no_space_count);
    }


    public final InventoryResult canStoreNewItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, int item, int count) {
        tangible.OutObject<Integer> tempOut__ = new tangible.OutObject<Integer>();
        var tempVar = canStoreItem(bag, slot, dest, item, count, null, false, tempOut__);
        _ = tempOut__.outArgValue;
        return tempVar;
    }

    public final Item storeItem(ArrayList<ItemPosCount> dest, Item pItem, boolean update) {
        if (pItem == null) {
            return null;
        }

        var lastItem = pItem;

        for (var i = 0; i < dest.size(); i++) {
            var itemPosCount = dest.get(i);
            var pos = itemPosCount.pos;
            var count = itemPosCount.count;

            if (i == dest.size() - 1) {
                lastItem = _StoreItem(pos, pItem, count, false, update);

                break;
            }

            lastItem = _StoreItem(pos, pItem, count, true, update);
        }

        autoUnequipChildItem(lastItem);

        return lastItem;
    }

    public final Item storeNewItem(ArrayList<ItemPosCount> pos, int itemId, boolean update, int randomBonusListId, ArrayList<ObjectGuid> allowedLooters, ItemContext context, ArrayList<Integer> bonusListIDs) {
        return storeNewItem(pos, itemId, update, randomBonusListId, allowedLooters, context, bonusListIDs, true);
    }

    public final Item storeNewItem(ArrayList<ItemPosCount> pos, int itemId, boolean update, int randomBonusListId, ArrayList<ObjectGuid> allowedLooters, ItemContext context) {
        return storeNewItem(pos, itemId, update, randomBonusListId, allowedLooters, context, null, true);
    }

    public final Item storeNewItem(ArrayList<ItemPosCount> pos, int itemId, boolean update, int randomBonusListId, ArrayList<ObjectGuid> allowedLooters) {
        return storeNewItem(pos, itemId, update, randomBonusListId, allowedLooters, 0, null, true);
    }

    public final Item storeNewItem(ArrayList<ItemPosCount> pos, int itemId, boolean update, int randomBonusListId) {
        return storeNewItem(pos, itemId, update, randomBonusListId, null, 0, null, true);
    }

    public final Item storeNewItem(ArrayList<ItemPosCount> pos, int itemId, boolean update) {
        return storeNewItem(pos, itemId, update, 0, null, 0, null, true);
    }

    public final Item storeNewItem(ArrayList<ItemPosCount> pos, int itemId, boolean update, int randomBonusListId, ArrayList<ObjectGuid> allowedLooters, ItemContext context, ArrayList<Integer> bonusListIDs, boolean addToCollection) {
        int count = 0;

        for (var itemPosCount : pos) {
            count += itemPosCount.count;
        }

        var item = item.createItem(itemId, count, context, this);

        if (item != null) {
            item.setItemFlag(ItemFieldFlags.newItem);

            item.setBonuses(bonusListIDs);

            item = storeItem(pos, item, update);

            itemAddedQuestCheck(itemId, count);
            updateCriteria(CriteriaType.ObtainAnyItem, itemId, count);
            updateCriteria(CriteriaType.AcquireItem, itemId, count);

            item.setFixedLevel(getLevel());
            item.setItemRandomBonusList(randomBonusListId);

            if (allowedLooters != null && allowedLooters.size() > 1 && item.getTemplate().getMaxStackSize() == 1 && item.isSoulBound()) {
                item.setSoulboundTradeable(allowedLooters);
                item.setCreatePlayedTime(getTotalPlayedTime());
                addTradeableItem(item);

                // save data
                StringBuilder ss = new StringBuilder();

                for (var guid : allowedLooters) {
                    ss.append(String.format("%1$s ", guid));
                }

                var stmt = DB.characters.GetPreparedStatement(CharStatements.INS_ITEM_BOP_TRADE);
                stmt.AddValue(0, item.getGUID().getCounter());
                stmt.AddValue(1, ss.toString());
                DB.characters.execute(stmt);
            }

            if (addToCollection) {
                getSession().getCollectionMgr().onItemAdded(item);
            }

            var childItemEntry = global.getDB2Mgr().GetItemChildEquipment(itemId);

            if (childItemEntry != null) {
                var childTemplate = global.getObjectMgr().getItemTemplate(childItemEntry.ChildItemID);

                if (childTemplate != null) {
                    ArrayList<ItemPosCount> childDest = new ArrayList<>();
                    tangible.RefObject<Integer> tempRef_count = new tangible.RefObject<Integer>(count);
                    canStoreItem_InInventorySlots(InventorySlots.ChildEquipmentStart, InventorySlots.ChildEquipmentEnd, childDest, childTemplate, tempRef_count, false, null, ItemConst.NullBag, ItemConst.NullSlot);
                    count = tempRef_count.refArgValue;
                    var childItem = storeNewItem(childDest, childTemplate.getId(), update, 0, null, context, null, addToCollection);

                    if (childItem) {
                        childItem.setCreator(item.getGUID());
                        childItem.setItemFlag(ItemFieldFlags.Child);
                        item.setChildItem(childItem.getGUID());
                    }
                }
            }

            if (item.getTemplate().getInventoryType() != inventoryType.NonEquip) {
                updateAverageItemLevelTotal();
            }
        }

        return item;
    }

    public final InventoryResult canUseItem(Item pItem) {
        return canUseItem(pItem, true);
    }

    public final InventoryResult canUseItem(Item pItem, boolean not_loading) {
        if (pItem != null) {
            Log.outDebug(LogFilter.player, "ItemStorage: CanUseItem item = {0}", pItem.getEntry());

            if (!isAlive() && not_loading) {
                return InventoryResult.PlayerDead;
            }

            var pProto = pItem.getTemplate();

            if (pProto != null) {
                if (pItem.isBindedNotWith(this)) {
                    return InventoryResult.NotOwner;
                }

                if (getLevel() < pItem.getRequiredLevel()) {
                    return InventoryResult.CantEquipLevelI;
                }

                var res = canUseItem(pProto);

                if (res != InventoryResult.Ok) {
                    return res;
                }

                if (pItem.getSkill() != 0) {
                    var allowEquip = false;
                    var itemSkill = pItem.getSkill();

                    // Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
                    if (pProto.getQuality() == itemQuality.Heirloom && pProto.getClass() == itemClass.armor && !hasSkill(itemSkill)) {
                        // TODO: when you right-click already equipped item it throws EQUIP_ERR_PROFICIENCY_NEEDED.
                        // In fact it's a visual bug, everything works properly... I need sniffs of operations with
                        // binded to account items from off server.
                        switch (getClass()) {
                            case Hunter:
                            case Shaman:
                                allowEquip = (itemSkill == SkillType.MAIL);

                                break;
                            case Paladin:
                            case Warrior:
                                allowEquip = (itemSkill == SkillType.PlateMail);

                                break;
                        }
                    }

                    if (!allowEquip && getSkillValue(itemSkill) == 0) {
                        return InventoryResult.ProficiencyNeeded;
                    }
                }

                return InventoryResult.Ok;
            }
        }

        return InventoryResult.ItemNotFound;
    }

    public final InventoryResult canUseItem(ItemTemplate proto) {
        return canUseItem(proto, false);
    }

    public final InventoryResult canUseItem(ItemTemplate proto, boolean skipRequiredLevelCheck) {
        // Used by group, function GroupLoot, to know if a prototype can be used by a player

        if (proto == null) {
            return InventoryResult.ItemNotFound;
        }

        if (proto.hasFlag(ItemFlags2.InternalItem)) {
            return InventoryResult.CantEquipEver;
        }

        if (proto.hasFlag(ItemFlags2.FactionHorde) && getTeam() != Team.Horde) {
            return InventoryResult.CantEquipEver;
        }

        if (proto.hasFlag(ItemFlags2.FactionAlliance) && getTeam() != Team.ALLIANCE) {
            return InventoryResult.CantEquipEver;
        }

        if ((proto.getAllowableClass() & getClassMask()) == 0 || (proto.getAllowableRace() & (long) SharedConst.GetMaskForRace(getRace())) == 0) {
            return InventoryResult.CantEquipEver;
        }

        if (proto.getRequiredSkill() != 0) {
            if (getSkillValue(SkillType.forValue(proto.getRequiredSkill())) == 0) {
                return InventoryResult.ProficiencyNeeded;
            } else if (getSkillValue(SkillType.forValue(proto.getRequiredSkill())).getValue() < proto.getRequiredSkillRank()) {
                return InventoryResult.CantEquipSkill;
            }
        }

        if (proto.getRequiredSpell() != 0 && !hasSpell(proto.getRequiredSpell())) {
            return InventoryResult.ProficiencyNeeded;
        }

        if (!skipRequiredLevelCheck && getLevel() < proto.getBaseRequiredLevel()) {
            return InventoryResult.CantEquipLevelI;
        }

        // If World Event is not active, prevent using event dependant items
        if (proto.getHolidayID() != 0 && !global.getGameEventMgr().isHolidayActive(proto.getHolidayID())) {
            return InventoryResult.ClientLockedOut;
        }

        if (proto.getRequiredReputationFaction() != 0 && (int) getReputationRank(proto.getRequiredReputationFaction()).getValue() < proto.getRequiredReputationRank()) {
            return InventoryResult.CantEquipReputation;
        }

        // learning (recipes, mounts, pets, etc.)
        if (proto.getEffects().size() >= 2) {
            if (proto.getEffects().get(0).spellID == 483 || proto.getEffects().get(0).spellID == 55884) {
                if (hasSpell((int) proto.getEffects().get(1).spellID)) {
                    return InventoryResult.InternalBagError;
                }
            }
        }

        var artifact = CliDB.ArtifactStorage.get(proto.getArtifactID());

        if (artifact != null) {
            if (artifact.chrSpecializationID != getPrimarySpecialization()) {
                return InventoryResult.CantUseItem;
            }
        }

        return InventoryResult.Ok;
    }


    public final Item equipNewItem(short pos, int item, ItemContext context, boolean update) {
        var pItem = item.createItem(item, 1, context, this);

        if (pItem != null) {
            updateCriteria(CriteriaType.ObtainAnyItem, item, 1);
            var equippedItem = equipItem(pos, pItem, update);
            itemAddedQuestCheck(item, 1);

            return equippedItem;
        }

        return null;
    }


    public final Item equipItem(short pos, Item pItem, boolean update) {
        addEnchantmentDurations(pItem);
        addItemDurations(pItem);

        var bag = (byte) (pos >>> 8);
        var slot = (byte) (pos & 255);

        var pItem2 = getItemByPos(bag, slot);

        if (pItem2 == null) {
            visualizeItem(slot, pItem);

            if (isAlive()) {
                var pProto = pItem.getTemplate();

                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                if (pProto != null && pProto.getItemSet() != 0) {
                    item.addItemsSetItem(this, pItem);
                }

                _ApplyItemMods(pItem, slot, true);

                if (pProto != null && isInCombat() && (pProto.getClass() == itemClass.Weapon || pProto.getInventoryType() == inventoryType.Relic) && weaponChangeTimer == 0) {
                    var cooldownSpell = getClass() == playerClass.Rogue ? 6123 : 6119;
                    var spellProto = global.getSpellMgr().getSpellInfo(cooldownSpell, Difficulty.NONE);

                    if (spellProto == null) {
                        Log.outError(LogFilter.player, "Weapon switch cooldown spell {0} couldn't be found in spell.dbc", cooldownSpell);
                    } else {
                        weaponChangeTimer = spellProto.getStartRecoveryTime();

                        getSpellHistory().addGlobalCooldown(spellProto, duration.ofSeconds(weaponChangeTimer));

                        SpellCooldownPkt spellCooldown = new SpellCooldownPkt();
                        spellCooldown.caster = getGUID();
                        spellCooldown.flags = SpellCooldownFlags.IncludeGCD;
                        spellCooldown.spellCooldowns.add(new SpellCooldownStruct(cooldownSpell, 0));
                        sendPacket(spellCooldown);
                    }
                }
            }

            pItem.setItemFlag2(ItemFieldFlags2.Equipped);

            if (isInWorld() && update) {
                pItem.addToWorld();
                pItem.sendUpdateToPlayer(this);
            }

            applyEquipCooldown(pItem);

            // update expertise and armor penetration - passive auras may need it

            if (slot == EquipmentSlot.MainHand) {
                updateExpertise(WeaponAttackType.BaseAttack);
            } else if (slot == EquipmentSlot.OffHand) {
                updateExpertise(WeaponAttackType.OffAttack);
            }

            switch (slot) {
                case EquipmentSlot.MainHand:
                case EquipmentSlot.OffHand:
                    recalculateRating(CombatRating.ArmorPenetration);

                    break;
            }
        } else {
            pItem2.setCount(pItem2.getCount() + pItem.getCount());

            if (isInWorld() && update) {
                pItem2.sendUpdateToPlayer(this);
            }

            if (isInWorld() && update) {
                pItem.removeFromWorld();
                pItem.destroyForPlayer(this);
            }

            removeEnchantmentDurations(pItem);
            removeItemDurations(pItem);

            pItem.setOwnerGUID(getGUID()); // prevent error at next SetState in case trade/mail/buy from vendor
            pItem.setNotRefundable(this);
            pItem.clearSoulboundTradeable(this);
            removeTradeableItem(pItem);
            pItem.setState(ItemUpdateState.removed, this);
            pItem2.setState(ItemUpdateState.changed, this);

            applyEquipCooldown(pItem2);

            return pItem2;
        }

        if (slot == EquipmentSlot.MainHand || slot == EquipmentSlot.OffHand) {
            checkTitanGripPenalty();
        }

        // only for full equip instead adding to stack
        updateCriteria(CriteriaType.EquipItem, pItem.getEntry());
        updateCriteria(CriteriaType.EquipItemInSlot, slot, pItem.getEntry());

        updateAverageItemLevelEquipped();

        return pItem;
    }


    public final void equipChildItem(byte parentBag, byte parentSlot, Item parentItem) {
        var itemChildEquipment = global.getDB2Mgr().GetItemChildEquipment(parentItem.getEntry());

        if (itemChildEquipment != null) {
            var childItem = getChildItemByGuid(parentItem.getChildItem());

            if (childItem) {
                var childDest = (short) ((InventorySlots.Bag0 << 8) | itemChildEquipment.ChildItemEquipSlot);

                if (childItem.getPos() != childDest) {
                    var dstItem = getItemByPos(childDest);

                    if (!dstItem) // empty slot, simple case
                    {
                        removeItem(childItem.getBagSlot(), childItem.getSlot(), true);
                        equipItem(childDest, childItem, true);
                        autoUnequipOffhandIfNeed();
                    } else // have currently equipped item, not simple case
                    {
                        var dstbag = dstItem.getBagSlot();
                        var dstslot = dstItem.getSlot();

                        var msg = canUnequipItem(childDest, !childItem.isBag());

                        if (msg != InventoryResult.Ok) {
                            sendEquipError(msg, dstItem);

                            return;
                        }

                        // check dest.src move possibility but try to store currently equipped item in the bag where the parent item is
                        ArrayList<ItemPosCount> sSrc = new ArrayList<>();
                        short eSrc = 0;

                        if (isInventoryPos(parentBag, parentSlot)) {
                            msg = canStoreItem(parentBag, ItemConst.NullSlot, sSrc, dstItem, true);

                            if (msg != InventoryResult.Ok) {
                                msg = canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, sSrc, dstItem, true);
                            }
                        } else if (isBankPos(parentBag, parentSlot)) {
                            msg = canBankItem(parentBag, ItemConst.NullSlot, sSrc, dstItem, true);

                            if (msg != InventoryResult.Ok) {
                                msg = canBankItem(ItemConst.NullBag, ItemConst.NullSlot, sSrc, dstItem, true);
                            }
                        } else if (isEquipmentPos(parentBag, parentSlot)) {
                            tangible.OutObject<SHORT> tempOut_eSrc = new tangible.OutObject<SHORT>();
                            msg = canEquipItem(parentSlot, tempOut_eSrc, dstItem, true);
                            eSrc = tempOut_eSrc.outArgValue;

                            if (msg == InventoryResult.Ok) {
                                msg = canUnequipItem(eSrc, true);
                            }
                        }

                        if (msg != InventoryResult.Ok) {
                            sendEquipError(msg, dstItem, childItem);

                            return;
                        }

                        // now do moves, remove...
                        removeItem(dstbag, dstslot, false);
                        removeItem(childItem.getBagSlot(), childItem.getSlot(), false);

                        // add to dest
                        equipItem(childDest, childItem, true);

                        // add to src
                        if (isInventoryPos(parentBag, parentSlot)) {
                            storeItem(sSrc, dstItem, true);
                        } else if (isBankPos(parentBag, parentSlot)) {
                            bankItem(sSrc, dstItem, true);
                        } else if (isEquipmentPos(parentBag, parentSlot)) {
                            equipItem(eSrc, dstItem, true);
                        }

                        autoUnequipOffhandIfNeed();
                    }
                }
            }
        }
    }

    public final void autoUnequipChildItem(Item parentItem) {
        if (global.getDB2Mgr().GetItemChildEquipment(parentItem.getEntry()) != null) {
            var childItem = getChildItemByGuid(parentItem.getChildItem());

            if (childItem) {
                if (isChildEquipmentPos(childItem.getPos())) {
                    return;
                }

                ArrayList<ItemPosCount> dest = new ArrayList<>();
                var count = childItem.getCount();
                tangible.RefObject<Integer> tempRef_count = new tangible.RefObject<Integer>(count);
                var result = canStoreItem_InInventorySlots(InventorySlots.ChildEquipmentStart, InventorySlots.ChildEquipmentEnd, dest, childItem.getTemplate(), tempRef_count, false, childItem, ItemConst.NullBag, ItemConst.NullSlot);
                count = tempRef_count.refArgValue;

                if (result != InventoryResult.Ok) {
                    return;
                }

                removeItem(childItem.getBagSlot(), childItem.getSlot(), true);
                storeItem(dest, childItem, true);
            }
        }
    }

    public final void sendEquipError(InventoryResult msg, Item item1, Item item2) {
        sendEquipError(msg, item1, item2, 0);
    }

    public final void sendEquipError(InventoryResult msg, Item item1) {
        sendEquipError(msg, item1, null, 0);
    }

    public final void sendEquipError(InventoryResult msg) {
        sendEquipError(msg, null, null, 0);
    }

    public final void sendEquipError(InventoryResult msg, Item item1, Item item2, int itemId) {
        InventoryChangeFailure failure = new InventoryChangeFailure();
        failure.bagResult = msg;

        if (msg != InventoryResult.Ok) {
            if (item1) {
                failure.Item[0] = item1.getGUID();
            }

            if (item2) {
                failure.Item[1] = item2.getGUID();
            }

            failure.containerBSlot = 0; // bag equip slot, used with EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM and EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG2

            switch (msg) {
                case CantEquipLevelI:
                case PurchaseLevelTooLow: {
                    failure.level = (item1 ? item1.getRequiredLevel() : 0);

                    break;
                }
                case EventAutoequipBindConfirm: // no idea about this one...
                {
                    //failure.SrcContainer
                    //failure.SrcSlot
                    //failure.DstContainer
                    break;
                }
                case ItemMaxLimitCategoryCountExceededIs:
                case ItemMaxLimitCategorySocketedExceededIs:
                case ItemMaxLimitCategoryEquippedExceededIs: {
                    var proto = item1 ? item1.getTemplate() : global.getObjectMgr().getItemTemplate(itemId);
                    failure.limitCategory = proto != null ? proto.getItemLimitCategory() : 0;

                    break;
                }
                default:
                    break;
            }
        }

        sendPacket(failure);
    }

    //Add/Remove/Misc Item
    public final boolean addItem(int itemId, int count) {
        ArrayList<ItemPosCount> dest = new ArrayList<>();
        int noSpaceForCount;
        tangible.OutObject<Integer> tempOut_noSpaceForCount = new tangible.OutObject<Integer>();
        var msg = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, itemId, count, tempOut_noSpaceForCount);
        noSpaceForCount = tempOut_noSpaceForCount.outArgValue;

        if (msg != InventoryResult.Ok) {
            count -= noSpaceForCount;
        }

        if (count == 0 || dest.isEmpty()) {
            // @todo Send to mailbox if no space
            sendSysMessage("You don't have any space in your bags.");

            return false;
        }

        var item = storeNewItem(dest, itemId, true, ItemEnchantmentManager.generateItemRandomBonusListId(itemId));

        if (item != null) {
            sendNewItem(item, count, true, false);
        } else {
            return false;
        }

        return true;
    }


    public final void removeItem(byte bag, byte slot, boolean update) {
        // note: removeitem does not actually change the item
        // it only takes the item out of storage temporarily
        // note2: if removeitem is to be used for delinking
        // the item must be removed from the player's updatequeue

        var pItem = getItemByPos(bag, slot);

        if (pItem != null) {
            Log.outDebug(LogFilter.player, "STORAGE: RemoveItem bag = {0}, slot = {1}, item = {2}", bag, slot, pItem.getEntry());

            removeEnchantmentDurations(pItem);
            removeItemDurations(pItem);
            removeTradeableItem(pItem);

            if (bag == InventorySlots.Bag0) {
                if (slot < InventorySlots.BagEnd) {
                    // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                    var pProto = pItem.getTemplate();

                    if (pProto != null && pProto.getItemSet() != 0) {
                        item.removeItemsSetItem(this, pItem);
                    }

                    _ApplyItemMods(pItem, slot, false, update);

                    pItem.removeItemFlag2(ItemFieldFlags2.Equipped);

                    // remove item dependent auras and casts (only weapon and armor slots)
                    if (slot < ProfessionSlots.End) {
                        // update expertise
                        if (slot == EquipmentSlot.MainHand) {
                            // clear main hand only enchantments
                            for (EnchantmentSlot enchantSlot = 0; enchantSlot.getValue() < EnchantmentSlot.max.getValue(); ++enchantSlot) {
                                var enchantment = CliDB.SpellItemEnchantmentStorage.get(pItem.getEnchantmentId(enchantSlot));

                                if (enchantment != null && enchantment.getFlags().hasFlag(SpellItemEnchantmentFlags.MainhandOnly)) {
                                    pItem.clearEnchantment(enchantSlot);
                                }
                            }

                            updateExpertise(WeaponAttackType.BaseAttack);
                        } else if (slot == EquipmentSlot.OffHand) {
                            updateExpertise(WeaponAttackType.OffAttack);
                        }

                        // update armor penetration - passive auras may need it
                        switch (slot) {
                            case EquipmentSlot.MainHand:
                            case EquipmentSlot.OffHand:
                                recalculateRating(CombatRating.ArmorPenetration);

                                break;
                        }
                    }
                }

                _items[slot] = null;
                setInvSlot(slot, ObjectGuid.Empty);

                if (slot < EquipmentSlot.End) {
                    setVisibleItemSlot(slot, null);

                    if (slot == EquipmentSlot.MainHand || slot == EquipmentSlot.OffHand) {
                        checkTitanGripPenalty();
                    }
                }
            }

            var pBag = getBagByPos(bag);

            if (pBag != null) {
                pBag.removeItem(slot, update);
            }

            pItem.setContainedIn(ObjectGuid.Empty);
            pItem.setSlot(ItemConst.NullSlot);

            if (isInWorld() && update) {
                pItem.sendUpdateToPlayer(this);
            }

            autoUnequipChildItem(pItem);

            if (bag == InventorySlots.Bag0) {
                updateAverageItemLevelEquipped();
            }
        }
    }


    public final void addItemWithToast(int itemID, short quantity, int bonusid) {
        var pItem = item.createItem(itemID, quantity, itemContext.NONE, this);
        pItem.addBonuses(bonusid);
        sendDisplayToast(itemID, DisplayToastType.newItem, false, quantity, displayToastMethod.personalLoot, 0, pItem);
        storeNewItemInBestSlots(itemID, quantity, itemContext.NONE);
    }

    public final void sendABunchOfItemsInMail(ArrayList<Integer> BunchOfItems, String subject) {
        sendABunchOfItemsInMail(BunchOfItems, subject, null);
    }

    public final void sendABunchOfItemsInMail(ArrayList<Integer> BunchOfItems, String subject, ArrayList<Integer> bonusListIDs) {
        var trans = new SQLTransaction();
        var _subject = subject;
        var draft = new MailDraft(_subject, "This is a system message. Do not answer! Don't forget to take out the items! :)");

        for (var item : BunchOfItems) {
            Log.outInfo(LogFilter.PlayerItems, "[BunchOfItems]: {}.", item);
            var pItem = item.createItem(item, 1, itemContext.NONE, this);

            if (pItem != null) {
                if (bonusListIDs != null) {
                    for (var bonus : bonusListIDs) {
                        pItem.addBonuses(bonus);
                    }
                }

                pItem.saveToDB(trans);
                draft.addItem(pItem);
            }
        }

        draft.sendMailTo(trans, this, new MailSender(this, MailStationery.gm), MailCheckMask.Copied.getValue() | MailCheckMask.Returned.getValue());
        DB.characters.CommitTransaction(trans);
    }


    public final void gearUpByLoadout(int loadout_purpose, final ArrayList<Integer> bonusListIDs) {
        // Get equipped item and store it in bag. If bag is full store it in toBeMailedCurrentEquipment to send it in mail later.
        var toBeMailedCurrentEquipment = new ArrayList<>();

        for (var es = EquipmentSlot.start; es < EquipmentSlot.End; es++) {
            var currentEquiped = getItemByPos(InventorySlots.Bag0, es);

            if (getItemByPos(InventorySlots.Bag0, es)) {
                var off_dest = new ArrayList<>();

                if (canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, off_dest, currentEquiped, false) == InventoryResult.Ok) {
                    removeItem(InventorySlots.Bag0, es, true);
                    storeItem(off_dest, currentEquiped, true);
                } else {
                    toBeMailedCurrentEquipment.add(currentEquiped);
                }
            }
        }

        // If there are item in the toBeMailedCurrentEquipment vector remove it from inventory and send it in mail.
        if (!toBeMailedCurrentEquipment.isEmpty()) {
            var trans = new SQLTransaction();
            var draft = new MailDraft("Inventory Full: Old Equipment.", "To equip your new gear, your old gear had to be unequiped. You did not have enough free bag space, the items that could not be added to your bag you can find in this mail.");

            for (var currentEquiped : toBeMailedCurrentEquipment) {
                moveItemFromInventory(InventorySlots.Bag0, currentEquiped.getBagSlot(), true);
                item.deleteFromInventoryDB(trans, currentEquiped.getGUID().getCounter()); // deletes item from character's inventory
                currentEquiped.saveToDB(trans); // recursive and not have transaction guard into self, item not in inventory and can be save standalone
                draft.addItem(currentEquiped);
            }

            draft.sendMailTo(trans, this, new MailSender(this, MailStationery.gm), MailCheckMask.Copied.getValue() | MailCheckMask.Returned.getValue());
            DB.characters.CommitTransaction(trans);
        }

        var toBeMailedNewItems = new ArrayList<>();

        // Add the new items from loadout. TODO
        //foreach (uint item in sDB2Manager.GetLowestIdItemLoadOutItemsBy(getClass(), loadout_purpose))
        //{
        //    if (!StoreNewItemInBestSlotsWithBonus(item, 1, bonusListIDs))
        //    {
        //        toBeMailedNewItems.add(item);
        //    }
        //}

        // If we added more item than free bag slot send the new item as well in mail.
        if (!toBeMailedNewItems.isEmpty()) {
            var trans = new SQLTransaction();
            var draft = new MailDraft("Inventory Full: New Gear.", "You did not have enough free bag space to add all your complementary new gear to your bags, those that did not fit you can find in this mail.");

            for (var item : toBeMailedNewItems) {
                var pItem = item.createItem(item, 1, itemContext.NONE, this);

                if (pItem != null) {
                    for (var bonus : bonusListIDs) {
                        pItem.addBonuses(bonus);
                    }

                    pItem.saveToDB(trans);
                    draft.addItem(pItem);
                }
            }

            draft.sendMailTo(trans, this, new MailSender(this, MailStationery.gm), MailCheckMask.Copied.getValue() | MailCheckMask.Returned.getValue());
            DB.characters.CommitTransaction(trans);
        }

        saveToDB();
    }


    public final int getFreeBagSlotCount() {
        int freeBagSlots = 0;

        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            var bag = getBagByPos(i);

            if (bag != null) {
                freeBagSlots += bag.getFreeSlots();
            }
        }

        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
            if (!getItemByPos(InventorySlots.Bag0, i)) {
                ++freeBagSlots;
            }
        }

        return freeBagSlots;
    }


    public final void splitItem(short src, short dst, int count) {
        var srcbag = (byte) (src >>> 8);
        var srcslot = (byte) (src & 255);

        var dstbag = (byte) (dst >>> 8);
        var dstslot = (byte) (dst & 255);

        var pSrcItem = getItemByPos(srcbag, srcslot);

        if (!pSrcItem) {
            sendEquipError(InventoryResult.ItemNotFound, pSrcItem);

            return;
        }

        if (pSrcItem.getLootGenerated()) // prevent split looting item (item
        {
            //best error message found for attempting to split while looting
            sendEquipError(InventoryResult.SplitFailed, pSrcItem);

            return;
        }

        // not let split all items (can be only at cheating)
        if (pSrcItem.getCount() == count) {
            sendEquipError(InventoryResult.SplitFailed, pSrcItem);

            return;
        }

        // not let split more existed items (can be only at cheating)
        if (pSrcItem.getCount() < count) {
            sendEquipError(InventoryResult.TooFewToSplit, pSrcItem);

            return;
        }

        //! If trading
        var tradeData = getTradeData();

        if (tradeData != null) {
            //! If current item is in trade window (only possible with packet spoofing - silent return)
            if (tradeData.getTradeSlotForItem(pSrcItem.getGUID()) != TradeSlots.Invalid) {
                return;
            }
        }

        Log.outDebug(LogFilter.player, "STORAGE: SplitItem bag = {0}, slot = {1}, item = {2}, count = {3}", dstbag, dstslot, pSrcItem.getEntry(), count);
        var pNewItem = pSrcItem.cloneItem(count, this);

        if (!pNewItem) {
            sendEquipError(InventoryResult.ItemNotFound, pSrcItem);

            return;
        }

        if (isInventoryPos(dst)) {
            // change item amount before check (for unique max count check)
            pSrcItem.setCount(pSrcItem.getCount() - count);

            ArrayList<ItemPosCount> dest = new ArrayList<>();
            var msg = canStoreItem(dstbag, dstslot, dest, pNewItem, false);

            if (msg != InventoryResult.Ok) {
                pSrcItem.setCount(pSrcItem.getCount() + count);
                sendEquipError(msg, pSrcItem);

                return;
            }

            if (isInWorld()) {
                pSrcItem.sendUpdateToPlayer(this);
            }

            pSrcItem.setState(ItemUpdateState.changed, this);
            storeItem(dest, pNewItem, true);
        } else if (isBankPos(dst)) {
            // change item amount before check (for unique max count check)
            pSrcItem.setCount(pSrcItem.getCount() - count);

            ArrayList<ItemPosCount> dest = new ArrayList<>();
            var msg = canBankItem(dstbag, dstslot, dest, pNewItem, false);

            if (msg != InventoryResult.Ok) {
                pSrcItem.setCount(pSrcItem.getCount() + count);
                sendEquipError(msg, pSrcItem);

                return;
            }

            if (isInWorld()) {
                pSrcItem.sendUpdateToPlayer(this);
            }

            pSrcItem.setState(ItemUpdateState.changed, this);
            bankItem(dest, pNewItem, true);
        } else if (isEquipmentPos(dst)) {
            // change item amount before check (for unique max count check), provide space for splitted items
            pSrcItem.setCount(pSrcItem.getCount() - count);

            short dest;
            tangible.OutObject<SHORT> tempOut_dest = new tangible.OutObject<SHORT>();
            var msg = canEquipItem(dstslot, tempOut_dest, pNewItem, false);
            dest = tempOut_dest.outArgValue;

            if (msg != InventoryResult.Ok) {
                pSrcItem.setCount(pSrcItem.getCount() + count);
                sendEquipError(msg, pSrcItem);

                return;
            }

            if (isInWorld()) {
                pSrcItem.sendUpdateToPlayer(this);
            }

            pSrcItem.setState(ItemUpdateState.changed, this);
            equipItem(dest, pNewItem, true);
            autoUnequipOffhandIfNeed();
        }
    }


    public final void swapItem(short src, short dst) {
        var srcbag = (byte) (src >>> 8);
        var srcslot = (byte) (src & 255);

        var dstbag = (byte) (dst >>> 8);
        var dstslot = (byte) (dst & 255);

        var pSrcItem = getItemByPos(srcbag, srcslot);
        var pDstItem = getItemByPos(dstbag, dstslot);

        if (pSrcItem == null) {
            return;
        }

        if (pSrcItem.hasItemFlag(ItemFieldFlags.Child)) {
            var parentItem = getItemByGuid(pSrcItem.getItemData().creator);

            if (parentItem) {
                if (isEquipmentPos(src)) {
                    autoUnequipChildItem(parentItem); // we need to unequip child first since it cannot go into whatever is going to happen next
                    swapItem(dst, src); // src is now empty
                    swapItem(parentItem.getPos(), dst); // dst is now empty

                    return;
                }
            }
        } else if (pDstItem && pDstItem.hasItemFlag(ItemFieldFlags.Child)) {
            var parentItem = getItemByGuid(pDstItem.getItemData().creator);

            if (parentItem) {
                if (isEquipmentPos(dst)) {
                    autoUnequipChildItem(parentItem); // we need to unequip child first since it cannot go into whatever is going to happen next
                    swapItem(src, dst); // dst is now empty
                    swapItem(parentItem.getPos(), src); // src is now empty

                    return;
                }
            }
        }

        Log.outDebug(LogFilter.player, "STORAGE: SwapItem bag = {0}, slot = {1}, item = {2}", dstbag, dstslot, pSrcItem.getEntry());

        if (!isAlive()) {
            sendEquipError(InventoryResult.PlayerDead, pSrcItem, pDstItem);

            return;
        }

        // SRC checks

        // check unequip potability for equipped items and bank bags
        if (isEquipmentPos(src) || isBagPos(src)) {
            // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
            var msg = canUnequipItem(src, !isBagPos(src) || isBagPos(dst) || (pDstItem != null && pDstItem.getAsBag() != null && pDstItem.getAsBag().isEmpty()));

            if (msg != InventoryResult.Ok) {
                sendEquipError(msg, pSrcItem, pDstItem);

                return;
            }
        }

        // prevent put equipped/bank bag in self
        if (isBagPos(src) && srcslot == dstbag) {
            sendEquipError(InventoryResult.BagInBag, pSrcItem, pDstItem);

            return;
        }

        // prevent equipping bag in the same slot from its inside
        if (isBagPos(dst) && srcbag == dstslot) {
            sendEquipError(InventoryResult.CantSwap, pSrcItem, pDstItem);

            return;
        }

        // DST checks
        if (pDstItem != null) {
            // check unequip potability for equipped items and bank bags
            if (isEquipmentPos(dst) || isBagPos(dst)) {
                // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
                var msg = canUnequipItem(dst, !isBagPos(dst) || isBagPos(src) || (pSrcItem.getAsBag() != null && pSrcItem.getAsBag().isEmpty()));

                if (msg != InventoryResult.Ok) {
                    sendEquipError(msg, pSrcItem, pDstItem);

                    return;
                }
            }
        }

        if (isReagentBankPos(dst) && !isReagentBankUnlocked()) {
            sendEquipError(InventoryResult.ReagentBankLocked, pSrcItem, pDstItem);

            return;
        }

        // NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
        // or swap empty bag with another empty or not empty bag (with items exchange)

        // Move case
        if (pDstItem == null) {
            if (isInventoryPos(dst)) {
                ArrayList<ItemPosCount> dest = new ArrayList<>();
                var msg = canStoreItem(dstbag, dstslot, dest, pSrcItem, false);

                if (msg != InventoryResult.Ok) {
                    sendEquipError(msg, pSrcItem);

                    return;
                }

                removeItem(srcbag, srcslot, true);
                storeItem(dest, pSrcItem, true);

                if (isBankPos(src)) {
                    itemAddedQuestCheck(pSrcItem.getEntry(), pSrcItem.getCount());
                }
            } else if (isBankPos(dst)) {
                ArrayList<ItemPosCount> dest = new ArrayList<>();
                var msg = canBankItem(dstbag, dstslot, dest, pSrcItem, false);

                if (msg != InventoryResult.Ok) {
                    sendEquipError(msg, pSrcItem);

                    return;
                }

                removeItem(srcbag, srcslot, true);
                bankItem(dest, pSrcItem, true);

                if (!isReagentBankPos(dst)) {
                    itemRemovedQuestCheck(pSrcItem.getEntry(), pSrcItem.getCount());
                }
            } else if (isEquipmentPos(dst)) {
                short _dest;
                tangible.OutObject<SHORT> tempOut__dest = new tangible.OutObject<SHORT>();
                var msg = canEquipItem(dstslot, tempOut__dest, pSrcItem, false);
                _dest = tempOut__dest.outArgValue;

                if (msg != InventoryResult.Ok) {
                    sendEquipError(msg, pSrcItem);

                    return;
                }

                removeItem(srcbag, srcslot, true);
                equipItem(_dest, pSrcItem, true);
                autoUnequipOffhandIfNeed();
            }

            return;
        }

        // attempt merge to / fill target item
        if (!pSrcItem.isBag() && !pDstItem.isBag()) {
            InventoryResult msg;
            ArrayList<ItemPosCount> sDest = new ArrayList<>();
            short eDest = 0;

            if (isInventoryPos(dst)) {
                msg = canStoreItem(dstbag, dstslot, sDest, pSrcItem, false);
            } else if (isBankPos(dst)) {
                msg = canBankItem(dstbag, dstslot, sDest, pSrcItem, false);
            } else if (isEquipmentPos(dst)) {
                tangible.OutObject<SHORT> tempOut_eDest = new tangible.OutObject<SHORT>();
                msg = canEquipItem(dstslot, tempOut_eDest, pSrcItem, false);
                eDest = tempOut_eDest.outArgValue;
            } else {
                return;
            }

            if (msg == InventoryResult.Ok && isEquipmentPos(dst) && !pSrcItem.getChildItem().isEmpty()) {
                msg = canEquipChildItem(pSrcItem);
            }

            // can be merge/fill
            if (msg == InventoryResult.Ok) {
                if (pSrcItem.getCount() + pDstItem.getCount() <= pSrcItem.getTemplate().getMaxStackSize()) {
                    removeItem(srcbag, srcslot, true);

                    if (isInventoryPos(dst)) {
                        storeItem(sDest, pSrcItem, true);
                    } else if (isBankPos(dst)) {
                        bankItem(sDest, pSrcItem, true);
                    } else if (isEquipmentPos(dst)) {
                        equipItem(eDest, pSrcItem, true);

                        if (!pSrcItem.getChildItem().isEmpty()) {
                            equipChildItem(srcbag, srcslot, pSrcItem);
                        }

                        autoUnequipOffhandIfNeed();
                    }
                } else {
                    pSrcItem.setCount(pSrcItem.getCount() + pDstItem.getCount() - pSrcItem.getTemplate().getMaxStackSize());
                    pDstItem.setCount(pSrcItem.getTemplate().getMaxStackSize());
                    pSrcItem.setState(ItemUpdateState.changed, this);
                    pDstItem.setState(ItemUpdateState.changed, this);

                    if (isInWorld()) {
                        pSrcItem.sendUpdateToPlayer(this);
                        pDstItem.sendUpdateToPlayer(this);
                    }
                }

                sendRefundInfo(pDstItem);

                return;
            }
        }

        // impossible merge/fill, do real swap
        var _msg = InventoryResult.Ok;

        // check src.dest move possibility
        ArrayList<ItemPosCount> _sDest = new ArrayList<>();
        short _eDest = 0;

        if (isInventoryPos(dst)) {
            _msg = canStoreItem(dstbag, dstslot, _sDest, pSrcItem, true);
        } else if (isBankPos(dst)) {
            _msg = canBankItem(dstbag, dstslot, _sDest, pSrcItem, true);
        } else if (isEquipmentPos(dst)) {
            tangible.OutObject<SHORT> tempOut__eDest = new tangible.OutObject<SHORT>();
            _msg = canEquipItem(dstslot, tempOut__eDest, pSrcItem, true);
            _eDest = tempOut__eDest.outArgValue;

            if (_msg == InventoryResult.Ok) {
                _msg = canUnequipItem(_eDest, true);
            }
        }

        if (_msg != InventoryResult.Ok) {
            sendEquipError(_msg, pSrcItem, pDstItem);

            return;
        }

        // check dest.src move possibility
        ArrayList<ItemPosCount> sDest2 = new ArrayList<>();
        short eDest2 = 0;

        if (isInventoryPos(src)) {
            _msg = canStoreItem(srcbag, srcslot, sDest2, pDstItem, true);
        } else if (isBankPos(src)) {
            _msg = canBankItem(srcbag, srcslot, sDest2, pDstItem, true);
        } else if (isEquipmentPos(src)) {
            tangible.OutObject<SHORT> tempOut_eDest2 = new tangible.OutObject<SHORT>();
            _msg = canEquipItem(srcslot, tempOut_eDest2, pDstItem, true);
            eDest2 = tempOut_eDest2.outArgValue;

            if (_msg == InventoryResult.Ok) {
                _msg = canUnequipItem(eDest2, true);
            }
        }

        if (_msg == InventoryResult.Ok && isEquipmentPos(dst) && !pSrcItem.getChildItem().isEmpty()) {
            _msg = canEquipChildItem(pSrcItem);
        }

        if (_msg != InventoryResult.Ok) {
            sendEquipError(_msg, pDstItem, pSrcItem);

            return;
        }

        // Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
        var srcBag = pSrcItem.getAsBag();

        if (srcBag != null) {
            var dstBag = pDstItem.getAsBag();

            if (dstBag != null) {
                Bag emptyBag = null;
                Bag fullBag = null;

                if (srcBag.isEmpty() && !isBagPos(src)) {
                    emptyBag = srcBag;
                    fullBag = dstBag;
                } else if (dstBag.isEmpty() && !isBagPos(dst)) {
                    emptyBag = dstBag;
                    fullBag = srcBag;
                }

                // bag swap (with items exchange) case
                if (emptyBag != null && fullBag != null) {
                    var emptyProto = emptyBag.getTemplate();
                    byte count = 0;

                    for (byte i = 0; i < fullBag.getBagSize(); ++i) {
                        var bagItem = fullBag.getItemByPos(i);

                        if (bagItem == null) {
                            continue;
                        }

                        var bagItemProto = bagItem.getTemplate();

                        if (!item.itemCanGoIntoBag(bagItemProto, emptyProto)) {
                            // one from items not go to empty target bag
                            sendEquipError(InventoryResult.BagInBag, pSrcItem, pDstItem);

                            return;
                        }

                        ++count;
                    }

                    if (count > emptyBag.getBagSize()) {
                        // too small targeted bag
                        sendEquipError(InventoryResult.CantSwap, pSrcItem, pDstItem);

                        return;
                    }

                    // Items swap
                    count = 0; // will pos in new bag

                    for (byte i = 0; i < fullBag.getBagSize(); ++i) {
                        var bagItem = fullBag.getItemByPos(i);

                        if (bagItem == null) {
                            continue;
                        }

                        fullBag.removeItem(i, true);
                        emptyBag.storeItem(count, bagItem, true);
                        bagItem.setState(ItemUpdateState.changed, this);

                        ++count;
                    }
                }
            }
        }

        // now do moves, remove...
        removeItem(dstbag, dstslot, false);
        removeItem(srcbag, srcslot, false);

        // add to dest
        if (isInventoryPos(dst)) {
            storeItem(_sDest, pSrcItem, true);
        } else if (isBankPos(dst)) {
            bankItem(_sDest, pSrcItem, true);
        } else if (isEquipmentPos(dst)) {
            equipItem(_eDest, pSrcItem, true);

            if (!pSrcItem.getChildItem().isEmpty()) {
                equipChildItem(srcbag, srcslot, pSrcItem);
            }
        }

        // add to src
        if (isInventoryPos(src)) {
            storeItem(sDest2, pDstItem, true);
        } else if (isBankPos(src)) {
            bankItem(sDest2, pDstItem, true);
        } else if (isEquipmentPos(src)) {
            equipItem(eDest2, pDstItem, true);
        }

        // if inventory item was moved, check if we can remove dependent auras, because they were not removed in Player::RemoveItem (update was set to false)
        // do this after swaps are done, we pass nullptr because both weapons could be swapped and none of them should be ignored
        if ((srcbag == InventorySlots.Bag0 && srcslot < InventorySlots.BagEnd) || (dstbag == InventorySlots.Bag0 && dstslot < InventorySlots.BagEnd)) {
            applyItemDependentAuras(null, false);
        }

        // if player is moving bags and is looting an item inside this bag
        // release the loot
        if (!getAELootView().isEmpty()) {
            var released = false;

            if (isBagPos(src)) {
                var bag = pSrcItem.getAsBag();

                for (byte i = 0; i < bag.getBagSize(); ++i) {
                    var bagItem = bag.getItemByPos(i);

                    if (bagItem != null) {
                        if (getLootByWorldObjectGUID(bagItem.getGUID()) != null) {
                            getSession().doLootReleaseAll();
                            released = true; // so we don't need to look at dstBag

                            break;
                        }
                    }
                }
            }

            if (!released && isBagPos(dst)) {
                var bag = pDstItem.getAsBag();

                for (byte i = 0; i < bag.getBagSize(); ++i) {
                    var bagItem = bag.getItemByPos(i);

                    if (bagItem != null) {
                        if (getLootByWorldObjectGUID(bagItem.getGUID()) != null) {
                            getSession().doLootReleaseAll();

                            break;
                        }
                    }
                }
            }
        }

        autoUnequipOffhandIfNeed();
    }

    public final void sendNewItem(Item item, int quantity, boolean pushed, boolean created, boolean broadcast) {
        sendNewItem(item, quantity, pushed, created, broadcast, 0);
    }

    public final void sendNewItem(Item item, int quantity, boolean pushed, boolean created) {
        sendNewItem(item, quantity, pushed, created, false, 0);
    }

    public final void sendNewItem(Item item, int quantity, boolean pushed, boolean created, boolean broadcast, int dungeonEncounterId) {
        if (item == null) // prevent crash
        {
            return;
        }

        ItemPushResult packet = new ItemPushResult();

        packet.playerGUID = getGUID();

        packet.slot = item.getBagSlot();
        packet.slotInBag = item.getCount() == quantity ? item.getSlot() : -1;

        packet.item = new itemInstance(item);

        //packet.questLogItemID;
        packet.quantity = quantity;
        packet.quantityInInventory = getItemCount(item.getEntry());
        packet.battlePetSpeciesID = item.getModifier(ItemModifier.battlePetSpeciesId);
        packet.battlePetBreedID = item.getModifier(ItemModifier.BattlePetBreedData) & 0xFFFFFF;
        packet.battlePetBreedQuality = (item.getModifier(ItemModifier.BattlePetBreedData) >>> 24) & 0xFF;
        packet.battlePetLevel = item.getModifier(ItemModifier.battlePetLevel);

        packet.itemGUID = item.getGUID();

        packet.pushed = pushed;
        packet.displayText = ItemPushResult.displayType.NORMAL;
        packet.created = created;
        //packet.isBonusRoll;

        if (dungeonEncounterId != 0) {
            packet.displayText = ItemPushResult.displayType.EncounterLoot;
            packet.dungeonEncounterID = dungeonEncounterId;
            packet.isEncounterLoot = true;
        }

        if (broadcast && getGroup() && !item.getTemplate().hasFlag(ItemFlags3.DontReportLootLogToParty)) {
            getGroup().broadcastPacket(packet, true);
        } else {
            sendPacket(packet);
        }
    }


    public final void toggleMetaGemsActive(int exceptslot, boolean apply) {
        //cycle all equipped items
        for (var slot = EquipmentSlot.start; slot < EquipmentSlot.End; ++slot) {
            //enchants for the slot being socketed are handled by WorldSession.HandleSocketOpcode(WorldPacket& recvData)
            if (slot == exceptslot) {
                continue;
            }

            var pItem = getItemByPos(InventorySlots.Bag0, slot);

            if (!pItem || pItem.getSocketColor(0) == 0) //if item has no sockets or no item is equipped go to next item
            {
                continue;
            }

            //cycle all (gem)enchants
            for (var enchant_slot = EnchantmentSlot.Sock1; enchant_slot.getValue() < EnchantmentSlot.Sock1.getValue() + 3; ++enchant_slot) {
                var enchant_id = pItem.getEnchantmentId(enchant_slot);

                if (enchant_id == 0) //if no enchant go to next enchant(slot)
                {
                    continue;
                }

                var enchantEntry = CliDB.SpellItemEnchantmentStorage.get(enchant_id);

                if (enchantEntry == null) {
                    continue;
                }

                //only metagems to be (de)activated, so only enchants with condition
                int condition = enchantEntry.ConditionID;

                if (condition != 0) {
                    applyEnchantment(pItem, enchant_slot, apply);
                }
            }
        }
    }

    public final float getAverageItemLevel() {
        float sum = 0;
        int count = 0;

        for (int i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
            // don't check tabard, ranged, offhand or shirt
            if (i == EquipmentSlot.Tabard || i == EquipmentSlot.Ranged || i == EquipmentSlot.OffHand || i == EquipmentSlot.Shirt) {
                continue;
            }

            if (_items[i] != null) {
                sum += _items[i].getItemLevel(this);
            }

            ++count;
        }

        return sum / count;
    }

    public final ArrayList<item> getCraftingReagentItemsToDeposit() {
        ArrayList<item> itemList = new ArrayList<>();

        forEachItem(ItemSearchLocation.Inventory, item ->
        {
            if (item.template.IsCraftingReagent) {
                itemList.add(item);
            }

            return true;
        });

        return itemList;
    }

    public final Item getItemByGuid(ObjectGuid guid) {
        Item result = null;

        forEachItem(ItemSearchLocation.Everywhere, item ->
        {
            if (Objects.equals(item.GUID, guid)) {
                result = item;

                return false;
            }

            return true;
        });

        return result;
    }

    public final int getItemCount(int item, boolean inBankAlso) {
        return getItemCount(item, inBankAlso, null);
    }

    public final int getItemCount(int item) {
        return getItemCount(item, false, null);
    }

    public final int getItemCount(int item, boolean inBankAlso, Item skipItem) {
        var countGems = skipItem != null && skipItem.getTemplate().getGemProperties() != 0;

        var location = ItemSearchLocation.forValue(ItemSearchLocation.Equipment.getValue() | ItemSearchLocation.Inventory.getValue().getValue() | ItemSearchLocation.ReagentBank.getValue().getValue());

        if (inBankAlso) {
            location = ItemSearchLocation.forValue(location.getValue() | ItemSearchLocation.Bank.getValue());
        }

        int count = 0;

        forEachItem(location, pItem ->
        {
            if (pItem != skipItem) {
                if (pItem.entry == item) {
                    count += pItem.count;
                }

                if (countGems) {
                    count += pItem.getGemCountWithID(item);
                }
            }

            return true;
        });

        return count;
    }


    public final Item getUseableItemByPos(byte bag, byte slot) {
        var item = getItemByPos(bag, slot);

        if (!item) {
            return null;
        }

        if (!canUseAttackType(getAttackBySlot(slot, item.getTemplate().getInventoryType()))) {
            return null;
        }

        return item;
    }


    public final Item getItemByPos(short pos) {
        var bag = (byte) (pos >>> 8);
        var slot = (byte) (pos & 255);

        return getItemByPos(bag, slot);
    }


    public final Item getItemByPos(byte bag, byte slot) {
        if (bag == InventorySlots.Bag0 && slot < PlayerSlot.End.getValue() && (slot < InventorySlots.BuyBackStart || slot >= InventorySlots.BuyBackEnd)) {
            return _items[slot];
        }

        var pBag = getBagByPos(bag);

        if (pBag != null) {
            return pBag.getItemByPos(slot);
        }

        return null;
    }

    public final Item getItemByEntry(int entry) {
        return getItemByEntry(entry, ItemSearchLocation.Default);
    }

    public final Item getItemByEntry(int entry, ItemSearchLocation where) {
        Item result = null;

        forEachItem(where, item ->
        {
            if (item.entry == entry) {
                result = item;

                return false;
            }

            return true;
        });

        return result;
    }

    public final ArrayList<item> getItemListByEntry(int entry) {
        return getItemListByEntry(entry, false);
    }

    public final ArrayList<item> getItemListByEntry(int entry, boolean inBankAlso) {
        var location = ItemSearchLocation.forValue(ItemSearchLocation.Equipment.getValue() | ItemSearchLocation.Inventory.getValue().getValue() | ItemSearchLocation.ReagentBank.getValue().getValue());

        if (inBankAlso) {
            location = ItemSearchLocation.forValue(location.getValue() | ItemSearchLocation.Bank.getValue());
        }

        ArrayList<item> itemList = new ArrayList<>();

        forEachItem(location, item ->
        {
            if (item.entry == entry) {
                itemList.add(item);
            }

            return true;
        });

        return itemList;
    }

    public final boolean hasItemCount(int item, int count) {
        return hasItemCount(item, count, false);
    }

    public final boolean hasItemCount(int item) {
        return hasItemCount(item, 1, false);
    }

    public final boolean hasItemCount(int item, int count, boolean inBankAlso) {
        var location = ItemSearchLocation.forValue(ItemSearchLocation.Equipment.getValue() | ItemSearchLocation.Inventory.getValue().getValue() | ItemSearchLocation.ReagentBank.getValue().getValue());

        if (inBankAlso) {
            location = ItemSearchLocation.forValue(location.getValue() | ItemSearchLocation.Bank.getValue());
        }

        int currentCount = 0;

        return !forEachItem(location, pItem ->
        {
            if (pItem && pItem.entry == item && !pItem.IsInTrade) {
                currentCount += pItem.count;

                if (currentCount >= count) {
                    return false;
                }
            }

            return true;
        });
    }


    public final boolean isValidPos(byte bag, byte slot, boolean explicit_pos) {
        // post selected
        if (bag == ItemConst.NullBag && !explicit_pos) {
            return true;
        }

        if (bag == InventorySlots.Bag0) {
            // any post selected
            if (slot == ItemConst.NullSlot && !explicit_pos) {
                return true;
            }

            // equipment
            if (slot < EquipmentSlot.End) {
                return true;
            }

            // profession equipment
            if (slot >= ProfessionSlots.start && slot < ProfessionSlots.End) {
                return true;
            }

            // bag equip slots
            if (slot >= InventorySlots.BagStart && slot < InventorySlots.BagEnd) {
                return true;
            }

            // reagent bag equip slots
            if (slot >= InventorySlots.ReagentBagStart && slot < InventorySlots.ReagentBagEnd) {
                return true;
            }

            // backpack slots
            if (slot >= InventorySlots.ItemStart && slot < InventorySlots.ItemStart + getInventorySlotCount()) {
                return true;
            }

            // bank main slots
            if (slot >= InventorySlots.BankItemStart && slot < InventorySlots.BankItemEnd) {
                return true;
            }

            // bank bag slots
            if (slot >= InventorySlots.BankBagStart && slot < InventorySlots.BankBagEnd) {
                return true;
            }

            // reagent bank bag slots
            return slot >= InventorySlots.ReagentStart && slot < InventorySlots.ReagentEnd;
        }

        // bag content slots
        // bank bag content slots
        var pBag = getBagByPos(bag);

        if (pBag != null) {
            // any post selected
            if (slot == ItemConst.NullSlot && !explicit_pos) {
                return true;
            }

            return slot < pBag.getBagSize();
        }

        // where this?
        return false;
    }

    public final Item getChildItemByGuid(ObjectGuid guid) {
        Item result = null;

        forEachItem(ItemSearchLocation.Equipment.getValue() | ItemSearchLocation.Inventory.getValue(), item ->
        {
            if (Objects.equals(item.GUID, guid)) {
                result = item;

                return false;
            }

            return true;
        });

        return result;
    }


    public final byte getItemLimitCategoryQuantity(ItemLimitCategoryRecord limitEntry) {
        var limit = limitEntry.quantity;

        var limitConditions = global.getDB2Mgr().GetItemLimitCategoryConditions(limitEntry.id);

        for (var limitCondition : limitConditions) {
            var playerCondition = CliDB.PlayerConditionStorage.get(limitCondition.playerConditionID);

            if (playerCondition == null || ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                limit += (byte) limitCondition.AddQuantity;
            }
        }

        return limit;
    }

    public final void destroyConjuredItems(boolean update) {
        // used when entering arena
        // destroys all conjured items
        Log.outDebug(LogFilter.player, "STORAGE: DestroyConjuredItems");

        // in inventory
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem) {
                if (pItem.isConjuredConsumable()) {
                    destroyItem(InventorySlots.Bag0, i, update);
                }
            }
        }

        // in inventory bags
        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            var pBag = getBagByPos(i);

            if (pBag) {
                for (byte j = 0; j < pBag.getBagSize(); j++) {
                    var pItem = pBag.getItemByPos(j);

                    if (pItem) {
                        if (pItem.isConjuredConsumable()) {
                            destroyItem(i, j, update);
                        }
                    }
                }
            }
        }

        // in equipment and bag list
        for (var i = EquipmentSlot.start; i < InventorySlots.BagEnd; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem) {
                if (pItem.isConjuredConsumable()) {
                    destroyItem(InventorySlots.Bag0, i, update);
                }
            }
        }
    }

    public final InventoryResult canRollNeedForItem(ItemTemplate proto, Map map, boolean restrictOnlyLfg) {
        if (restrictOnlyLfg) {
            if (!getGroup() || !getGroup().isLFGGroup()) {
                return InventoryResult.Ok; // not in LFG group
            }

            // check if looted object is inside the lfg dungeon
            if (!global.getLFGMgr().inLfgDungeonMap(getGroup().getGUID(), map.getId(), map.getDifficultyID())) {
                return InventoryResult.Ok;
            }
        }

        if (proto == null) {
            return InventoryResult.ItemNotFound;
        }

        // Used by group, function GroupLoot, to know if a prototype can be used by a player
        if ((proto.getAllowableClass() & getClassMask()) == 0 || (proto.getAllowableRace() & (long) SharedConst.GetMaskForRace(getRace())) == 0) {
            return InventoryResult.CantEquipEver;
        }

        if (proto.getRequiredSpell() != 0 && !hasSpell(proto.getRequiredSpell())) {
            return InventoryResult.ProficiencyNeeded;
        }

        if (proto.getRequiredSkill() != 0) {
            if (getSkillValue(SkillType.forValue(proto.getRequiredSkill())) == 0) {
                return InventoryResult.ProficiencyNeeded;
            } else if (getSkillValue(SkillType.forValue(proto.getRequiredSkill())).getValue() < proto.getRequiredSkillRank()) {
                return InventoryResult.CantEquipSkill;
            }
        }

        if (proto.getClass() == itemClass.Weapon && getSkillValue(proto.getSkill()) == 0) {
            return InventoryResult.ProficiencyNeeded;
        }

        if (proto.getClass() == itemClass.armor && proto.getInventoryType() != inventoryType.Cloak) {
            var classesEntry = CliDB.ChrClassesStorage.get(getClass());

            if ((classesEntry.ArmorTypeMask & 1 << proto.getSubClass()) == 0) {
                return InventoryResult.ClientLockedOut;
            }
        }

        return InventoryResult.Ok;
    }

    public final void addItemToBuyBackSlot(Item pItem) {
        if (pItem != null) {
            var slot = currentBuybackSlot;

            // if current back slot non-empty search oldest or free
            if (_items[slot] != null) {
                var oldest_time = getActivePlayerData().buybackTimestamp.get(0);
                int oldest_slot = InventorySlots.BuyBackStart;

                for (byte i = InventorySlots.BuyBackStart + 1; i < InventorySlots.BuyBackEnd; ++i) {
                    // found empty
                    if (!_items[i]) {
                        oldest_slot = i;

                        break;
                    }

                    var i_time = getActivePlayerData().buybackTimestamp.get(i - InventorySlots.BuyBackStart);

                    if (oldest_time > i_time) {
                        oldest_time = i_time;
                        oldest_slot = i;
                    }
                }

                // find oldest
                slot = oldest_slot;
            }

            removeItemFromBuyBackSlot(slot, true);
            Log.outDebug(LogFilter.player, "STORAGE: AddItemToBuyBackSlot item = {0}, slot = {1}", pItem.getEntry(), slot);

            _items[slot] = pItem;
            var time = gameTime.GetGameTime();
            var etime = (int) (time - logintime + (30 * 3600));
            var eslot = slot - InventorySlots.BuyBackStart;

            setInvSlot(slot, pItem.getGUID());
            var proto = pItem.getTemplate();

            if (proto != null) {
                setBuybackPrice(eslot, proto.getSellPrice() * pItem.getCount());
            } else {
                setBuybackPrice(eslot, 0);
            }

            setBuybackTimestamp(eslot, etime);

            // move to next (for non filled list is move most optimized choice)
            if (currentBuybackSlot < InventorySlots.BuyBackEnd - 1) {
                ++currentBuybackSlot;
            }
        }
    }


    public final boolean buyCurrencyFromVendorSlot(ObjectGuid vendorGuid, int vendorSlot, int currency, int count) {
        // cheating attempt
        if (count < 1) {
            count = 1;
        }

        if (!isAlive()) {
            return false;
        }

        var proto = CliDB.CurrencyTypesStorage.get(currency);

        if (proto == null) {
            sendBuyError(BuyResult.CantFindItem, null, currency);

            return false;
        }

        var creature = getNPCIfCanInteractWith(vendorGuid, NPCFlags.vendor, NPCFlags2.NONE);

        if (!creature) {
            Log.outDebug(LogFilter.Network, "WORLD: BuyCurrencyFromVendorSlot - {0} not found or you can't interact with him.", vendorGuid.toString());
            sendBuyError(BuyResult.DistanceTooFar, null, currency);

            return false;
        }

        var vItems = creature.getVendorItems();

        if (vItems == null || vItems.isEmpty()) {
            sendBuyError(BuyResult.CantFindItem, creature, currency);

            return false;
        }

        if (vendorSlot >= vItems.getItemCount()) {
            sendBuyError(BuyResult.CantFindItem, creature, currency);

            return false;
        }

        var crItem = vItems.getItem(vendorSlot);

        // store diff item (cheating)
        if (crItem == null || crItem.getItem() != currency || crItem.getType() != ItemVendorType.currency) {
            sendBuyError(BuyResult.CantFindItem, creature, currency);

            return false;
        }

        if ((count % crItem.getMaxcount()) != 0) {
            sendEquipError(InventoryResult.CantBuyQuantity);

            return false;
        }

        var stacks = count / crItem.getMaxcount();
        ItemExtendedCostRecord iece;

        if (crItem.getExtendedCost() != 0) {
            iece = CliDB.ItemExtendedCostStorage.get(crItem.getExtendedCost());

            if (iece == null) {
                Log.outError(LogFilter.player, "Currency {0} have wrong ExtendedCost field second {1}", currency, crItem.getExtendedCost());

                return false;
            }

            for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) {
                if (iece.ItemID[i] != 0 && !hasItemCount(iece.ItemID[i], (iece.ItemCount[i] * stacks))) {
                    sendEquipError(InventoryResult.VendorMissingTurnins);

                    return false;
                }
            }

            for (byte i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) {
                if (iece.CurrencyID[i] == 0) {
                    continue;
                }

                var entry = CliDB.CurrencyTypesStorage.get(iece.CurrencyID[i]);

                if (entry == null) {
                    sendBuyError(BuyResult.CantFindItem, creature, currency); // Find correct error

                    return false;
                }

                if (iece.flags.hasFlag((byte) ((int) ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                    // Not implemented
                    sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                    return false;
                } else if (!hasCurrency(iece.CurrencyID[i], (iece.CurrencyCount[i] * stacks))) {
                    sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                    return false;
                }
            }

            // check for personal arena rating requirement
            if (getMaxPersonalArenaRatingRequirement(iece.ArenaBracket) < iece.RequiredArenaRating) {
                // probably not the proper equip err
                sendEquipError(InventoryResult.CantEquipRank);

                return false;
            }

            if (iece.MinFactionID != 0 && (int) getReputationRank(iece.MinFactionID).getValue() < iece.RequiredAchievement) {
                sendBuyError(BuyResult.ReputationRequire, creature, currency);

                return false;
            }

            if (iece.flags.hasFlag((byte) ItemExtendedCostFlags.RequireGuild.getValue()) && getGuildId() == 0) {
                sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                return false;
            }

            if (iece.RequiredAchievement != 0 && !hasAchieved(iece.RequiredAchievement)) {
                sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                return false;
            }
        } else // currencies have no price defined, can only be bought with ExtendedCost
        {
            sendBuyError(BuyResult.CantFindItem, null, currency);

            return false;
        }

        addCurrency(currency, count, CurrencyGainSource.vendor);

        if (iece != null) {
            for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) {
                if (iece.ItemID[i] == 0) {
                    continue;
                }

                destroyItemCount(iece.ItemID[i], iece.ItemCount[i] * stacks, true);
            }

            for (byte i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) {
                if (iece.CurrencyID[i] == 0) {
                    continue;
                }

                if (iece.flags.hasFlag((byte) ((int) ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                    continue;
                }

                removeCurrency(iece.CurrencyID[i], (int) (iece.CurrencyCount[i] * stacks), CurrencyDestroyReason.vendor);
            }
        }

        return true;
    }


    public final boolean buyItemFromVendorSlot(ObjectGuid vendorguid, int vendorslot, int item, byte count, byte bag, byte slot) {
        // cheating attempt
        if (count < 1) {
            count = 1;
        }

        // cheating attempt
        if (slot > ItemConst.MaxBagSize && slot != ItemConst.NullSlot) {
            return false;
        }

        if (!isAlive()) {
            return false;
        }

        var pProto = global.getObjectMgr().getItemTemplate(item);

        if (pProto == null) {
            sendBuyError(BuyResult.CantFindItem, null, item);

            return false;
        }

        if (!(boolean) (pProto.getAllowableClass() & getClassMask()) && pProto.getBonding() == ItemBondingType.OnAcquire && !isGameMaster()) {
            sendBuyError(BuyResult.CantFindItem, null, item);

            return false;
        }

        if (!isGameMaster() && ((pProto.hasFlag(ItemFlags2.FactionHorde) && getTeam() == Team.ALLIANCE) || (pProto.hasFlag(ItemFlags2.FactionAlliance) && getTeam() == Team.Horde))) {
            return false;
        }

        var creature = getNPCIfCanInteractWith(vendorguid, NPCFlags.vendor, NPCFlags2.NONE);

        if (!creature) {
            Log.outDebug(LogFilter.Network, "WORLD: BuyItemFromVendor - {0} not found or you can't interact with him.", vendorguid.toString());
            sendBuyError(BuyResult.DistanceTooFar, null, item);

            return false;
        }

        if (!global.getConditionMgr().isObjectMeetingVendorItemConditions(creature.getEntry(), item, this, creature)) {
            Log.outDebug(LogFilter.condition, "BuyItemFromVendor: conditions not met for creature entry {0} item {1}", creature.getEntry(), item);
            sendBuyError(BuyResult.CantFindItem, creature, item);

            return false;
        }

        var vItems = creature.getVendorItems();

        if (vItems == null || vItems.isEmpty()) {
            sendBuyError(BuyResult.CantFindItem, creature, item);

            return false;
        }

        if (vendorslot >= vItems.getItemCount()) {
            sendBuyError(BuyResult.CantFindItem, creature, item);

            return false;
        }

        var crItem = vItems.getItem(vendorslot);

        // store diff item (cheating)
        if (crItem == null || crItem.getItem() != item) {
            sendBuyError(BuyResult.CantFindItem, creature, item);

            return false;
        }

        var playerCondition = CliDB.PlayerConditionStorage.get(crItem.getPlayerConditionId());

        if (playerCondition != null) {
            if (!ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                sendEquipError(InventoryResult.ItemLocked);

                return false;
            }
        }

        // check current item amount if it limited
        if (crItem.getMaxcount() != 0) {
            if (creature.getVendorItemCurrentCount(crItem) < count) {
                sendBuyError(BuyResult.ItemAlreadySold, creature, item);

                return false;
            }
        }

        if (pProto.getRequiredReputationFaction() != 0 && ((int) getReputationRank(pProto.getRequiredReputationFaction()).getValue() < pProto.getRequiredReputationRank())) {
            sendBuyError(BuyResult.ReputationRequire, creature, item);

            return false;
        }

        if (crItem.getExtendedCost() != 0) {
            // Can only buy full stacks for extended cost
            if ((count % pProto.getBuyCount()) != 0) {
                sendEquipError(InventoryResult.CantBuyQuantity);

                return false;
            }

            var stacks = count / pProto.getBuyCount();
            var iece = CliDB.ItemExtendedCostStorage.get(crItem.getExtendedCost());

            if (iece == null) {
                Log.outError(LogFilter.player, "Item {0} have wrong ExtendedCost field second {1}", pProto.getId(), crItem.getExtendedCost());

                return false;
            }

            for (byte i = 0; i < ItemConst.MaxItemExtCostItems; ++i) {
                if (iece.ItemID[i] != 0 && !hasItemCount(iece.ItemID[i], iece.ItemCount[i] * stacks)) {
                    sendEquipError(InventoryResult.VendorMissingTurnins);

                    return false;
                }
            }

            for (byte i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) {
                if (iece.CurrencyID[i] == 0) {
                    continue;
                }

                var entry = CliDB.CurrencyTypesStorage.get(iece.CurrencyID[i]);

                if (entry == null) {
                    sendBuyError(BuyResult.CantFindItem, creature, item);

                    return false;
                }

                if (iece.flags.hasFlag((byte) ((int) ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                    sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                    return false;
                } else if (!hasCurrency(iece.CurrencyID[i], iece.CurrencyCount[i] * stacks)) {
                    sendEquipError(InventoryResult.VendorMissingTurnins);

                    return false;
                }
            }

            // check for personal arena rating requirement
            if (getMaxPersonalArenaRatingRequirement(iece.ArenaBracket) < iece.RequiredArenaRating) {
                // probably not the proper equip err
                sendEquipError(InventoryResult.CantEquipRank);

                return false;
            }

            if (iece.MinFactionID != 0 && (int) getReputationRank(iece.MinFactionID).getValue() < iece.MinReputation) {
                sendBuyError(BuyResult.ReputationRequire, creature, item);

                return false;
            }

            if (iece.flags.hasFlag((byte) ItemExtendedCostFlags.RequireGuild.getValue()) && getGuildId() == 0) {
                sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                return false;
            }

            if (iece.RequiredAchievement != 0 && !hasAchieved(iece.RequiredAchievement)) {
                sendEquipError(InventoryResult.VendorMissingTurnins); // Find correct error

                return false;
            }
        }

        long price = 0;

        if (pProto.getBuyPrice() > 0) //Assume price cannot be negative (do not know why it is int32)
        {
            var buyPricePerItem = (float) pProto.getBuyPrice() / pProto.getBuyCount();
            var maxCount = (long) (PlayerConst.MaxMoneyAmount / buyPricePerItem);

            if (count > maxCount) {
                Log.outError(LogFilter.player, "Player {0} tried to buy {1} item id {2}, causing overflow", getName(), count, pProto.getId());
                count = (byte) maxCount;
            }

            price = (long) buyPricePerItem * count; //it should not exceed MAX_MONEY_AMOUNT

            // reputation discount
            price = (long) Math.floor(price * getReputationPriceDiscount(creature));
            price = pProto.getBuyPrice() > 0 ? Math.max(1, price) : price;

            var priceMod = getTotalAuraModifier(AuraType.ModVendorItemsPrices);

            if (priceMod != 0) {
                price -= (long) MathUtil.CalculatePct(price, priceMod);
            }

            if (!hasEnoughMoney(price)) {
                sendBuyError(BuyResult.NotEnoughtMoney, creature, item);

                return false;
            }
        }

        if ((bag == ItemConst.NullBag && slot == ItemConst.NullSlot) || isInventoryPos(bag, slot)) {
            if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, (int) price, pProto, creature, crItem, true)) {
                return false;
            }
        } else if (isEquipmentPos(bag, slot)) {
            if (count != 1) {
                sendEquipError(InventoryResult.NotEquippable);

                return false;
            }

            if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, (int) price, pProto, creature, crItem, false)) {
                return false;
            }
        } else {
            sendEquipError(InventoryResult.WrongSlot);

            return false;
        }

        if (crItem.getMaxcount() != 0) // bought
        {
            if (pProto.getQuality().getValue() > itemQuality.Epic.getValue() || (pProto.getQuality() == itemQuality.Epic && pProto.getBaseItemLevel() >= GuildConst.MinNewsItemLevel)) {
                var guild = getGuild();

                if (guild != null) {
                    guild.addGuildNews(GuildNews.ItemPurchased, getGUID(), 0, item);
                }
            }

            updateCriteria(CriteriaType.BuyItemsFromVendors, 1);

            return true;
        }

        return false;
    }


    public final int getMaxPersonalArenaRatingRequirement(int minarenaslot) {
        // returns the maximal personal arena rating that can be used to purchase items requiring this condition
        // so return max[in arenateams](personalrating[teamtype])
        int max_personal_rating = 0;

        for (var i = (byte) minarenaslot; i < SharedConst.MaxArenaSlot; ++i) {
            var p_rating = getArenaPersonalRating(i);

            if (max_personal_rating < p_rating) {
                max_personal_rating = p_rating;
            }
        }

        return max_personal_rating;
    }


    public final void sendItemRetrievalMail(int itemEntry, int count, ItemContext context) {
        MailSender sender = new MailSender(MailMessageType.CREATURE, 34337);
        MailDraft draft = new MailDraft("Recovered Item", "We recovered a lost item in the twisting nether and noted that it was yours.$B$BPlease find said object enclosed."); // This is the text used in Cataclysm, it probably wasn't changed.
        SQLTransaction trans = new SQLTransaction();

        var item = item.createItem(itemEntry, count, context, null);

        if (item) {
            item.saveToDB(trans);
            draft.addItem(item);
        }

        draft.sendMailTo(trans, new MailReceiver(this, getGUID().getCounter()), sender);
        DB.characters.CommitTransaction(trans);
    }


    public final void setBuybackPrice(int slot, int price) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().buybackPrice, (int) slot), price);
    }


    public final void setBuybackTimestamp(int slot, long timestamp) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().buybackTimestamp, (int) slot), timestamp);
    }


    public final Item getItemFromBuyBackSlot(int slot) {
        Log.outDebug(LogFilter.player, "STORAGE: GetItemFromBuyBackSlot slot = {0}", slot);

        if (slot >= InventorySlots.BuyBackStart && slot < InventorySlots.BuyBackEnd) {
            return _items[slot];
        }

        return null;
    }


    public final void removeItemFromBuyBackSlot(int slot, boolean del) {
        Log.outDebug(LogFilter.player, "STORAGE: RemoveItemFromBuyBackSlot slot = {0}", slot);

        if (slot >= InventorySlots.BuyBackStart && slot < InventorySlots.BuyBackEnd) {
            var pItem = _items[slot];

            if (pItem) {
                pItem.removeFromWorld();

                if (del) {
                    var itemTemplate = pItem.getTemplate();

                    if (itemTemplate != null) {
                        if (itemTemplate.hasFlag(ItemFlags.HasLoot)) {
                            global.getLootItemStorage().removeStoredLootForContainer(pItem.getGUID().getCounter());
                        }
                    }

                    pItem.setState(ItemUpdateState.removed, this);
                }
            }

            _items[slot] = null;

            var eslot = slot - InventorySlots.BuyBackStart;
            setInvSlot(slot, ObjectGuid.Empty);
            setBuybackPrice(eslot, 0);
            setBuybackTimestamp(eslot, 0);

            // if current backslot is filled set to now free slot
            if (_items[_currentBuybackSlot]) {
                currentBuybackSlot = slot;
            }
        }
    }


    public final boolean hasItemTotemCategory(int totemCategory) {
        for (var providedTotemCategory : getAuraEffectsByType(AuraType.ProvideTotemCategory)) {
            if (global.getDB2Mgr().IsTotemCategoryCompatibleWith((int) providedTotemCategory.getMiscValueB(), totemCategory)) {
                return true;
            }
        }

        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = EquipmentSlot.start; i < inventoryEnd; ++i) {
            var item = getUseableItemByPos(InventorySlots.Bag0, i);

            if (item && global.getDB2Mgr().IsTotemCategoryCompatibleWith(item.getTemplate().getTotemCategory(), totemCategory)) {
                return true;
            }
        }

        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; ++i) {
            var bag = getBagByPos(i);

            if (bag) {
                for (byte j = 0; j < bag.getBagSize(); ++j) {
                    var item = getUseableItemByPos(i, j);

                    if (item && global.getDB2Mgr().IsTotemCategoryCompatibleWith(item.getTemplate().getTotemCategory(), totemCategory)) {
                        return true;
                    }
                }
            }
        }

        for (var i = InventorySlots.ChildEquipmentStart; i < InventorySlots.ChildEquipmentEnd; ++i) {
            var item = getUseableItemByPos(InventorySlots.Bag0, i);

            if (item && global.getDB2Mgr().IsTotemCategoryCompatibleWith(item.getTemplate().getTotemCategory(), totemCategory)) {
                return true;
            }
        }

        return false;
    }

    public final void _ApplyItemMods(Item item, byte slot, boolean apply) {
        _ApplyItemMods(item, slot, apply, true);
    }

    public final void _ApplyItemMods(Item item, byte slot, boolean apply, boolean updateItemAuras) {
        if (slot >= InventorySlots.BagEnd || item == null) {
            return;
        }

        var proto = item.getTemplate();

        if (proto == null) {
            return;
        }

        // not apply/remove mods for broken item
        if (item.isBroken()) {
            return;
        }

        Log.outInfo(LogFilter.player, "applying mods for item {0} ", item.getGUID().toString());

        if (item.getSocketColor(0) != 0) //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
        {
            correctMetaGemEnchants(slot, apply);
        }

        _ApplyItemBonuses(item, slot, apply);
        applyItemEquipSpell(item, apply);

        if (updateItemAuras) {
            applyItemDependentAuras(item, apply);
            var attackType = getAttackBySlot(slot, item.getTemplate().getInventoryType());

            if (attackType != WeaponAttackType.max) {
                updateWeaponDependentAuras(attackType);
            }
        }

        applyArtifactPowers(item, apply);
        applyAzeritePowers(item, apply);
        applyEnchantment(item, apply);

        Log.outDebug(LogFilter.player, "_ApplyItemMods complete.");
    }


    public final void _ApplyItemBonuses(Item item, byte slot, boolean apply) {
        var proto = item.getTemplate();

        if (slot >= InventorySlots.BagEnd || proto == null) {
            return;
        }

        var itemLevel = item.getItemLevel(this);
        var combatRatingMultiplier = 1.0f;
        var ratingMult = CliDB.CombatRatingsMultByILvlGameTable.GetRow(itemLevel);

        if (ratingMult != null) {
            combatRatingMultiplier = CliDB.GetIlvlStatMultiplier(ratingMult, proto.getInventoryType());
        }

        for (byte i = 0; i < ItemConst.MaxStats; ++i) {
            var statType = item.getItemStatType(i);

            if (statType == -1) {
                continue;
            }

            var val = item.getItemStatValue(i, this);

            if (val == 0) {
                continue;
            }

            switch (ItemModType.forValue(statType)) {
                case Mana:
                    handleStatFlatModifier(UnitMods.mana, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case Health: // modify HP
                    handleStatFlatModifier(UnitMods.health, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case Agility: // modify agility
                    handleStatFlatModifier(UnitMods.StatAgility, UnitModifierFlatType.base, (float) val, apply);
                    updateStatBuffMod(stats.Agility);

                    break;
                case Strength: //modify strength
                    handleStatFlatModifier(UnitMods.StatStrength, UnitModifierFlatType.base, (float) val, apply);
                    updateStatBuffMod(stats.Strength);

                    break;
                case Intellect: //modify intellect
                    handleStatFlatModifier(UnitMods.StatIntellect, UnitModifierFlatType.base, (float) val, apply);
                    updateStatBuffMod(stats.Intellect);

                    break;
                //case ItemModType.Spirit:                           //modify spirit
                //HandleStatModifier(UnitMods.StatSpirit, UnitModifierType.BaseValue, (float)val, apply);
                //ApplyStatBuffMod(stats.Spirit, MathUtil.CalculatePct(val, GetModifierValue(UnitMods.StatSpirit, UnitModifierType.BasePCTExcludeCreate)), apply);
                //break;
                case Stamina: //modify stamina
                    var staminaMult = CliDB.StaminaMultByILvlGameTable.GetRow(itemLevel);

                    if (staminaMult != null) {
                        val = (int) (val * CliDB.GetIlvlStatMultiplier(staminaMult, proto.getInventoryType()));
                    }

                    handleStatFlatModifier(UnitMods.StatStamina, UnitModifierFlatType.base, (float) val, apply);
                    updateStatBuffMod(stats.Stamina);

                    break;
                case DefenseSkillRating:
                    applyRatingMod(CombatRating.DefenseSkill, (int) (val * combatRatingMultiplier), apply);

                    break;
                case DodgeRating:
                    applyRatingMod(CombatRating.Dodge, (int) (val * combatRatingMultiplier), apply);

                    break;
                case ParryRating:
                    applyRatingMod(CombatRating.Parry, (int) (val * combatRatingMultiplier), apply);

                    break;
                case BlockRating:
                    applyRatingMod(CombatRating.Block, (int) (val * combatRatingMultiplier), apply);

                    break;
                case HitMeleeRating:
                    applyRatingMod(CombatRating.HitMelee, (int) (val * combatRatingMultiplier), apply);

                    break;
                case HitRangedRating:
                    applyRatingMod(CombatRating.HitRanged, (int) (val * combatRatingMultiplier), apply);

                    break;
                case HitSpellRating:
                    applyRatingMod(CombatRating.HitSpell, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CritMeleeRating:
                    applyRatingMod(CombatRating.CritMelee, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CritRangedRating:
                    applyRatingMod(CombatRating.CritRanged, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CritSpellRating:
                    applyRatingMod(CombatRating.CritSpell, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CritTakenRangedRating:
                    applyRatingMod(CombatRating.CritRanged, (int) val, apply);

                    break;
                case HasteMeleeRating:
                    applyRatingMod(CombatRating.HasteMelee, (int) val, apply);

                    break;
                case HasteRangedRating:
                    applyRatingMod(CombatRating.HasteRanged, (int) val, apply);

                    break;
                case HasteSpellRating:
                    applyRatingMod(CombatRating.HasteSpell, (int) val, apply);

                    break;
                case HitRating:
                    applyRatingMod(CombatRating.HitMelee, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.HitRanged, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.HitSpell, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CritRating:
                    applyRatingMod(CombatRating.CritMelee, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.CritRanged, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.CritSpell, (int) (val * combatRatingMultiplier), apply);

                    break;
                case ResilienceRating:
                    applyRatingMod(CombatRating.ResiliencePlayerDamage, (int) (val * combatRatingMultiplier), apply);

                    break;
                case HasteRating:
                    applyRatingMod(CombatRating.HasteMelee, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.HasteRanged, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.HasteSpell, (int) (val * combatRatingMultiplier), apply);

                    break;
                case ExpertiseRating:
                    applyRatingMod(CombatRating.Expertise, (int) (val * combatRatingMultiplier), apply);

                    break;
                case AttackPower:
                    handleStatFlatModifier(UnitMods.attackPower, UnitModifierFlatType.Total, (float) val, apply);
                    handleStatFlatModifier(UnitMods.AttackPowerRanged, UnitModifierFlatType.Total, (float) val, apply);

                    break;
                case RangedAttackPower:
                    handleStatFlatModifier(UnitMods.AttackPowerRanged, UnitModifierFlatType.Total, (float) val, apply);

                    break;
                case Versatility:
                    applyRatingMod(CombatRating.VersatilityDamageDone, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.VersatilityDamageTaken, (int) (val * combatRatingMultiplier), apply);
                    applyRatingMod(CombatRating.VersatilityHealingDone, (int) (val * combatRatingMultiplier), apply);

                    break;
                case ManaRegeneration:
                    applyManaRegenBonus((int) val, apply);

                    break;
                case ArmorPenetrationRating:
                    applyRatingMod(CombatRating.ArmorPenetration, (int) val, apply);

                    break;
                case SpellPower:
                    applySpellPowerBonus((int) val, apply);

                    break;
                case HealthRegen:
                    applyHealthRegenBonus((int) val, apply);

                    break;
                case SpellPenetration:
                    applySpellPenetrationBonus((int) val, apply);

                    break;
                case MasteryRating:
                    applyRatingMod(CombatRating.mastery, (int) (val * combatRatingMultiplier), apply);

                    break;
                case ExtraArmor:
                    handleStatFlatModifier(UnitMods.armor, UnitModifierFlatType.Total, (float) val, apply);

                    break;
                case FireResistance:
                    handleStatFlatModifier(UnitMods.ResistanceFire, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case FrostResistance:
                    handleStatFlatModifier(UnitMods.ResistanceFrost, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case HolyResistance:
                    handleStatFlatModifier(UnitMods.ResistanceHoly, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case ShadowResistance:
                    handleStatFlatModifier(UnitMods.ResistanceShadow, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case NatureResistance:
                    handleStatFlatModifier(UnitMods.ResistanceNature, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case ArcaneResistance:
                    handleStatFlatModifier(UnitMods.ResistanceArcane, UnitModifierFlatType.base, (float) val, apply);

                    break;
                case PvpPower:
                    applyRatingMod(CombatRating.PvpPower, (int) val, apply);

                    break;
                case Corruption:
                    applyRatingMod(CombatRating.corruption, (int) val, apply);

                    break;
                case CorruptionResistance:
                    applyRatingMod(CombatRating.CorruptionResistance, (int) val, apply);

                    break;
                case CrSpeed:
                    applyRatingMod(CombatRating.speed, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CrLifesteal:
                    applyRatingMod(CombatRating.lifesteal, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CrAvoidance:
                    applyRatingMod(CombatRating.avoidance, (int) (val * combatRatingMultiplier), apply);

                    break;
                case CrSturdiness:
                    applyRatingMod(CombatRating.Studiness, (int) (val * combatRatingMultiplier), apply);

                    break;
                case AgiStrInt:
                    handleStatFlatModifier(UnitMods.StatAgility, UnitModifierFlatType.base, val, apply);
                    handleStatFlatModifier(UnitMods.StatStrength, UnitModifierFlatType.base, val, apply);
                    handleStatFlatModifier(UnitMods.StatIntellect, UnitModifierFlatType.base, val, apply);
                    updateStatBuffMod(stats.Agility);
                    updateStatBuffMod(stats.Strength);
                    updateStatBuffMod(stats.Intellect);

                    break;
                case AgiStr:
                    handleStatFlatModifier(UnitMods.StatAgility, UnitModifierFlatType.base, val, apply);
                    handleStatFlatModifier(UnitMods.StatStrength, UnitModifierFlatType.base, val, apply);
                    updateStatBuffMod(stats.Agility);
                    updateStatBuffMod(stats.Strength);

                    break;
                case AgiInt:
                    handleStatFlatModifier(UnitMods.StatAgility, UnitModifierFlatType.base, val, apply);
                    handleStatFlatModifier(UnitMods.StatIntellect, UnitModifierFlatType.base, val, apply);
                    updateStatBuffMod(stats.Agility);
                    updateStatBuffMod(stats.Intellect);

                    break;
                case StrInt:
                    handleStatFlatModifier(UnitMods.StatStrength, UnitModifierFlatType.base, val, apply);
                    handleStatFlatModifier(UnitMods.StatIntellect, UnitModifierFlatType.base, val, apply);
                    updateStatBuffMod(stats.Strength);
                    updateStatBuffMod(stats.Intellect);

                    break;
            }
        }

        var armor = proto.getArmor(itemLevel);

        if (armor != 0) {
            handleStatFlatModifier(UnitMods.armor, UnitModifierFlatType.Total, (float) armor, apply);

            if (proto.getClass() == itemClass.armor && proto.getSubClass() == ItemSubClassArmor.Shield.getValue()) {
                setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().shieldBlock), apply ? (int) (armor * 2.5f) : 0);
            }
        }

        var attType = getAttackBySlot(slot, proto.getInventoryType());

        if (attType != WeaponAttackType.max) {
            _ApplyWeaponDamage(slot, item, apply);
        }
    }

    public final void applyEquipSpell(SpellInfo spellInfo, Item item, boolean apply) {
        applyEquipSpell(spellInfo, item, apply, false);
    }

    public final void applyEquipSpell(SpellInfo spellInfo, Item item, boolean apply, boolean formChange) {
        if (apply) {
            // Cannot be used in this stance/form
            if (spellInfo.checkShapeshift(getShapeshiftForm()) != SpellCastResult.SpellCastOk) {
                return;
            }

            if (formChange) // check aura active state from other form
            {
                if (item != null) {
                    if (getAppliedAurasQuery().hasSpellId(spellInfo.getId()).hasCastItemGuid(item.getGUID()).getResults().Any()) {
                        return;
                    }
                } else if (getAppliedAurasQuery().hasSpellId(spellInfo.getId()).getResults().Any()) {
                    return;
                }
            }

            Log.outDebug(LogFilter.player, "WORLD: cast {0} Equip spellId - {1}", (item != null ? "item" : "itemset"), spellInfo.getId());

            castSpell(this, spellInfo.getId(), new CastSpellExtraArgs(item));
        } else {
            if (formChange) // check aura compatibility
            {
                // Cannot be used in this stance/form
                if (spellInfo.checkShapeshift(getShapeshiftForm()) == SpellCastResult.SpellCastOk) {
                    return; // and remove only not compatible at form change
                }
            }

            if (item != null) {
                removeAurasDueToItemSpell(spellInfo.getId(), item.getGUID()); // un-apply all spells, not only at-equipped
            } else {
                removeAura(spellInfo.getId()); // un-apply spell (item set case)
            }
        }
    }

    public final void applyItemLootedSpell(Item item, boolean apply) {
        if (item.getTemplate().hasFlag(ItemFlags.legacy)) {
            return;
        }

        var lootedEffect = item.getEffects().FirstOrDefault(effectData -> effectData.triggerType == ItemSpelltriggerType.OnLooted);

        if (lootedEffect != null) {
            if (apply) {
                castSpell(this, (int) lootedEffect.spellID, item);
            } else {
                removeAurasDueToItemSpell((int) lootedEffect.spellID, item.getGUID());
            }
        }
    }

    public final void _ApplyAllLevelScaleItemMods(boolean apply) {
        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] != null) {
                if (!canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                _ApplyItemMods(_items[i], i, apply);

                // Update item sets for heirlooms
                if (global.getDB2Mgr().GetHeirloomByItemId(_items[i].getEntry()) != null && _items[i].getTemplate().getItemSet() != 0) {
                    if (apply) {
                        item.addItemsSetItem(this, _items[i]);
                    } else {
                        item.removeItemsSetItem(this, _items[i]);
                    }
                }
            }
        }
    }

    public final Loot getLootByWorldObjectGUID(ObjectGuid lootWorldObjectGuid) {
        return aeLootView.FirstOrDefault(pair -> Objects.equals(pair.value.getOwnerGUID(), lootWorldObjectGuid)).value;
    }


    public final LootRoll getLootRoll(ObjectGuid lootObjectGuid, byte lootListId) {
        return tangible.ListHelper.find(lootRolls, roll -> roll.isLootItem(lootObjectGUID, lootListId));
    }

    public final void addLootRoll(LootRoll roll) {
        lootRolls.add(roll);
    }

    public final void removeLootRoll(LootRoll roll) {
        lootRolls.remove(roll);
    }

    //Inventory
    public final boolean isInventoryPos(short pos) {
        return isInventoryPos((byte) (pos >>> 8), (byte) (pos & 255));
    }


    public final void moveItemFromInventory(byte bag, byte slot, boolean update) {
        var it = getItemByPos(bag, slot);

        if (it != null) {
            removeItem(bag, slot, update);
            itemRemovedQuestCheck(it.getEntry(), it.getCount());
            it.setNotRefundable(this, false, null, false);
            item.removeItemFromUpdateQueueOf(it, this);
            getSession().getCollectionMgr().removeTemporaryAppearance(it);

            if (it.isInWorld()) {
                it.removeFromWorld();
                it.destroyForPlayer(this);
            }
        }
    }

    public final void moveItemToInventory(ArrayList<ItemPosCount> dest, Item pItem, boolean update) {
        moveItemToInventory(dest, pItem, update, false);
    }

    public final void moveItemToInventory(ArrayList<ItemPosCount> dest, Item pItem, boolean update, boolean in_characterInventoryDB) {
        var itemId = pItem.getEntry();
        var count = pItem.getCount();

        // store item
        var pLastItem = storeItem(dest, pItem, update);

        // only set if not merged to existed stack
        if (pLastItem == pItem) {
            // update owner for last item (this can be original item with wrong owner
            if (ObjectGuid.opNotEquals(pLastItem.getOwnerGUID(), getGUID())) {
                pLastItem.setOwnerGUID(getGUID());
            }

            // if this original item then it need create record in inventory
            // in case trade we already have item in other player inventory
            pLastItem.setState(in_characterInventoryDB ? ItemUpdateState.Changed : ItemUpdateState.New, this);

            if (pLastItem.isBOPTradeable()) {
                addTradeableItem(pLastItem);
            }
        }

        // update quest counters
        itemAddedQuestCheck(itemId, count);
        updateCriteria(CriteriaType.ObtainAnyItem, itemId, count);
    }

    public final InventoryResult canBankItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, Item pItem, boolean swap, boolean not_loading) {
        return canBankItem(bag, slot, dest, pItem, swap, not_loading, false);
    }

    public final InventoryResult canBankItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, Item pItem, boolean swap) {
        return canBankItem(bag, slot, dest, pItem, swap, true, false);
    }

    public final InventoryResult canBankItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, Item pItem, boolean swap, boolean not_loading, boolean reagentBankOnly) {
        if (pItem == null) {
            return swap ? InventoryResult.CantSwap : InventoryResult.ItemNotFound;
        }

        // different slots range if we're trying to store item in Reagent Bank
        if ((isReagentBankPos(bag, slot) || reagentBankOnly) && !isReagentBankUnlocked()) {
            return InventoryResult.ReagentBankLocked;
        }

        var slotStart = reagentBankOnly ? InventorySlots.ReagentStart : InventorySlots.BankItemStart;
        var slotEnd = reagentBankOnly ? InventorySlots.ReagentEnd : InventorySlots.BankItemEnd;

        var count = pItem.getCount();

        Log.outDebug(LogFilter.player, "STORAGE: CanBankItem bag = {0}, slot = {1}, item = {2}, count = {3}", bag, slot, pItem.getEntry(), count);
        var pProto = pItem.getTemplate();

        if (pProto == null) {
            return swap ? InventoryResult.CantSwap : InventoryResult.ItemNotFound;
        }

        // item used
        if (pItem.getLootGenerated()) {
            return InventoryResult.LootGone;
        }

        if (pItem.isBindedNotWith(this)) {
            return InventoryResult.NotOwner;
        }

        // Currency tokens are not supposed to be swapped out of their hidden bag
        if (pItem.isCurrencyToken()) {
            Log.outError(LogFilter.player, "Possible hacking attempt: Player {0} [guid: {1}] tried to move token [guid: {2}, entry: {3}] out of the currency bag!", getName(), getGUID().toString(), pItem.getGUID().toString(), pProto.getId());

            return InventoryResult.CantSwap;
        }

        // check count of items (skip for auto move for same player from bank)
        var res = canTakeMoreSimilarItems(pItem);

        if (res != InventoryResult.Ok) {
            return res;
        }

        // in specific slot
        if (bag != ItemConst.NullBag && slot != ItemConst.NullSlot) {
            if (slot >= InventorySlots.BagStart && slot < InventorySlots.BagEnd) {
                if (!pItem.isBag()) {
                    return InventoryResult.WrongSlot;
                }

                if (slot - InventorySlots.BagStart >= getBankBagSlotCount()) {
                    return InventoryResult.NoBankSlot;
                }

                res = canUseItem(pItem, not_loading);

                if (res != InventoryResult.Ok) {
                    return res;
                }
            }

            tangible.RefObject<Integer> tempRef_count = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InSpecificSlot(bag, slot, dest, pProto, tempRef_count, swap, pItem);
            count = tempRef_count.refArgValue;

            if (res != InventoryResult.Ok) {
                return res;
            }

            if (count == 0) {
                return InventoryResult.Ok;
            }
        }

        // not specific slot or have space for partly store only in specific slot

        // in specific bag
        if (bag != ItemConst.NullBag) {
            if (pItem.isNotEmptyBag()) {
                return InventoryResult.BagInBag;
            }

            // search stack in bag for merge to
            if (pProto.getMaxStackSize() != 1) {
                if (bag == InventorySlots.Bag0) {
                    tangible.RefObject<Integer> tempRef_count2 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InInventorySlots(slotStart, slotEnd, dest, pProto, tempRef_count2, true, pItem, bag, slot);
                    count = tempRef_count2.refArgValue;

                    if (res != InventoryResult.Ok) {
                        return res;
                    }

                    if (count == 0) {
                        return InventoryResult.Ok;
                    }
                } else {
                    tangible.RefObject<Integer> tempRef_count3 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InBag(bag, dest, pProto, tempRef_count3, true, false, pItem, ItemConst.NullBag, slot);
                    count = tempRef_count3.refArgValue;

                    if (res != InventoryResult.Ok) {
                        tangible.RefObject<Integer> tempRef_count4 = new tangible.RefObject<Integer>(count);
                        res = canStoreItem_InBag(bag, dest, pProto, tempRef_count4, true, true, pItem, ItemConst.NullBag, slot);
                        count = tempRef_count4.refArgValue;
                    }

                    if (res != InventoryResult.Ok) {
                        return res;
                    }

                    if (count == 0) {
                        return InventoryResult.Ok;
                    }
                }
            }

            // search free slot in bag
            if (bag == InventorySlots.Bag0) {
                tangible.RefObject<Integer> tempRef_count5 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InInventorySlots(slotStart, slotEnd, dest, pProto, tempRef_count5, false, pItem, bag, slot);
                count = tempRef_count5.refArgValue;

                if (res != InventoryResult.Ok) {
                    return res;
                }

                if (count == 0) {
                    return InventoryResult.Ok;
                }
            } else {
                tangible.RefObject<Integer> tempRef_count6 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InBag(bag, dest, pProto, tempRef_count6, false, false, pItem, ItemConst.NullBag, slot);
                count = tempRef_count6.refArgValue;

                if (res != InventoryResult.Ok) {
                    tangible.RefObject<Integer> tempRef_count7 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InBag(bag, dest, pProto, tempRef_count7, false, true, pItem, ItemConst.NullBag, slot);
                    count = tempRef_count7.refArgValue;
                }

                if (res != InventoryResult.Ok) {
                    return res;
                }

                if (count == 0) {
                    return InventoryResult.Ok;
                }
            }
        }

        // not specific bag or have space for partly store only in specific bag

        // search stack for merge to
        if (pProto.getMaxStackSize() != 1) {
            // in slots
            tangible.RefObject<Integer> tempRef_count8 = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InInventorySlots(slotStart, slotEnd, dest, pProto, tempRef_count8, true, pItem, bag, slot);
            count = tempRef_count8.refArgValue;

            if (res != InventoryResult.Ok) {
                return res;
            }

            if (count == 0) {
                return InventoryResult.Ok;
            }

            // don't try to store reagents anywhere else than in Reagent Bank if we're on it
            if (!reagentBankOnly) {
                // in special bags
                if (pProto.getBagFamily() != BagFamilyMask.NONE) {
                    for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; i++) {
                        tangible.RefObject<Integer> tempRef_count9 = new tangible.RefObject<Integer>(count);
                        res = canStoreItem_InBag(i, dest, pProto, tempRef_count9, true, false, pItem, bag, slot);
                        count = tempRef_count9.refArgValue;

                        if (res != InventoryResult.Ok) {
                            continue;
                        }

                        if (count == 0) {
                            return InventoryResult.Ok;
                        }
                    }
                }

                // in regular bags
                for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; i++) {
                    tangible.RefObject<Integer> tempRef_count10 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InBag(i, dest, pProto, tempRef_count10, true, true, pItem, bag, slot);
                    count = tempRef_count10.refArgValue;

                    if (res != InventoryResult.Ok) {
                        continue;
                    }

                    if (count == 0) {
                        return InventoryResult.Ok;
                    }
                }
            }
        }

        // search free place in special bag
        if (!reagentBankOnly && pProto.getBagFamily() != BagFamilyMask.NONE) {
            for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; i++) {
                tangible.RefObject<Integer> tempRef_count11 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InBag(i, dest, pProto, tempRef_count11, false, false, pItem, bag, slot);
                count = tempRef_count11.refArgValue;

                if (res != InventoryResult.Ok) {
                    continue;
                }

                if (count == 0) {
                    return InventoryResult.Ok;
                }
            }
        }

        // search free space
        tangible.RefObject<Integer> tempRef_count12 = new tangible.RefObject<Integer>(count);
        res = canStoreItem_InInventorySlots(slotStart, slotEnd, dest, pProto, tempRef_count12, false, pItem, bag, slot);
        count = tempRef_count12.refArgValue;

        if (res != InventoryResult.Ok) {
            return res;
        }

        if (count == 0) {
            return InventoryResult.Ok;
        }

        // search free space in regular bags (don't try to store reagents anywhere else than in Reagent Bank if we're on it)
        if (!reagentBankOnly) {
            for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; i++) {
                tangible.RefObject<Integer> tempRef_count13 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InBag(i, dest, pProto, tempRef_count13, false, true, pItem, bag, slot);
                count = tempRef_count13.refArgValue;

                if (res != InventoryResult.Ok) {
                    continue;
                }

                if (count == 0) {
                    return InventoryResult.Ok;
                }
            }
        }

        return reagentBankOnly ? InventoryResult.ReagentBankFull : InventoryResult.BankFull;
    }

    public final Item bankItem(ArrayList<ItemPosCount> dest, Item pItem, boolean update) {
        return storeItem(dest, pItem, update);
    }

    public final int getFreeInventorySlotCount() {
        return getFreeInventorySlotCount(ItemSearchLocation.Inventory);
    }

    public final int getFreeInventorySlotCount(ItemSearchLocation location) {
        int freeSlotCount = 0;

        if (location.hasFlag(ItemSearchLocation.Equipment)) {
            for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
                if (getItemByPos(InventorySlots.Bag0, i) == null) {
                    ++freeSlotCount;
                }
            }

            for (var i = ProfessionSlots.start; i < ProfessionSlots.End; ++i) {
                if (!getItemByPos(InventorySlots.Bag0, i)) {
                    ++freeSlotCount;
                }
            }
        }

        if (location.hasFlag(ItemSearchLocation.Inventory)) {
            var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

            for (var i = InventorySlots.ItemStart; i < inventoryEnd; ++i) {
                if (getItemByPos(InventorySlots.Bag0, i) == null) {
                    ++freeSlotCount;
                }
            }

            for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; ++i) {
                var bag = getBagByPos(i);

                if (bag != null) {
                    for (byte j = 0; j < bag.getBagSize(); ++j) {
                        if (bag.getItemByPos(j) == null) {
                            ++freeSlotCount;
                        }
                    }
                }
            }
        }

        if (location.hasFlag(ItemSearchLocation.Bank)) {
            for (var i = InventorySlots.BankItemStart; i < InventorySlots.BankItemEnd; ++i) {
                if (getItemByPos(InventorySlots.Bag0, i) == null) {
                    ++freeSlotCount;
                }
            }

            for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; ++i) {
                var bag = getBagByPos(i);

                if (bag != null) {
                    for (byte j = 0; j < bag.getBagSize(); ++j) {
                        if (bag.getItemByPos(j) == null) {
                            ++freeSlotCount;
                        }
                    }
                }
            }
        }

        if (location.hasFlag(ItemSearchLocation.ReagentBank)) {
            for (var i = InventorySlots.ReagentBagStart; i < InventorySlots.ReagentBagEnd; ++i) {
                var bag = getBagByPos(i);

                if (bag != null) {
                    for (byte j = 0; j < bag.getBagSize(); ++j) {
                        if (bag.getItemByPos(j) == null) {
                            ++freeSlotCount;
                        }
                    }
                }
            }

            for (var i = InventorySlots.ReagentStart; i < InventorySlots.ReagentEnd; ++i) {
                if (getItemByPos(InventorySlots.Bag0, i) == null) {
                    ++freeSlotCount;
                }
            }
        }

        return freeSlotCount;
    }


    public final int getFreeInventorySpace() {
        int freeSpace = 0;

        // Check backpack
        for (var slot = InventorySlots.ItemStart; slot < InventorySlots.ItemEnd; ++slot) {
            var item = getItemByPos(InventorySlots.Bag0, slot);

            if (item == null) {
                freeSpace += 1;
            }
        }

        // Check bags
        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            var bag = getBagByPos(i);

            if (bag != null) {
                freeSpace += bag.getFreeSlots();
            }
        }

        return freeSpace;
    }

    //Bags
    public final Bag getBagByPos(byte bag) {
        if ((bag >= InventorySlots.BagStart && bag < InventorySlots.BagEnd) || (bag >= InventorySlots.BankBagStart && bag < InventorySlots.BankBagEnd) || (bag >= InventorySlots.ReagentBagStart && bag < InventorySlots.ReagentBagEnd)) {
            var item = getItemByPos(InventorySlots.Bag0, bag);

            if (item != null) {
                return item.getAsBag();
            }
        }

        return null;
    }

    public final InventoryResult canEquipItem(byte slot, tangible.OutObject<SHORT> dest, Item pItem, boolean swap) {
        return canEquipItem(slot, dest, pItem, swap, true);
    }

    public final InventoryResult canEquipItem(byte slot, tangible.OutObject<SHORT> dest, Item pItem, boolean swap, boolean not_loading) {
        dest.outArgValue = 0;

        if (pItem != null) {
            Log.outDebug(LogFilter.player, "STORAGE: CanEquipItem slot = {0}, item = {1}, count = {2}", slot, pItem.getEntry(), pItem.getCount());
            var pProto = pItem.getTemplate();

            if (pProto != null) {
                // item used
                if (pItem.getLootGenerated()) {
                    return InventoryResult.LootGone;
                }

                if (pItem.isBindedNotWith(this)) {
                    return InventoryResult.NotOwner;
                }

                // check count of items (skip for auto move for same player from bank)
                var res = canTakeMoreSimilarItems(pItem);

                if (res != InventoryResult.Ok) {
                    return res;
                }

                // check this only in game
                if (not_loading) {
                    // May be here should be more stronger checks; STUNNED checked
                    // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
                    if (hasUnitState(UnitState.Stunned)) {
                        return InventoryResult.GenericStunned;
                    }

                    if (isCharmed()) {
                        return InventoryResult.CantDoThatRightNow; // @todo is this the correct error?
                    }

                    // do not allow equipping gear except weapons, offhands, projectiles, relics in
                    // - combat
                    // - in-progress arenas
                    if (!pProto.canChangeEquipStateInCombat()) {
                        if (isInCombat()) {
                            return InventoryResult.NotInCombat;
                        }

                        var bg = getBattleground();

                        if (bg) {
                            if (bg.isArena() && bg.getStatus() == BattlegroundStatus.inProgress) {
                                return InventoryResult.NotDuringArenaMatch;
                            }
                        }
                    }

                    if (isInCombat() && (pProto.getClass() == itemClass.Weapon || pProto.getInventoryType() == inventoryType.Relic) && weaponChangeTimer != 0) {
                        return InventoryResult.ItemCooldown;
                    }

                    var currentGenericSpell = getCurrentSpell(CurrentSpellTypes.generic);

                    if (currentGenericSpell != null) {
                        if (!currentGenericSpell.spellInfo.hasAttribute(SpellAttr6.AllowEquipWhileCasting)) {
                            return InventoryResult.ClientLockedOut;
                        }
                    }

                    var currentChanneledSpell = getCurrentSpell(CurrentSpellTypes.Channeled);

                    if (currentChanneledSpell != null) {
                        if (!currentChanneledSpell.spellInfo.hasAttribute(SpellAttr6.AllowEquipWhileCasting)) {
                            return InventoryResult.ClientLockedOut;
                        }
                    }
                }

                ContentTuningLevels requiredLevels = null;

                // check allowed level (extend range to upper values if MaxLevel more or equal max player level, this let GM set high level with 1...max range items)
                if (pItem.getQuality() == itemQuality.Heirloom) {
                    requiredLevels = global.getDB2Mgr().GetContentTuningData(pItem.getScalingContentTuningId(), 0, true);
                }

                if (requiredLevels != null && requiredLevels.getValue().maxLevel < SharedConst.DefaultMaxLevel && requiredLevels.getValue().maxLevel < getLevel() && global.getDB2Mgr().GetHeirloomByItemId(pProto.getId()) == null) {
                    return InventoryResult.NotEquippable;
                }

                var eslot = findEquipSlot(pItem, slot, swap);

                if (eslot == ItemConst.NullSlot) {
                    return InventoryResult.NotEquippable;
                }

                res = canUseItem(pItem, not_loading);

                if (res != InventoryResult.Ok) {
                    return res;
                }

                if (!swap && getItemByPos(InventorySlots.Bag0, eslot) != null) {
                    return InventoryResult.NoSlotAvailable;
                }

                // if we are swapping 2 equiped items, CanEquipUniqueItem check
                // should ignore the item we are trying to swap, and not the
                // destination item. CanEquipUniqueItem should ignore destination
                // item only when we are swapping weapon from bag
                var ignore = ItemConst.NullSlot;

                switch (eslot) {
                    case EquipmentSlot.MainHand:
                        ignore = EquipmentSlot.OffHand;

                        break;
                    case EquipmentSlot.OffHand:
                        ignore = EquipmentSlot.MainHand;

                        break;
                    case EquipmentSlot.Finger1:
                        ignore = EquipmentSlot.Finger2;

                        break;
                    case EquipmentSlot.Finger2:
                        ignore = EquipmentSlot.Finger1;

                        break;
                    case EquipmentSlot.Trinket1:
                        ignore = EquipmentSlot.Trinket2;

                        break;
                    case EquipmentSlot.Trinket2:
                        ignore = EquipmentSlot.Trinket1;

                        break;
                    case ProfessionSlots.Profession1Gear1:
                        ignore = ProfessionSlots.Profession1Gear2;

                        break;
                    case ProfessionSlots.Profession1Gear2:
                        ignore = ProfessionSlots.Profession1Gear1;

                        break;
                    case ProfessionSlots.Profession2Gear1:
                        ignore = ProfessionSlots.Profession2Gear2;

                        break;
                    case ProfessionSlots.Profession2Gear2:
                        ignore = ProfessionSlots.Profession2Gear1;

                        break;
                }

                if (ignore == ItemConst.NullSlot || pItem != getItemByPos(InventorySlots.Bag0, ignore)) {
                    ignore = eslot;
                }

                // if swap ignore item (equipped also)
                var res2 = canEquipUniqueItem(pItem, swap ? ignore : ItemConst.NullSlot);

                if (res2 != InventoryResult.Ok) {
                    return res2;
                }

                // check unique-equipped special item classes
                if (pProto.getClass() == itemClass.Quiver) {
                    for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; ++i) {
                        var pBag = getItemByPos(InventorySlots.Bag0, i);

                        if (pBag != null) {
                            if (pBag != pItem) {
                                var pBagProto = pBag.getTemplate();

                                if (pBagProto != null) {
                                    if (pBagProto.getClass() == pProto.getClass() && (!swap || pBag.getSlot() != eslot)) {
                                        return (pBagProto.getSubClass() == (int) ItemSubClassQuiver.AmmoPouch.getValue()) ? InventoryResult.OnlyOneAmmo : InventoryResult.OnlyOneQuiver;
                                    }
                                }
                            }
                        }
                    }
                }

                var type = pProto.getInventoryType();

                if (eslot == EquipmentSlot.OffHand) {
                    // Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
                    if (type == inventoryType.Weapon && pProto.getSubClass() == (int) ItemSubClassWeapon.Polearm.getValue()) {
                        return InventoryResult.TwoHandSkillNotFound;
                    } else if (type == inventoryType.Weapon) {
                        if (!canDualWield) {
                            return InventoryResult.TwoHandSkillNotFound;
                        }
                    } else if (type == inventoryType.WeaponOffhand) {
                        if (!canDualWield && !pProto.hasFlag(ItemFlags3.AlwaysAllowDualWield)) {
                            return InventoryResult.TwoHandSkillNotFound;
                        }
                    } else if (type == inventoryType.Weapon2Hand) {
                        if (!canDualWield || !canTitanGrip()) {
                            return InventoryResult.TwoHandSkillNotFound;
                        }
                    }

                    if (isTwoHandUsed()) {
                        return InventoryResult.Equipped2handed;
                    }
                }

                // equip two-hand weapon case (with possible unequip 2 items)
                if (type == inventoryType.Weapon2Hand) {
                    if (eslot == EquipmentSlot.OffHand) {
                        if (!canTitanGrip()) {
                            return InventoryResult.NotEquippable;
                        }
                    } else if (eslot != EquipmentSlot.MainHand) {
                        return InventoryResult.NotEquippable;
                    }

                    if (!canTitanGrip()) {
                        // offhand item must can be stored in inventory for offhand item and it also must be unequipped
                        var offItem = getItemByPos(InventorySlots.Bag0, EquipmentSlot.OffHand);
                        ArrayList<ItemPosCount> off_dest = new ArrayList<>();

                        if (offItem != null && (!not_loading || canUnequipItem((short) (((int) InventorySlots.Bag0 << 8) | (int) EquipmentSlot.OffHand), false) != InventoryResult.Ok || canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, off_dest, offItem, false) != InventoryResult.Ok)) {
                            return swap ? InventoryResult.CantSwap : InventoryResult.InvFull;
                        }
                    }
                }

                dest.outArgValue = (short) (((int) InventorySlots.Bag0 << 8) | eslot);

                return InventoryResult.Ok;
            }
        }

        return !swap ? InventoryResult.ItemNotFound : InventoryResult.CantSwap;
    }

    public final InventoryResult canEquipChildItem(Item parentItem) {
        var childItem = getChildItemByGuid(parentItem.getChildItem());

        if (!childItem) {
            return InventoryResult.Ok;
        }

        var childEquipement = global.getDB2Mgr().GetItemChildEquipment(parentItem.getEntry());

        if (childEquipement == null) {
            return InventoryResult.Ok;
        }

        var dstItem = getItemByPos(InventorySlots.Bag0, childEquipement.ChildItemEquipSlot);

        if (!dstItem) {
            return InventoryResult.Ok;
        }

        var childDest = (short) ((InventorySlots.Bag0 << 8) | childEquipement.ChildItemEquipSlot);
        var msg = canUnequipItem(childDest, !childItem.isBag());

        if (msg != InventoryResult.Ok) {
            return msg;
        }

        // check dest.src move possibility
        var src = parentItem.getPos();
        ArrayList<ItemPosCount> dest = new ArrayList<>();

        if (isInventoryPos(src)) {
            msg = canStoreItem(parentItem.getBagSlot(), ItemConst.NullSlot, dest, dstItem, true);

            if (msg != InventoryResult.Ok) {
                msg = canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, dest, dstItem, true);
            }
        } else if (isBankPos(src)) {
            msg = canBankItem(parentItem.getBagSlot(), ItemConst.NullSlot, dest, dstItem, true);

            if (msg != InventoryResult.Ok) {
                msg = canBankItem(ItemConst.NullBag, ItemConst.NullSlot, dest, dstItem, true);
            }
        } else if (isEquipmentPos(src)) {
            return InventoryResult.CantSwap;
        }

        return msg;
    }

    public final InventoryResult canEquipUniqueItem(Item pItem, byte eslot) {
        return canEquipUniqueItem(pItem, eslot, 1);
    }

    public final InventoryResult canEquipUniqueItem(Item pItem) {
        return canEquipUniqueItem(pItem, ItemConst.NullSlot, 1);
    }

    public final InventoryResult canEquipUniqueItem(Item pItem, byte eslot, int limit_count) {
        var pProto = pItem.getTemplate();

        // proto based limitations
        var res = canEquipUniqueItem(pProto, eslot, limit_count);

        if (res != InventoryResult.Ok) {
            return res;
        }

        // check unique-equipped on gems
        for (var gemData : pItem.getItemData().gems) {
            var pGem = global.getObjectMgr().getItemTemplate(gemData.itemId);

            if (pGem == null) {
                continue;
            }

            // include for check equip another gems with same limit category for not equipped item (and then not counted)
            var gem_limit_count = (int) (!pItem.isEquipped() && pGem.getItemLimitCategory() != 0 ? pItem.getGemCountWithLimitCategory(pGem.getItemLimitCategory()) : 1);

            var ress = canEquipUniqueItem(pGem, eslot, gem_limit_count);

            if (ress != InventoryResult.Ok) {
                return ress;
            }
        }

        return InventoryResult.Ok;
    }

    public final InventoryResult canEquipUniqueItem(ItemTemplate itemProto, byte except_slot) {
        return canEquipUniqueItem(itemProto, except_slot, 1);
    }

    public final InventoryResult canEquipUniqueItem(ItemTemplate itemProto) {
        return canEquipUniqueItem(itemProto, ItemConst.NullSlot, 1);
    }

    public final InventoryResult canEquipUniqueItem(ItemTemplate itemProto, byte except_slot, int limit_count) {
        // check unique-equipped on item
        if (itemProto.hasFlag(ItemFlags.UniqueEquippable)) {
            // there is an equip limit on this item
            if (hasItemOrGemWithIdEquipped(itemProto.getId(), 1, except_slot)) {
                return InventoryResult.ItemUniqueEquippable;
            }
        }

        // check unique-equipped limit
        if (itemProto.getItemLimitCategory() != 0) {
            var limitEntry = CliDB.ItemLimitCategoryStorage.get(itemProto.getItemLimitCategory());

            if (limitEntry == null) {
                return InventoryResult.NotEquippable;
            }

            // NOTE: limitEntry.mode not checked because if item have have-limit then it applied and to equip case
            var limitQuantity = getItemLimitCategoryQuantity(limitEntry);

            if (limit_count > limitQuantity) {
                return InventoryResult.ItemMaxLimitCategoryEquippedExceededIs;
            }

            // there is an equip limit on this item
            if (hasItemWithLimitCategoryEquipped(itemProto.getItemLimitCategory(), limitQuantity - limit_count + 1, except_slot)) {
                return InventoryResult.ItemMaxLimitCategoryEquippedExceededIs;
            } else if (hasGemWithLimitCategoryEquipped(itemProto.getItemLimitCategory(), limitQuantity - limit_count + 1, except_slot)) {
                return InventoryResult.ItemMaxCountEquippedSocketed;
            }
        }

        return InventoryResult.Ok;
    }


    public final InventoryResult canUnequipItem(short pos, boolean swap) {
        // Applied only to equipped items and bank bags
        if (!isEquipmentPos(pos) && !isBagPos(pos)) {
            return InventoryResult.Ok;
        }

        var pItem = getItemByPos(pos);

        // Applied only to existed equipped item
        if (pItem == null) {
            return InventoryResult.Ok;
        }

        Log.outDebug(LogFilter.player, "STORAGE: CanUnequipItem slot = {0}, item = {1}, count = {2}", pos, pItem.getEntry(), pItem.getCount());

        var pProto = pItem.getTemplate();

        if (pProto == null) {
            return InventoryResult.ItemNotFound;
        }

        // item used
        if (pItem.getLootGenerated()) {
            return InventoryResult.LootGone;
        }

        if (isCharmed()) {
            return InventoryResult.CantDoThatRightNow; // @todo is this the correct error?
        }

        // do not allow unequipping gear except weapons, offhands, projectiles, relics in
        // - combat
        // - in-progress arenas
        if (!pProto.canChangeEquipStateInCombat()) {
            if (isInCombat()) {
                return InventoryResult.NotInCombat;
            }

            var bg = getBattleground();

            if (bg) {
                if (bg.isArena() && bg.getStatus() == BattlegroundStatus.inProgress) {
                    return InventoryResult.NotDuringArenaMatch;
                }
            }
        }

        if (!swap && pItem.isNotEmptyBag()) {
            return InventoryResult.DestroyNonemptyBag;
        }

        return InventoryResult.Ok;
    }

    public final void applyArtifactPowerRank(Item artifact, ArtifactPowerRankRecord artifactPowerRank, boolean apply) {
        var spellInfo = global.getSpellMgr().getSpellInfo(artifactPowerRank.spellID, Difficulty.NONE);

        if (spellInfo == null) {
            return;
        }

        if (spellInfo.isPassive()) {
            var powerAura = getAuraApplication(artifactPowerRank.spellID, ObjectGuid.Empty, artifact.getGUID());

            if (powerAura != null) {
                if (apply) {
                    for (var auraEffect : powerAura.getBase().getAuraEffects().entrySet()) {
                        if (powerAura.hasEffect(auraEffect.getValue().effIndex)) {
                            auraEffect.getValue().changeAmount((int) (artifactPowerRank.AuraPointsOverride != 0 ? artifactPowerRank.AuraPointsOverride : auraEffect.getValue().getSpellEffectInfo().calcValue()));
                        }
                    }
                } else {
                    removeAura(powerAura);
                }
            } else if (apply) {
                CastSpellExtraArgs args = new CastSpellExtraArgs(TriggerCastFlags.FullMask);
                args.setCastItem(artifact);

                if (artifactPowerRank.AuraPointsOverride != 0) {
                    for (var spellEffectInfo : spellInfo.getEffects()) {
                        args.addSpellMod(SpellValueMod.BasePoint0 + spellEffectInfo.effectIndex, (int) artifactPowerRank.AuraPointsOverride);
                    }
                }

                castSpell(this, artifactPowerRank.spellID, args);
            }
        } else {
            if (apply && !hasSpell(artifactPowerRank.spellID)) {
                addTemporarySpell(artifactPowerRank.spellID);
                LearnedSpells learnedSpells = new LearnedSpells();
                LearnedSpellInfo learnedSpellInfo = new LearnedSpellInfo();
                learnedSpellInfo.spellID = artifactPowerRank.spellID;
                learnedSpells.suppressMessaging = true;
                learnedSpells.clientLearnedSpellData.add(learnedSpellInfo);
                sendPacket(learnedSpells);
            } else if (!apply) {
                removeTemporarySpell(artifactPowerRank.spellID);
                UnlearnedSpells unlearnedSpells = new UnlearnedSpells();
                unlearnedSpells.suppressMessaging = true;
                unlearnedSpells.spellID.add(artifactPowerRank.spellID);
                sendPacket(unlearnedSpells);
            }
        }
    }

    public final void applyAzeriteItemMilestonePower(AzeriteItem item, AzeriteItemMilestonePowerRecord azeriteItemMilestonePower, boolean apply) {
        var type = AzeriteItemMilestoneType.forValue(azeriteItemMilestonePower.type);

        if (type == AzeriteItemMilestoneType.BonusStamina) {
            var azeritePower = CliDB.AzeritePowerStorage.get(azeriteItemMilestonePower.AzeritePowerID);

            if (azeritePower != null) {
                if (apply) {
                    castSpell(this, azeritePower.spellID, item);
                } else {
                    removeAurasDueToItemSpell(azeritePower.spellID, item.getGUID());
                }
            }
        }
    }


    public final void applyAzeriteEssence(AzeriteItem item, int azeriteEssenceId, int rank, boolean major, boolean apply) {
        for (int currentRank = 1; currentRank <= rank; ++currentRank) {
            var azeriteEssencePower = global.getDB2Mgr().GetAzeriteEssencePower(azeriteEssenceId, currentRank);

            if (azeriteEssencePower != null) {
                applyAzeriteEssencePower(item, azeriteEssencePower, major, apply);

                if (major && currentRank == 1) {
                    if (apply) {
                        CastSpellExtraArgs args = new CastSpellExtraArgs(TriggerCastFlags.FullMask);
                        args.addSpellMod(SpellValueMod.BasePoint0, (int) azeriteEssencePower.MajorPowerDescription);
                        castSpell(this, PlayerConst.SpellIdHeartEssenceActionBarOverride, args);
                    } else {
                        removeAura(PlayerConst.SpellIdHeartEssenceActionBarOverride);
                    }
                }
            }
        }
    }

    public final void applyAzeritePower(AzeriteEmpoweredItem item, AzeritePowerRecord azeritePower, boolean apply) {
        if (apply) {
            if (azeritePower.SpecSetID == 0 || global.getDB2Mgr().IsSpecSetMember(azeritePower.SpecSetID, getPrimarySpecialization())) {
                castSpell(this, azeritePower.spellID, item);
            }
        } else {
            removeAurasDueToItemSpell(azeritePower.spellID, item.getGUID());
        }
    }

    public final boolean hasItemOrGemWithIdEquipped(int item, int count) {
        return hasItemOrGemWithIdEquipped(item, count, ItemConst.NullSlot);
    }

    public final boolean hasItemOrGemWithIdEquipped(int item, int count, byte except_slot) {
        int tempcount = 0;

        var pProto = global.getObjectMgr().getItemTemplate(item);
        var includeGems = pProto == null ? null : pProto.getGemProperties() != 0;

        return !forEachItem(ItemSearchLocation.Equipment, pItem ->
        {
            if (pItem.slot != except_slot) {
                if (pItem.entry == item) {
                    tempcount += pItem.count;
                }

                if (includeGems) {
                    tempcount += pItem.getGemCountWithID(item);
                }

                if (tempcount >= count) {
                    return false;
                }
            }

            return true;
        });
    }

    //Visual
    public final void setVisibleItemSlot(int slot, Item pItem) {
        var itemField = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().visibleItems, (int) slot);

        if (pItem != null) {
            setUpdateFieldValue(itemField.modifyValue(itemField.itemID), pItem.getVisibleEntry(this));
            setUpdateFieldValue(itemField.modifyValue(itemField.secondaryItemModifiedAppearanceID), pItem.getVisibleSecondaryModifiedAppearanceId(this));
            setUpdateFieldValue(itemField.modifyValue(itemField.itemAppearanceModID), pItem.getVisibleAppearanceModId(this));
            setUpdateFieldValue(itemField.modifyValue(itemField.itemVisual), pItem.getVisibleItemVisual(this));
        } else {
            setUpdateFieldValue(itemField.modifyValue(itemField.itemID), 0);
            setUpdateFieldValue(itemField.modifyValue(itemField.secondaryItemModifiedAppearanceID), 0);
            setUpdateFieldValue(itemField.modifyValue(itemField.itemAppearanceModID), (short) 0);
            setUpdateFieldValue(itemField.modifyValue(itemField.itemVisual), (short) 0);
        }
    }


    public final void destroyItem(byte bag, byte slot, boolean update) {
        var pItem = getItemByPos(bag, slot);

        if (pItem != null) {
            Log.outDebug(LogFilter.player, "STORAGE: DestroyItem bag = {0}, slot = {1}, item = {2}", bag, slot, pItem.getEntry());

            // Also remove all contained items if the item is a bag.
            // This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
            if (pItem.isNotEmptyBag()) {
                for (byte i = 0; i < ItemConst.MaxBagSize; ++i) {
                    destroyItem(slot, i, update);
                }
            }

            if (pItem.isWrapped()) {
                var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_GIFT);
                stmt.AddValue(0, pItem.getGUID().getCounter());
                DB.characters.execute(stmt);
            }

            removeEnchantmentDurations(pItem);
            removeItemDurations(pItem);

            pItem.setNotRefundable(this);
            pItem.clearSoulboundTradeable(this);
            removeTradeableItem(pItem);

            applyItemObtainSpells(pItem, false);
            applyItemLootedSpell(pItem, false);
            global.getScriptMgr().<IItemOnRemove>RunScriptRet(tmpscript -> tmpscript.onRemove(this, pItem), pItem.getScriptId());

            Bag pBag;
            var pProto = pItem.getTemplate();

            if (bag == InventorySlots.Bag0) {
                setInvSlot(slot, ObjectGuid.Empty);

                // equipment and equipped bags can have applied bonuses
                if (slot < InventorySlots.BagEnd) {
                    // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                    if (pProto != null && pProto.getItemSet() != 0) {
                        item.removeItemsSetItem(this, pItem);
                    }

                    _ApplyItemMods(pItem, slot, false);
                }

                if (slot < EquipmentSlot.End) {
                    // update expertise and armor penetration - passive auras may need it
                    switch (slot) {
                        case EquipmentSlot.MainHand:
                        case EquipmentSlot.OffHand:
                            recalculateRating(CombatRating.ArmorPenetration);

                            break;
                        default:
                            break;
                    }

                    if (slot == EquipmentSlot.MainHand) {
                        updateExpertise(WeaponAttackType.BaseAttack);
                    } else if (slot == EquipmentSlot.OffHand) {
                        updateExpertise(WeaponAttackType.OffAttack);
                    }

                    // equipment visual show
                    setVisibleItemSlot(slot, null);
                }

                _items[slot] = null;
            } else if ((pBag = getBagByPos(bag)) != null) {
                pBag.removeItem(slot, update);
            }

            // Delete rolled money / loot from db.
            // MUST be done before removeFromWorld() or getTemplate() fails
            if (pProto.hasFlag(ItemFlags.HasLoot)) {
                global.getLootItemStorage().removeStoredLootForContainer(pItem.getGUID().getCounter());
            }

            itemRemovedQuestCheck(pItem.getEntry(), pItem.getCount());

            if (isInWorld() && update) {
                pItem.removeFromWorld();
                pItem.destroyForPlayer(this);
            }

            //pItem.setOwnerGUID(ObjectGuid.Empty);
            pItem.setContainedIn(ObjectGuid.Empty);
            pItem.setSlot(ItemConst.NullSlot);
            pItem.setState(ItemUpdateState.removed, this);

            if (pProto.getInventoryType() != inventoryType.NonEquip) {
                updateAverageItemLevelTotal();
            }

            if (bag == InventorySlots.Bag0) {
                updateAverageItemLevelEquipped();
            }
        }
    }

    public final int destroyItemCount(int itemEntry, int count, boolean update) {
        return destroyItemCount(itemEntry, count, update, true);
    }

    public final int destroyItemCount(int itemEntry, int count, boolean update, boolean unequip_check) {
        Log.outDebug(LogFilter.player, "STORAGE: DestroyItemCount item = {0}, count = {1}", itemEntry, count);
        int remcount = 0;

        // in inventory
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = InventorySlots.ItemStart; i < inventoryEnd; ++i) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item != null) {
                if (item.getEntry() == itemEntry && !item.isInTrade()) {
                    if (item.getCount() + remcount <= count) {
                        // all items in inventory can unequipped
                        remcount += item.getCount();
                        destroyItem(InventorySlots.Bag0, i, update);

                        if (remcount >= count) {
                            return remcount;
                        }
                    } else {
                        item.setCount(item.getCount() - count + remcount);
                        itemRemovedQuestCheck(item.getEntry(), count - remcount);

                        if (isInWorld() && update) {
                            item.sendUpdateToPlayer(this);
                        }

                        item.setState(ItemUpdateState.changed, this);

                        return count;
                    }
                }
            }
        }

        // in inventory bags
        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            var bag = getBagByPos(i);

            if (bag != null) {
                for (byte j = 0; j < bag.getBagSize(); j++) {
                    var item = bag.getItemByPos(j);

                    if (item != null) {
                        if (item.getEntry() == itemEntry && !item.isInTrade()) {
                            // all items in bags can be unequipped
                            if (item.getCount() + remcount <= count) {
                                remcount += item.getCount();
                                destroyItem(i, j, update);

                                if (remcount >= count) {
                                    return remcount;
                                }
                            } else {
                                item.setCount(item.getCount() - count + remcount);
                                itemRemovedQuestCheck(item.getEntry(), count - remcount);

                                if (isInWorld() && update) {
                                    item.sendUpdateToPlayer(this);
                                }

                                item.setState(ItemUpdateState.changed, this);

                                return count;
                            }
                        }
                    }
                }
            }
        }

        // in equipment and bag list
        for (var i = EquipmentSlot.start; i < InventorySlots.BagEnd; i++) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item != null) {
                if (item.getEntry() == itemEntry && !item.isInTrade()) {
                    if (item.getCount() + remcount <= count) {
                        if (!unequip_check || canUnequipItem((short) (InventorySlots.Bag0 << 8 | i), false) == InventoryResult.Ok) {
                            remcount += item.getCount();
                            destroyItem(InventorySlots.Bag0, i, update);

                            if (remcount >= count) {
                                return remcount;
                            }
                        }
                    } else {
                        item.setCount(item.getCount() - count + remcount);
                        itemRemovedQuestCheck(item.getEntry(), count - remcount);

                        if (isInWorld() && update) {
                            item.sendUpdateToPlayer(this);
                        }

                        item.setState(ItemUpdateState.changed, this);

                        return count;
                    }
                }
            }
        }

        // in bank
        for (var i = InventorySlots.BankItemStart; i < InventorySlots.BankItemEnd; i++) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item != null) {
                if (item.getEntry() == itemEntry && !item.isInTrade()) {
                    if (item.getCount() + remcount <= count) {
                        remcount += item.getCount();
                        destroyItem(InventorySlots.Bag0, i, update);

                        if (remcount >= count) {
                            return remcount;
                        }
                    } else {
                        item.setCount(item.getCount() - count + remcount);
                        itemRemovedQuestCheck(item.getEntry(), count - remcount);

                        if (isInWorld() && update) {
                            item.sendUpdateToPlayer(this);
                        }

                        item.setState(ItemUpdateState.changed, this);

                        return count;
                    }
                }
            }
        }

        // in bank bags
        for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; i++) {
            var bag = getBagByPos(i);

            if (bag != null) {
                for (byte j = 0; j < bag.getBagSize(); j++) {
                    var item = bag.getItemByPos(j);

                    if (item != null) {
                        if (item.getEntry() == itemEntry && !item.isInTrade()) {
                            // all items in bags can be unequipped
                            if (item.getCount() + remcount <= count) {
                                remcount += item.getCount();
                                destroyItem(i, j, update);

                                if (remcount >= count) {
                                    return remcount;
                                }
                            } else {
                                item.setCount(item.getCount() - count + remcount);
                                itemRemovedQuestCheck(item.getEntry(), count - remcount);

                                if (isInWorld() && update) {
                                    item.sendUpdateToPlayer(this);
                                }

                                item.setState(ItemUpdateState.changed, this);

                                return count;
                            }
                        }
                    }
                }
            }
        }

        // in bank bag list
        for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; i++) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item) {
                if (item.getEntry() == itemEntry && !item.isInTrade()) {
                    if (item.getCount() + remcount <= count) {
                        if (!unequip_check || canUnequipItem((short) (InventorySlots.Bag0 << 8 | i), false) == InventoryResult.Ok) {
                            remcount += item.getCount();
                            destroyItem(InventorySlots.Bag0, i, update);

                            if (remcount >= count) {
                                return remcount;
                            }
                        }
                    } else {
                        item.setCount(item.getCount() - count + remcount);
                        itemRemovedQuestCheck(item.getEntry(), count - remcount);

                        if (isInWorld() && update) {
                            item.sendUpdateToPlayer(this);
                        }

                        item.setState(ItemUpdateState.changed, this);

                        return count;
                    }
                }
            }
        }

        for (var i = InventorySlots.ReagentStart; i < InventorySlots.ReagentEnd; ++i) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item) {
                if (item.getEntry() == itemEntry && !item.isInTrade()) {
                    if (item.getCount() + remcount <= count) {
                        // all keys can be unequipped
                        remcount += item.getCount();
                        destroyItem(InventorySlots.Bag0, i, update);

                        if (remcount >= count) {
                            return remcount;
                        }
                    } else {
                        item.setCount(item.getCount() - count + remcount);
                        itemRemovedQuestCheck(item.getEntry(), count - remcount);

                        if (isInWorld() && update) {
                            item.sendUpdateToPlayer(this);
                        }

                        item.setState(ItemUpdateState.changed, this);

                        return count;
                    }
                }
            }
        }

        for (var i = InventorySlots.ChildEquipmentStart; i < InventorySlots.ChildEquipmentEnd; ++i) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item) {
                if (item.getEntry() == itemEntry && !item.isInTrade()) {
                    if (item.getCount() + remcount <= count) {
                        // all keys can be unequipped
                        remcount += item.getCount();
                        destroyItem(InventorySlots.Bag0, i, update);

                        if (remcount >= count) {
                            return remcount;
                        }
                    } else {
                        item.setCount(item.getCount() - count + remcount);
                        itemRemovedQuestCheck(item.getEntry(), count - remcount);

                        if (isInWorld() && update) {
                            item.sendUpdateToPlayer(this);
                        }

                        item.setState(ItemUpdateState.changed, this);

                        return count;
                    }
                }
            }
        }

        return remcount;
    }


    public final void destroyItemCount(Item pItem, tangible.RefObject<Integer> count, boolean update) {
        if (pItem == null) {
            return;
        }

        Log.outDebug(LogFilter.player, "STORAGE: DestroyItemCount item (GUID: {0}, Entry: {1}) count = {2}", pItem.getGUID().toString(), pItem.getEntry(), count.refArgValue);

        if (pItem.getCount() <= count.refArgValue) {
            count.refArgValue -= pItem.getCount();

            destroyItem(pItem.getBagSlot(), pItem.getSlot(), update);
        } else {
            itemRemovedQuestCheck(pItem.getEntry(), count.refArgValue);
            pItem.setCount(pItem.getCount() - count.refArgValue);
            count.refArgValue = 0;

            if (isInWorld() && update) {
                pItem.sendUpdateToPlayer(this);
            }

            pItem.setState(ItemUpdateState.changed, this);
        }
    }

    public final void autoStoreLoot(int loot_id, LootStore store, ItemContext context, boolean broadcast) {
        autoStoreLoot(loot_id, store, context, broadcast, false);
    }

    public final void autoStoreLoot(int loot_id, LootStore store, ItemContext context) {
        autoStoreLoot(loot_id, store, context, false, false);
    }

    public final void autoStoreLoot(int loot_id, LootStore store) {
        autoStoreLoot(loot_id, store, 0, false, false);
    }

    public final void autoStoreLoot(int loot_id, LootStore store, ItemContext context, boolean broadcast, boolean createdByPlayer) {
        autoStoreLoot(ItemConst.NullBag, ItemConst.NullSlot, loot_id, store, context, broadcast);
    }


    public final byte getInventorySlotCount() {
        return getActivePlayerData().numBackpackSlots;
    }


    public final void setInventorySlotCount(byte slots) {
        //ASSERT(slots <= (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));

        if (slots < getInventorySlotCount()) {
            ArrayList<item> unstorableItems = new ArrayList<>();

            for (var slot = (byte) (InventorySlots.ItemStart + slots); slot < InventorySlots.ItemEnd; ++slot) {
                var unstorableItem = getItemByPos(InventorySlots.Bag0, slot);

                if (unstorableItem) {
                    unstorableItems.add(unstorableItem);
                }
            }

            if (!unstorableItems.isEmpty()) {
                var fullBatches = unstorableItems.size() / SharedConst.MaxMailItems;
                var remainder = unstorableItems.size() % SharedConst.MaxMailItems;
                SQLTransaction trans = new SQLTransaction();

                var sendItemsBatch = (int arg1, int arg2) ->
                {
                    MailDraft draft = new MailDraft(global.getObjectMgr().getCypherString(CypherStrings.NotEquippedItem), "There were problems with equipping item(s).");

                    for (var j = 0; j < batchSize; ++j) {
                        draft.addItem(unstorableItems.get(batchNumber * SharedConst.MaxMailItems + j));
                    }

                    draft.sendMailTo(trans, this, new MailSender(this, MailStationery.gm), MailCheckMask.Copied);
                };

                for (var batch = 0; batch < fullBatches; ++batch) {
                    sendItemsBatch.invoke(batch, SharedConst.MaxMailItems);
                }

                if (remainder != 0) {
                    sendItemsBatch.invoke(fullBatches, remainder);
                }

                DB.characters.CommitTransaction(trans);

                sendPacket(new InventoryFullOverflow());
            }
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().numBackpackSlots), slots);
    }


    public final byte getBankBagSlotCount() {
        return getActivePlayerData().numBankSlots;
    }


    public final void setBankBagSlotCount(byte count) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().numBankSlots), count);
    }

    //Loot
    public final ObjectGuid getLootGUID() {
        return getPlayerData().lootTargetGUID;
    }

    public final void setLootGUID(ObjectGuid guid) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().lootTargetGUID), guid);
    }

    public final void storeLootItem(ObjectGuid lootWorldObjectGuid, byte lootSlot, Loot loot) {
        storeLootItem(lootWorldObjectGuid, lootSlot, loot, null);
    }

    public final void storeLootItem(ObjectGuid lootWorldObjectGuid, byte lootSlot, Loot loot, AELootResult aeResult) {
        NotNormalLootItem ffaItem;
        tangible.OutObject<NotNormalLootItem> tempOut_ffaItem = new tangible.OutObject<NotNormalLootItem>();
        var item = loot.lootItemInSlot(lootSlot, this, tempOut_ffaItem);
        ffaItem = tempOut_ffaItem.outArgValue;

        if (item == null || item.is_looted) {
            sendEquipError(InventoryResult.LootGone);

            return;
        }

        if (!item.hasAllowedLooter(getGUID())) {
            sendLootReleaseAll();

            return;
        }

        if (item.is_blocked) {
            sendLootReleaseAll();

            return;
        }

        // dont allow protected item to be looted by someone else
        if (!item.rollWinnerGUID.isEmpty() && ObjectGuid.opNotEquals(item.rollWinnerGUID, getGUID())) {
            sendLootReleaseAll();

            return;
        }

        ArrayList<ItemPosCount> dest = new ArrayList<>();
        var msg = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, item.itemid, item.count);

        if (msg == InventoryResult.Ok) {
            var newitem = storeNewItem(dest, item.itemid, true, item.randomBonusListId, item.getAllowedLooters(), item.context, item.bonusListIDs);

            if (ffaItem != null) {
                //freeforall case, notify only one player of the removal
                ffaItem.is_looted = true;
                sendNotifyLootItemRemoved(loot.getGUID(), loot.getOwnerGUID(), lootSlot);
            } else //not freeforall, notify everyone
            {
                loot.notifyItemRemoved(lootSlot, getMap());
            }

            //if only one person is supposed to loot the item, then set it to looted
            if (!item.freeforall) {
                item.is_looted = true;
            }

            --loot.unlootedCount;

            if (global.getObjectMgr().getItemTemplate(item.itemid) != null) {
                if (newitem.getQuality().getValue() > itemQuality.Epic.getValue() || (newitem.getQuality() == itemQuality.Epic && newitem.getItemLevel(this) >= GuildConst.MinNewsItemLevel)) {
                    var guild = getGuild();

                    if (guild) {
                        guild.addGuildNews(GuildNews.ItemLooted, getGUID(), 0, item.itemid);
                    }
                }
            }

            // if aeLooting then we must delay sending out item so that it appears properly stacked in chat
            if (aeResult == null) {
                sendNewItem(newitem, item.count, false, false, true, loot.getDungeonEncounterId());
                updateCriteria(CriteriaType.LootItem, item.itemid, item.count);
                updateCriteria(CriteriaType.GetLootByType, item.itemid, item.count, (int) SharedConst.GetLootTypeForClient(loot.loot_type).getValue());
                updateCriteria(CriteriaType.LootAnyItem, item.itemid, item.count);
            } else {
                aeResult.add(newitem, item.count, SharedConst.GetLootTypeForClient(loot.loot_type), loot.getDungeonEncounterId());
            }

            // LootItem is being removed (looted) from the container, delete it from the DB.
            if (loot.loot_type == LootType.item) {
                global.getLootItemStorage().removeStoredLootItemForContainer(lootWorldObjectGuid.getCounter(), item.itemid, item.count, item.lootListId);
            }

            applyItemLootedSpell(newitem, true);
        } else {
            sendEquipError(msg, null, null, item.itemid);
        }
    }

    public final HashMap<ObjectGuid, loot> getAELootView() {
        return aeLootView;
    }

    /**
     * if in a Battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
     * Called by remove insignia spell effect
     *
     * @param looterPlr
     */
    public final void removedInsignia(Player looterPlr) {
        // If player is not in battleground and not in worldpvpzone
        if (getBattlegroundId() == 0 && !isInWorldPvpZone()) {
            return;
        }

        // If not released spirit, do it !
        if (deathTimer > 0) {
            deathTimer = 0;
            buildPlayerRepop();
            repopAtGraveyard();
        }

        corpseLocation = new worldLocation();

        // We have to convert player corpse to bones, not to be able to resurrect there
        // SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
        var bones = getMap().convertCorpseToBones(getGUID(), true);

        if (!bones) {
            return;
        }

        // Now we must make bones lootable, and send player loot
        bones.setCorpseDynamicFlag(CorpseDynFlags.Lootable);

        bones.setLoot(new loot(getMap(), bones.getGUID(), LootType.Insignia, looterPlr.getGroup()));

        // For AV Achievement
        var bg = getBattleground();

        if (bg != null) {
            if (bg.getTypeID(true) == BattlegroundTypeId.AV) {
                bones.getLoot().fillLoot(1, LootStorage.CREATURE, this, true);
            }
        }
        // For wintergrasp Quests
        else if (getZone() == (int) areaId.wintergrasp.getValue()) {
            bones.getLoot().fillLoot(1, LootStorage.CREATURE, this, true);
        }

        // It may need a better formula
        // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
        bones.getLoot().gold = (int) (RandomUtil.URand(50, 150) * 0.016f * Math.pow((float) getLevel() / 5.76f, 2.5f) * WorldConfig.getFloatValue(WorldCfg.RateDropMoney));
        bones.setLootRecipient(looterPlr);
        looterPlr.sendLoot(bones.getLoot());
    }

    public final void sendLootRelease(ObjectGuid guid) {
        LootReleaseResponse packet = new LootReleaseResponse();
        packet.lootObj = guid;
        packet.owner = getGUID();
        sendPacket(packet);
    }

    public final void sendLootReleaseAll() {
        sendPacket(new LootReleaseAll());
    }

    public final void sendLoot(Loot loot) {
        sendLoot(loot, false);
    }

    public final void sendLoot(Loot loot, boolean aeLooting) {
        if (!getLootGUID().isEmpty() && !aeLooting) {
            session.doLootReleaseAll();
        }

        Log.outDebug(LogFilter.loot, String.format("Player::SendLoot: Player: '%1$s' (%2$s), Loot: %3$s", getName(), getGUID(), loot.getOwnerGUID()));

        if (!loot.getOwnerGUID().isItem() && !aeLooting) {
            setLootGUID(loot.getOwnerGUID());
        }

        LootResponse packet = new LootResponse();
        packet.owner = loot.getOwnerGUID();
        packet.lootObj = loot.getGUID();
        packet.lootMethod = loot.getLootMethod();
        packet.acquireReason = (byte) SharedConst.GetLootTypeForClient(loot.loot_type).getValue();
        packet.acquired = true; // false == No loot (this too^^)
        packet.AELooting = aeLooting;
        loot.buildLootResponse(packet, this);
        sendPacket(packet);

        // add 'this' player as one of the players that are looting 'loot'
        loot.onLootOpened(getMap(), getGUID());
        aeLootView.put(loot.getGUID(), loot);

        if (loot.loot_type == LootType.Corpse && !loot.getOwnerGUID().isItem()) {
            setUnitFlag(UnitFlag.Looting);
        }
    }

    public final void sendLootError(ObjectGuid lootObj, ObjectGuid owner, LootError error) {
        LootResponse packet = new LootResponse();
        packet.lootObj = lootObj;
        packet.owner = owner;
        packet.acquired = false;
        packet.failureReason = error;
        sendPacket(packet);
    }

    public final void sendNotifyLootMoneyRemoved(ObjectGuid lootObj) {
        CoinRemoved packet = new CoinRemoved();
        packet.lootObj = lootObj;
        sendPacket(packet);
    }


    public final void sendNotifyLootItemRemoved(ObjectGuid lootObj, ObjectGuid owner, byte lootListId) {
        LootRemoved packet = new LootRemoved();
        packet.lootObj = lootObj;
        packet.owner = owner;
        packet.lootListID = lootListId;
        sendPacket(packet);
    }

    public final void setEquipmentSet(EquipmentSetInfo.EquipmentSetData newEqSet) {
        if (newEqSet.getGuid() != 0) {
            // something wrong...
            var equipmentSetInfo = equipmentSets.get(newEqSet.getGuid());

            if (equipmentSetInfo == null || equipmentSetInfo.data.guid != newEqSet.getGuid()) {
                Log.outError(LogFilter.player, "Player {0} tried to save equipment set {1} (index: {2}), but that equipment set not found!", getName(), newEqSet.getGuid(), newEqSet.getSetId());

                return;
            }
        }

        var setGuid = (newEqSet.getGuid() != 0) ? newEqSet.getGuid() : global.getObjectMgr().generateEquipmentSetGuid();

        if (!equipmentSets.containsKey(setGuid)) {
            equipmentSets.put(setGuid, new EquipmentSetInfo());
        }

        var eqSlot = equipmentSets.get(setGuid);
        eqSlot.setData(newEqSet);

        if (eqSlot.getData().getGuid() == 0) {
            eqSlot.getData().setGuid(setGuid);

            EquipmentSetID data = new EquipmentSetID();
            data.GUID = eqSlot.getData().getGuid();
            data.type = eqSlot.getData().getType().getValue();
            data.setID = eqSlot.getData().getSetId();
            sendPacket(data);
        }

        eqSlot.setState(eqSlot.getState() == EquipmentSetUpdateState.New ? EquipmentSetUpdateState.New : EquipmentSetUpdateState.changed);
    }


    public final void deleteEquipmentSet(long id) {
        for (var pair : equipmentSets.entrySet()) {
            if (pair.getValue().data.guid == id) {
                if (pair.getValue().state == EquipmentSetUpdateState.New) {
                    equipmentSets.remove(pair.getKey());
                } else {
                    pair.getValue().state = EquipmentSetUpdateState.Deleted;
                }

                break;
            }
        }
    }

    //Void Storage
    public final boolean isVoidStorageUnlocked() {
        return hasPlayerFlag(playerFlags.VoidUnlocked);
    }

    public final void unlockVoidStorage() {
        setPlayerFlag(playerFlags.VoidUnlocked);
    }

    public final void lockVoidStorage() {
        removePlayerFlag(playerFlags.VoidUnlocked);
    }


    public final byte getNextVoidStorageFreeSlot() {
        for (byte i = 0; i < SharedConst.VoidStorageMaxSlot; ++i) {
            if (_voidStorageItems[i] == null) // unused item
            {
                return i;
            }
        }

        return SharedConst.VoidStorageMaxSlot;
    }


    public final byte getNumOfVoidStorageFreeSlots() {
        byte count = 0;

        for (byte i = 0; i < SharedConst.VoidStorageMaxSlot; ++i) {
            if (_voidStorageItems[i] == null) {
                count++;
            }
        }

        return count;
    }


    public final byte addVoidStorageItem(VoidStorageItem item) {
        var slot = getNextVoidStorageFreeSlot();

        if (slot >= SharedConst.VoidStorageMaxSlot) {
            getSession().sendVoidStorageTransferResult(VoidTransferError.Full);

            return (byte) 255;
        }

        _voidStorageItems[slot] = item;

        return slot;
    }


    public final void deleteVoidStorageItem(byte slot) {
        if (slot >= SharedConst.VoidStorageMaxSlot) {
            getSession().sendVoidStorageTransferResult(VoidTransferError.InternalError1);

            return;
        }

        _voidStorageItems[slot] = null;
    }


    public final boolean swapVoidStorageItem(byte oldSlot, byte newSlot) {
        if (oldSlot >= SharedConst.VoidStorageMaxSlot || newSlot >= SharedConst.VoidStorageMaxSlot || oldSlot == newSlot) {
            return false;
        }

        voidStorageItems.Swap(newSlot, oldSlot);

        return true;
    }


    public final VoidStorageItem getVoidStorageItem(byte slot) {
        if (slot >= SharedConst.VoidStorageMaxSlot) {
            getSession().sendVoidStorageTransferResult(VoidTransferError.InternalError1);

            return null;
        }

        return _voidStorageItems[slot];
    }


    public final VoidStorageItem getVoidStorageItem(long id, tangible.OutObject<Byte> slot) {
        slot.outArgValue = 0;

        for (byte i = 0; i < SharedConst.VoidStorageMaxSlot; ++i) {
            if (_voidStorageItems[i] != null && _voidStorageItems[i].getItemId() == id) {
                slot.outArgValue = i;

                return _voidStorageItems[i];
            }
        }

        return null;
    }

    public final boolean forEachItem(ItemSearchLocation location, tangible.Func1Param<item, Boolean> callback) {
        if (location.hasFlag(ItemSearchLocation.Equipment)) {
            for (var i = EquipmentSlot.start; i < EquipmentSlot.End; i++) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    if (!callback.invoke(item)) {
                        return false;
                    }
                }
            }

            for (var i = ProfessionSlots.start; i < ProfessionSlots.End; ++i) {
                var pItem = getItemByPos(InventorySlots.Bag0, i);

                if (pItem != null) {
                    if (!callback.invoke(pItem)) {
                        return false;
                    }
                }
            }
        }

        if (location.hasFlag(ItemSearchLocation.Inventory)) {
            var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

            for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    if (!callback.invoke(item)) {
                        return false;
                    }
                }
            }

            for (var i = InventorySlots.ChildEquipmentStart; i < InventorySlots.ChildEquipmentEnd; ++i) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    if (!callback.invoke(item)) {
                        return false;
                    }
                }
            }

            for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
                var bag = getBagByPos(i);

                if (bag != null) {
                    for (byte j = 0; j < bag.getBagSize(); ++j) {
                        var pItem = bag.getItemByPos(j);

                        if (pItem != null) {
                            if (!callback.invoke(pItem)) {
                                return false;
                            }
                        }
                    }
                }
            }
        }

        if (location.hasFlag(ItemSearchLocation.Bank)) {
            for (var i = InventorySlots.BankItemStart; i < InventorySlots.BankItemEnd; ++i) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    if (!callback.invoke(item)) {
                        return false;
                    }
                }
            }

            for (var i = InventorySlots.BankBagStart; i < InventorySlots.BankBagEnd; ++i) {
                var bag = getBagByPos(i);

                if (bag != null) {
                    for (byte j = 0; j < bag.getBagSize(); ++j) {
                        var pItem = bag.getItemByPos(j);

                        if (pItem != null) {
                            if (!callback.invoke(pItem)) {
                                return false;
                            }
                        }
                    }
                }
            }
        }

        if (location.hasFlag(ItemSearchLocation.ReagentBank)) {
            for (var i = InventorySlots.ReagentBagStart; i < InventorySlots.ReagentBagEnd; ++i) {
                var bag = getBagByPos(i);

                if (bag != null) {
                    for (byte j = 0; j < bag.getBagSize(); ++j) {
                        var pItem = bag.getItemByPos(j);

                        if (pItem != null) {
                            if (!callback.invoke(pItem)) {
                                return false;
                            }
                        }
                    }
                }
            }

            for (var i = InventorySlots.ReagentStart; i < InventorySlots.ReagentEnd; ++i) {
                var item = getItemByPos(InventorySlots.Bag0, i);

                if (item != null) {
                    if (!callback.invoke(item)) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    public final void updateAverageItemLevelTotal() {
        var bestItemLevels = new var(InventoryType inventoryType, int itemLevel, ObjectGuid guid)[EquipmentSlot.End]
        float sum = 0;

        forEachItem(ItemSearchLocation.Everywhere, item ->
        {
            var itemTemplate = item.template;

            if (itemTemplate != null && itemTemplate.inventoryType < inventoryType.ProfessionTool.getValue()) {
                if (item.IsEquipped) {
                    var itemLevel = item.getItemLevel(this);
                    var inventoryType = itemTemplate.inventoryType;
                    var slotData = bestItemLevels[item.Slot];

                    if (itemLevel > slotData.item2) {
                        sum += itemLevel - slotData.item2;
                        slotData = (inventoryType, itemLevel, item.GUID)
                    }
                } else {
                    short dest;
                    tangible.OutObject<SHORT> tempOut_dest = new tangible.OutObject<SHORT>();
                    if (canEquipItem(ItemConst.NullSlot, tempOut_dest, item, true, false) == InventoryResult.Ok) {
                        dest = tempOut_dest.outArgValue;
                        var itemLevel = item.getItemLevel(this);
                        var inventoryType = itemTemplate.inventoryType;

                        forEachEquipmentSlot(inventoryType, canDualWield, canTitanGrip, (slot, checkDuplicateGuid) ->
                        {
                            if (checkDuplicateGuid) {
                                for (var slotData1 : bestItemLevels) {
                                    if (slotData1.guid == item.GUID) {
                                        return;
                                    }
                                }
                            }

                            var slotData = bestItemLevels[slot];

                            if (itemLevel > slotData.itemLevel) {
                                sum += itemLevel - slotData.itemLevel;
                                slotData = (inventoryType, itemLevel, item.GUID)
                            }
                        });
                    } else {
                        dest = tempOut_dest.outArgValue;
                    }
                }
            }

            return true;
        });

        // If main hand is a 2h weapon, count it twice
        var mainHand = bestItemLevels[EquipmentSlot.MainHand];

        if (!canTitanGrip && mainHand.inventoryType == inventoryType.Weapon2Hand) {
            sum += mainHand.itemLevel;
        }

        sum /= 16.0f;
        setAverageItemLevelTotal(sum);
    }

    public final void updateAverageItemLevelEquipped() {
        float totalItemLevel = 0;

        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; i++) {
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item != null) {
                var itemLevel = item.getItemLevel(this);
                totalItemLevel += itemLevel;

                if (!canTitanGrip && i == EquipmentSlot.MainHand && item.getTemplate().getInventoryType() == inventoryType.Weapon2Hand) // 2h weapon counts twice
                {
                    totalItemLevel += itemLevel;
                }
            }
        }

        totalItemLevel /= 16.0f;
        setAverageItemLevelEquipped(totalItemLevel);
    }

    //Refund
    private void addRefundReference(ObjectGuid it) {
        refundableItems.add(it);
    }

    //Trade
    private void addTradeableItem(Item item) {
        itemSoulboundTradeable.add(item.getGUID());
    }

    private void updateSoulboundTradeItems() {
        // also checks for garbage data
        for (var guid : itemSoulboundTradeable) {
            var item = getItemByGuid(guid);

            if (!item || ObjectGuid.opNotEquals(item.getOwnerGUID(), getGUID()) || item.checkSoulboundTradeExpire()) {
                itemSoulboundTradeable.remove(guid);
            }
        }
    }


    private InventoryResult canStoreItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, int entry, int count, Item pItem, boolean swap) {
        tangible.OutObject<Integer> tempOut__ = new tangible.OutObject<Integer>();
        var tempVar = canStoreItem(bag, slot, dest, entry, count, pItem, swap, tempOut__);
        _ = tempOut__.outArgValue;
        return tempVar;
    }


    private InventoryResult canStoreItem(byte bag, byte slot, ArrayList<ItemPosCount> dest, int entry, int count, Item pItem, boolean swap, tangible.OutObject<Integer> no_space_count) {
        no_space_count.outArgValue = 0;
        Log.outDebug(LogFilter.player, "STORAGE: CanStoreItem bag = {0}, slot = {1}, item = {2}, count = {3}", bag, slot, entry, count);

        var pProto = global.getObjectMgr().getItemTemplate(entry);

        if (pProto == null) {
            no_space_count.outArgValue = count;

            return swap ? InventoryResult.CantSwap : InventoryResult.ItemNotFound;
        }

        if (pItem != null) {
            // item used
            if (pItem.getLootGenerated()) {
                no_space_count.outArgValue = count;

                return InventoryResult.LootGone;
            }

            if (pItem.isBindedNotWith(this)) {
                no_space_count.outArgValue = count;

                return InventoryResult.NotOwner;
            }
        }

        // check count of items (skip for auto move for same player from bank)
        int no_similar_count = 0; // can't store this amount similar items
        tangible.RefObject<Integer> tempRef_no_similar_count = new tangible.RefObject<Integer>(no_similar_count);
        var res = canTakeMoreSimilarItems(entry, count, pItem, tempRef_no_similar_count);
        no_similar_count = tempRef_no_similar_count.refArgValue;

        if (res != InventoryResult.Ok) {
            if (count == no_similar_count) {
                no_space_count.outArgValue = no_similar_count;

                return res;
            }

            count -= no_similar_count;
        }

        // in specific slot
        if (bag != ItemConst.NullBag && slot != ItemConst.NullSlot) {
            tangible.RefObject<Integer> tempRef_count = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InSpecificSlot(bag, slot, dest, pProto, tempRef_count, swap, pItem);
            count = tempRef_count.refArgValue;

            if (res != InventoryResult.Ok) {
                no_space_count.outArgValue = count + no_similar_count;

                return res;
            }

            if (count == 0) {
                if (no_similar_count == 0) {
                    return InventoryResult.Ok;
                }

                no_space_count.outArgValue = count + no_similar_count;

                return InventoryResult.ItemMaxCount;
            }
        }

        // not specific slot or have space for partly store only in specific slot
        var inventoryEnd = (byte) (InventorySlots.ItemStart + getInventorySlotCount());

        // in specific bag
        if (bag != ItemConst.NullBag) {
            // search stack in bag for merge to
            if (pProto.getMaxStackSize() != 1) {
                if (bag == InventorySlots.Bag0) // inventory
                {
                    tangible.RefObject<Integer> tempRef_count2 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InInventorySlots(InventorySlots.ChildEquipmentStart, InventorySlots.ChildEquipmentEnd, dest, pProto, tempRef_count2, true, pItem, bag, slot);
                    count = tempRef_count2.refArgValue;

                    if (res != InventoryResult.Ok) {
                        no_space_count.outArgValue = count + no_similar_count;

                        return res;
                    }

                    if (count == 0) {
                        if (no_similar_count == 0) {
                            return InventoryResult.Ok;
                        }

                        no_space_count.outArgValue = count + no_similar_count;

                        return InventoryResult.ItemMaxCount;
                    }

                    tangible.RefObject<Integer> tempRef_count3 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InInventorySlots(InventorySlots.ItemStart, inventoryEnd, dest, pProto, tempRef_count3, true, pItem, bag, slot);
                    count = tempRef_count3.refArgValue;

                    if (res != InventoryResult.Ok) {
                        no_space_count.outArgValue = count + no_similar_count;

                        return res;
                    }

                    if (count == 0) {
                        if (no_similar_count == 0) {
                            return InventoryResult.Ok;
                        }


                        no_space_count.outArgValue = count + no_similar_count;

                        return InventoryResult.ItemMaxCount;
                    }
                } else // equipped bag
                {
                    // we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
                    tangible.RefObject<Integer> tempRef_count4 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InBag(bag, dest, pProto, tempRef_count4, true, false, pItem, ItemConst.NullBag, slot);
                    count = tempRef_count4.refArgValue;

                    if (res != InventoryResult.Ok) {
                        tangible.RefObject<Integer> tempRef_count5 = new tangible.RefObject<Integer>(count);
                        res = canStoreItem_InBag(bag, dest, pProto, tempRef_count5, true, true, pItem, ItemConst.NullBag, slot);
                        count = tempRef_count5.refArgValue;
                    }

                    if (res != InventoryResult.Ok) {
                        no_space_count.outArgValue = count + no_similar_count;

                        return res;
                    }

                    if (count == 0) {
                        if (no_similar_count == 0) {
                            return InventoryResult.Ok;
                        }

                        no_space_count.outArgValue = count + no_similar_count;

                        return InventoryResult.ItemMaxCount;
                    }
                }
            }

            // search free slot in bag for place to
            if (bag == InventorySlots.Bag0) // inventory
            {
                if (pItem && pItem.hasItemFlag(ItemFieldFlags.Child)) {
                    tangible.RefObject<Integer> tempRef_count6 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InInventorySlots(InventorySlots.ChildEquipmentStart, InventorySlots.ChildEquipmentEnd, dest, pProto, tempRef_count6, false, pItem, bag, slot);
                    count = tempRef_count6.refArgValue;

                    if (res != InventoryResult.Ok) {
                        no_space_count.outArgValue = count + no_similar_count;

                        return res;
                    }

                    if (count == 0) {
                        if (no_similar_count == 0) {
                            return InventoryResult.Ok;
                        }

                        no_space_count.outArgValue = count + no_similar_count;

                        return InventoryResult.ItemMaxCount;
                    }
                }

                tangible.RefObject<Integer> tempRef_count7 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InInventorySlots(InventorySlots.ItemStart, inventoryEnd, dest, pProto, tempRef_count7, false, pItem, bag, slot);
                count = tempRef_count7.refArgValue;

                if (res != InventoryResult.Ok) {
                    no_space_count.outArgValue = count + no_similar_count;

                    return res;
                }

                if (count == 0) {
                    if (no_similar_count == 0) {
                        return InventoryResult.Ok;
                    }

                    no_space_count.outArgValue = count + no_similar_count;

                    return InventoryResult.ItemMaxCount;
                }
            } else // equipped bag
            {
                tangible.RefObject<Integer> tempRef_count8 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InBag(bag, dest, pProto, tempRef_count8, false, false, pItem, ItemConst.NullBag, slot);
                count = tempRef_count8.refArgValue;

                if (res != InventoryResult.Ok) {
                    tangible.RefObject<Integer> tempRef_count9 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InBag(bag, dest, pProto, tempRef_count9, false, true, pItem, ItemConst.NullBag, slot);
                    count = tempRef_count9.refArgValue;
                }

                if (res != InventoryResult.Ok) {
                    no_space_count.outArgValue = count + no_similar_count;

                    return res;
                }

                if (count == 0) {
                    if (no_similar_count == 0) {
                        return InventoryResult.Ok;
                    }

                    no_space_count.outArgValue = count + no_similar_count;

                    return InventoryResult.ItemMaxCount;
                }
            }
        }

        // not specific bag or have space for partly store only in specific bag

        // search stack for merge to
        if (pProto.getMaxStackSize() != 1) {
            tangible.RefObject<Integer> tempRef_count10 = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InInventorySlots(InventorySlots.ChildEquipmentStart, InventorySlots.ChildEquipmentEnd, dest, pProto, tempRef_count10, true, pItem, bag, slot);
            count = tempRef_count10.refArgValue;

            if (res != InventoryResult.Ok) {
                no_space_count.outArgValue = count + no_similar_count;

                return res;
            }

            if (count == 0) {
                if (no_similar_count == 0) {
                    return InventoryResult.Ok;
                }

                no_space_count.outArgValue = count + no_similar_count;

                return InventoryResult.ItemMaxCount;
            }

            tangible.RefObject<Integer> tempRef_count11 = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InInventorySlots(InventorySlots.ItemStart, inventoryEnd, dest, pProto, tempRef_count11, true, pItem, bag, slot);
            count = tempRef_count11.refArgValue;

            if (res != InventoryResult.Ok) {
                no_space_count.outArgValue = count + no_similar_count;

                return res;
            }

            if (count == 0) {
                if (no_similar_count == 0) {
                    return InventoryResult.Ok;
                }

                no_space_count.outArgValue = count + no_similar_count;

                return InventoryResult.ItemMaxCount;
            }

            if (pProto.getBagFamily() != 0) {
                for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
                    tangible.RefObject<Integer> tempRef_count12 = new tangible.RefObject<Integer>(count);
                    res = canStoreItem_InBag(i, dest, pProto, tempRef_count12, true, false, pItem, bag, slot);
                    count = tempRef_count12.refArgValue;

                    if (res != InventoryResult.Ok) {
                        continue;
                    }

                    if (count == 0) {
                        if (no_similar_count == 0) {
                            return InventoryResult.Ok;
                        }

                        no_space_count.outArgValue = count + no_similar_count;

                        return InventoryResult.ItemMaxCount;
                    }
                }
            }

            for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
                tangible.RefObject<Integer> tempRef_count13 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InBag(i, dest, pProto, tempRef_count13, true, true, pItem, bag, slot);
                count = tempRef_count13.refArgValue;

                if (res != InventoryResult.Ok) {
                    continue;
                }

                if (count == 0) {
                    if (no_similar_count == 0) {
                        return InventoryResult.Ok;
                    }

                    no_space_count.outArgValue = count + no_similar_count;

                    return InventoryResult.ItemMaxCount;
                }
            }
        }

        // search free slot - special bag case
        if (pProto.getBagFamily() != 0) {
            for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
                tangible.RefObject<Integer> tempRef_count14 = new tangible.RefObject<Integer>(count);
                res = canStoreItem_InBag(i, dest, pProto, tempRef_count14, false, false, pItem, bag, slot);
                count = tempRef_count14.refArgValue;

                if (res != InventoryResult.Ok) {
                    continue;
                }

                if (count == 0) {
                    if (no_similar_count == 0) {
                        return InventoryResult.Ok;
                    }

                    no_space_count.outArgValue = count + no_similar_count;

                    return InventoryResult.ItemMaxCount;
                }
            }
        }

        if (pItem != null && pItem.isNotEmptyBag()) {
            return InventoryResult.BagInBag;
        }

        if (pItem && pItem.hasItemFlag(ItemFieldFlags.Child)) {
            tangible.RefObject<Integer> tempRef_count15 = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InInventorySlots(InventorySlots.ChildEquipmentStart, InventorySlots.ChildEquipmentEnd, dest, pProto, tempRef_count15, false, pItem, bag, slot);
            count = tempRef_count15.refArgValue;

            if (res != InventoryResult.Ok) {
                no_space_count.outArgValue = count + no_similar_count;

                return res;
            }

            if (count == 0) {
                if (no_similar_count == 0) {
                    return InventoryResult.Ok;
                }

                no_space_count.outArgValue = count + no_similar_count;

                return InventoryResult.ItemMaxCount;
            }
        }

        // search free slot
        var searchSlotStart = InventorySlots.ItemStart;

        // new bags can be directly equipped
        if (!pItem && pProto.getClass() == itemClass.Container && ItemSubClassContainer.forValue(pProto.getSubClass()) == ItemSubClassContainer.Container && (pProto.getBonding() == ItemBondingType.NONE || pProto.getBonding() == ItemBondingType.OnAcquire)) {
            searchSlotStart = InventorySlots.BagStart;
        }

        tangible.RefObject<Integer> tempRef_count16 = new tangible.RefObject<Integer>(count);
        res = canStoreItem_InInventorySlots(searchSlotStart, inventoryEnd, dest, pProto, tempRef_count16, false, pItem, bag, slot);
        count = tempRef_count16.refArgValue;

        if (res != InventoryResult.Ok) {
            no_space_count.outArgValue = count + no_similar_count;

            return res;
        }

        if (count == 0) {
            if (no_similar_count == 0) {
                return InventoryResult.Ok;
            }

            no_space_count.outArgValue = count + no_similar_count;

            return InventoryResult.ItemMaxCount;
        }

        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            tangible.RefObject<Integer> tempRef_count17 = new tangible.RefObject<Integer>(count);
            res = canStoreItem_InBag(i, dest, pProto, tempRef_count17, false, true, pItem, bag, slot);
            count = tempRef_count17.refArgValue;

            if (res != InventoryResult.Ok) {
                continue;
            }

            if (count == 0) {
                if (no_similar_count == 0) {
                    return InventoryResult.Ok;
                }

                no_space_count.outArgValue = count + no_similar_count;

                return InventoryResult.ItemMaxCount;
            }
        }

        no_space_count.outArgValue = count + no_similar_count;

        return InventoryResult.InvFull;
    }


    private Item _StoreItem(short pos, Item pItem, int count, boolean clone, boolean update) {
        if (pItem == null) {
            return null;
        }

        var bag = (byte) (pos >>> 8);
        var slot = (byte) (pos & 255);

        Log.outDebug(LogFilter.player, "STORAGE: StoreItem bag = {0}, slot = {1}, item = {2}, count = {3}, guid = {4}", bag, slot, pItem.getEntry(), count, pItem.getGUID().toString());

        var pItem2 = getItemByPos(bag, slot);

        if (pItem2 == null) {
            if (clone) {
                pItem = pItem.cloneItem(count, this);
            } else {
                pItem.setCount(count);
            }

            if (pItem == null) {
                return null;
            }

            if (pItem.getBonding() == ItemBondingType.OnAcquire || pItem.getBonding() == ItemBondingType.Quest || (pItem.getBonding() == ItemBondingType.OnEquip && isBagPos(pos))) {
                pItem.setBinding(true);
            }

            var pBag = bag == InventorySlots.Bag0 ? null : getBagByPos(bag);

            if (pBag == null) {
                _items[slot] = pItem;
                setInvSlot(slot, pItem.getGUID());
                pItem.setContainedIn(getGUID());
                pItem.setOwnerGUID(getGUID());

                pItem.setSlot(slot);
                pItem.setContainer(null);
            } else {
                pBag.storeItem(slot, pItem, update);
            }

            if (isInWorld() && update) {
                pItem.addToWorld();
                pItem.sendUpdateToPlayer(this);
            }

            pItem.setState(ItemUpdateState.changed, this);

            if (pBag != null) {
                pBag.setState(ItemUpdateState.changed, this);
            }

            addEnchantmentDurations(pItem);
            addItemDurations(pItem);

            if (bag == InventorySlots.Bag0 || (bag >= InventorySlots.BagStart && bag < InventorySlots.BagEnd)) {
                applyItemObtainSpells(pItem, true);
            }

            return pItem;
        } else {
            if (pItem2.getBonding() == ItemBondingType.OnAcquire || pItem2.getBonding() == ItemBondingType.Quest || (pItem2.getBonding() == ItemBondingType.OnEquip && isBagPos(pos))) {
                pItem2.setBinding(true);
            }

            pItem2.setCount(pItem2.getCount() + count);

            if (isInWorld() && update) {
                pItem2.sendUpdateToPlayer(this);
            }

            if (!clone) {
                // delete item (it not in any slot currently)
                if (isInWorld() && update) {
                    pItem.removeFromWorld();
                    pItem.destroyForPlayer(this);
                }

                removeEnchantmentDurations(pItem);
                removeItemDurations(pItem);

                pItem.setOwnerGUID(getGUID()); // prevent error at next SetState in case trade/mail/buy from vendor
                pItem.setNotRefundable(this);
                pItem.clearSoulboundTradeable(this);
                removeTradeableItem(pItem);
                pItem.setState(ItemUpdateState.removed, this);
            }

            addEnchantmentDurations(pItem2);

            pItem2.setState(ItemUpdateState.changed, this);

            if (bag == InventorySlots.Bag0 || (bag >= InventorySlots.BagStart && bag < InventorySlots.BagEnd)) {
                applyItemObtainSpells(pItem2, true);
            }

            return pItem2;
        }
    }


    private boolean storeNewItemInBestSlots(int itemId, int amount, ItemContext context) {
        Log.outDebug(LogFilter.player, "STORAGE: Creating initial item, itemId = {0}, count = {1}", itemId, amount);

        var bonusListIDs = global.getDB2Mgr().GetDefaultItemBonusTree(itemId, context);

        InventoryResult msg;

        // attempt equip by one
        while (amount > 0) {
            short eDest;
            tangible.OutObject<SHORT> tempOut_eDest = new tangible.OutObject<SHORT>();
            msg = canEquipNewItem(ItemConst.NullSlot, tempOut_eDest, itemId, false);
            eDest = tempOut_eDest.outArgValue;

            if (msg != InventoryResult.Ok) {
                break;
            }

            var item = equipNewItem(eDest, itemId, context, true);
            item.setBonuses(bonusListIDs);
            autoUnequipOffhandIfNeed();
            --amount;
        }

        if (amount == 0) {
            return true; // equipped
        }

        // attempt store
        ArrayList<ItemPosCount> sDest = new ArrayList<>();
        // store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
        msg = canStoreNewItem(InventorySlots.Bag0, ItemConst.NullSlot, sDest, itemId, amount);

        if (msg == InventoryResult.Ok) {
            storeNewItem(sDest, itemId, true, ItemEnchantmentManager.generateItemRandomBonusListId(itemId), null, context, bonusListIDs);

            return true; // stored
        }

        // item can't be added
        Log.outError(LogFilter.player, "STORAGE: Can't equip or store initial item {0} for race {1} class {2}, error msg = {3}", itemId, getRace(), getClass(), msg);

        return false;
    }

    //Move Item
    private InventoryResult canTakeMoreSimilarItems(Item pItem) {
        int notused = 0;

        tangible.RefObject<Integer> tempRef_notused = new tangible.RefObject<Integer>(notused);
        var tempVar = canTakeMoreSimilarItems(pItem.getEntry(), pItem.getCount(), pItem, tempRef_notused);
        notused = tempRef_notused.refArgValue;
        return tempVar;
    }


    private InventoryResult canTakeMoreSimilarItems(Item pItem, tangible.RefObject<Integer> offendingItemId) {
        int notused = 0;

        tangible.RefObject<Integer> tempRef_notused = new tangible.RefObject<Integer>(notused);
        var tempVar = canTakeMoreSimilarItems(pItem.getEntry(), pItem.getCount(), pItem, tempRef_notused, offendingItemId);
        notused = tempRef_notused.refArgValue;
        return tempVar;
    }


    private InventoryResult canTakeMoreSimilarItems(int entry, int count, Item pItem, tangible.RefObject<Integer> no_space_count) {
        int notused = 0;

        tangible.RefObject<Integer> tempRef_notused = new tangible.RefObject<Integer>(notused);
        var tempVar = canTakeMoreSimilarItems(entry, count, pItem, no_space_count, tempRef_notused);
        notused = tempRef_notused.refArgValue;
        return tempVar;
    }


    private InventoryResult canTakeMoreSimilarItems(int entry, int count, Item pItem, tangible.RefObject<Integer> no_space_count, tangible.RefObject<Integer> offendingItemId) {
        var pProto = global.getObjectMgr().getItemTemplate(entry);

        if (pProto == null) {
            no_space_count.refArgValue = count;

            return InventoryResult.ItemMaxCount;
        }

        if (pItem != null && pItem.getLootGenerated()) {
            return InventoryResult.LootGone;
        }

        // no maximum
        if ((pProto.getMaxCount() <= 0 && pProto.getItemLimitCategory() == 0) || pProto.getMaxCount() == 2147483647) {
            return InventoryResult.Ok;
        }

        if (pProto.getMaxCount() > 0) {
            var curcount = getItemCount(pProto.getId(), true, pItem);

            if (curcount + count > pProto.getMaxCount()) {
                no_space_count.refArgValue = count + curcount - pProto.getMaxCount();

                return InventoryResult.ItemMaxCount;
            }
        }

        // check unique-equipped limit
        if (pProto.getItemLimitCategory() != 0) {
            var limitEntry = CliDB.ItemLimitCategoryStorage.get(pProto.getItemLimitCategory());

            if (limitEntry == null) {
                no_space_count.refArgValue = count;

                return InventoryResult.NotEquippable;
            }

            if (limitEntry.flags == 0) {
                var limitQuantity = getItemLimitCategoryQuantity(limitEntry);
                var curcount = getItemCountWithLimitCategory(pProto.getItemLimitCategory(), pItem);

                if (curcount + count > limitQuantity) {
                    no_space_count.refArgValue = count + curcount - limitQuantity;
                    offendingItemId.refArgValue = pProto.getId();

                    return InventoryResult.ItemMaxLimitCategoryCountExceededIs;
                }
            }
        }

        return InventoryResult.Ok;
    }

    //Equip/Unequip Item
    private InventoryResult canUnequipItems(int item, int count) {
        var res = InventoryResult.Ok;

        int tempcount = 0;

        var result = forEachItem(ItemSearchLocation.Equipment, pItem ->
        {
            if (pItem.entry == item) {
                var ires = canUnequipItem(pItem.pos, false);

                if (ires == InventoryResult.Ok) {
                    tempcount += pItem.count;

                    if (tempcount >= count) {
                        return false;
                    }
                } else {
                    res = ires;
                }
            }

            return true;
        });

        if (!result) // we stopped early due to a sucess
        {
            return InventoryResult.Ok;
        }

        return res; // return latest error if any
    }


    private void quickEquipItem(short pos, Item pItem) {
        if (pItem != null) {
            addEnchantmentDurations(pItem);
            addItemDurations(pItem);

            var slot = (byte) (pos & 255);
            visualizeItem(slot, pItem);

            pItem.setItemFlag2(ItemFieldFlags2.Equipped);

            if (isInWorld()) {
                pItem.addToWorld();
                pItem.sendUpdateToPlayer(this);
            }

            if (slot == EquipmentSlot.MainHand || slot == EquipmentSlot.OffHand) {
                checkTitanGripPenalty();
            }

            updateCriteria(CriteriaType.EquipItem, pItem.getEntry());
            updateCriteria(CriteriaType.EquipItemInSlot, slot, pItem.getEntry());
        }
    }


    private boolean _StoreOrEquipNewItem(int vendorslot, int item, byte count, byte bag, byte slot, long price, ItemTemplate pProto, Creature pVendor, VendorItem crItem, boolean bStore) {
        var stacks = count / pProto.getBuyCount();
        ArrayList<ItemPosCount> vDest = new ArrayList<>();
        short uiDest = 0;
        tangible.OutObject<SHORT> tempOut_uiDest = new tangible.OutObject<SHORT>();
        var msg = bStore ? canStoreNewItem(bag, slot, vDest, item, count) : canEquipNewItem(slot, tempOut_uiDest, item, false);
        uiDest = tempOut_uiDest.outArgValue;

        if (msg != InventoryResult.Ok) {
            sendEquipError(msg, null, null, item);

            return false;
        }

        modifyMoney(-price);

        if (crItem.getExtendedCost() != 0) // case for new honor system
        {
            var iece = CliDB.ItemExtendedCostStorage.get(crItem.getExtendedCost());

            for (var i = 0; i < ItemConst.MaxItemExtCostItems; ++i) {
                if (iece.ItemID[i] != 0) {
                    destroyItemCount(iece.ItemID[i], iece.ItemCount[i] * stacks, true);
                }
            }

            for (var i = 0; i < ItemConst.MaxItemExtCostCurrencies; ++i) {
                if (iece.flags.hasFlag((byte) (ItemExtendedCostFlags.RequireSeasonEarned1.getValue() << i))) {
                    continue;
                }

                if (iece.CurrencyID[i] != 0) {
                    removeCurrency(iece.CurrencyID[i], (int) (iece.CurrencyCount[i] * stacks), CurrencyDestroyReason.vendor);
                }
            }
        }

        var it = bStore ? storeNewItem(vDest, item, true, ItemEnchantmentManager.generateItemRandomBonusListId(item), null, itemContext.vendor, crItem.getBonusListIDs(), false) : equipNewItem(uiDest, item, itemContext.vendor, true);

        if (it != null) {
            var new_count = pVendor.updateVendorItemCurrentCount(crItem, count);

            BuySucceeded packet = new BuySucceeded();
            packet.vendorGUID = pVendor.getGUID();
            packet.muid = vendorslot + 1;
            packet.newQuantity = crItem.getMaxcount() > 0 ? new_count : 0xFFFFFFFF;
            packet.quantityBought = count;
            sendPacket(packet);

            sendNewItem(it, count, true, false, false);

            if (!bStore) {
                autoUnequipOffhandIfNeed();
            }

            if (pProto.hasFlag(ItemFlags.ItemPurchaseRecord) && crItem.getExtendedCost() != 0 && pProto.getMaxStackSize() == 1) {
                it.setItemFlag(ItemFieldFlags.refundable);
                it.setRefundRecipient(getGUID());
                it.setPaidMoney((int) price);
                it.setPaidExtendedCost(crItem.getExtendedCost());
                it.saveRefundDataToDB();
                addRefundReference(it.getGUID());
            }

            getSession().getCollectionMgr().onItemAdded(it);
        }

        return true;
    }

    //Item Durations
    private void removeItemDurations(Item item) {
        itemDuration.remove(item);
    }

    private void addItemDurations(Item item) {
        if (item.getItemData().expiration != 0) {
            itemDuration.add(item);
            item.sendTimeUpdate(this);
        }
    }

    private void updateItemDuration(int time) {
        updateItemDuration(time, false);
    }

    private void updateItemDuration(int time, boolean realtimeonly) {
        if (itemDuration.isEmpty()) {
            return;
        }

        Log.outDebug(LogFilter.player, "Player:UpdateItemDuration({0}, {1})", time, realtimeonly);

        for (var item : itemDuration) {
            if (!realtimeonly || item.getTemplate().hasFlag(ItemFlags.RealDuration)) {
                item.updateDuration(this, time);
            }
        }
    }

    private void sendEnchantmentDurations() {
        for (var enchantDuration : enchantDurations) {
            getSession().sendItemEnchantTimeUpdate(getGUID(), enchantDuration.getItem().getGUID(), (int) enchantDuration.getSlot().getValue(), enchantDuration.getLeftduration() / 1000);
        }
    }

    private void sendItemDurations() {
        for (var item : itemDuration) {
            item.sendTimeUpdate(this);
        }
    }


    private int getItemCountWithLimitCategory(int limitCategory, Item skipItem) {
        int count = 0;

        forEachItem(ItemSearchLocation.Everywhere, item ->
        {
            if (item != skipItem) {
                var pProto = item.template;

                if (pProto != null) {
                    if (pProto.ItemLimitCategory == limitCategory) {
                        count += item.count;
                    }
                }
            }

            return true;
        });

        return count;
    }


    private void destroyZoneLimitedItem(boolean update, int new_zone) {
        Log.outDebug(LogFilter.player, "STORAGE: DestroyZoneLimitedItem in map {0} and area {1}", getLocation().getMapId(), new_zone);

        // in inventory
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = InventorySlots.ItemStart; i < inventoryEnd; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem) {
                if (pItem.isLimitedToAnotherMapOrZone(getLocation().getMapId(), new_zone)) {
                    destroyItem(InventorySlots.Bag0, i, update);
                }
            }
        }

        // in inventory bags
        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; i++) {
            var pBag = getBagByPos(i);

            if (pBag) {
                for (byte j = 0; j < pBag.getBagSize(); j++) {
                    var pItem = pBag.getItemByPos(j);

                    if (pItem) {
                        if (pItem.isLimitedToAnotherMapOrZone(getLocation().getMapId(), new_zone)) {
                            destroyItem(i, j, update);
                        }
                    }
                }
            }
        }

        // in equipment and bag list
        for (var i = EquipmentSlot.start; i < InventorySlots.BagEnd; i++) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem) {
                if (pItem.isLimitedToAnotherMapOrZone(getLocation().getMapId(), new_zone)) {
                    destroyItem(InventorySlots.Bag0, i, update);
                }
            }
        }
    }

    private void applyItemEquipSpell(Item item, boolean apply) {
        applyItemEquipSpell(item, apply, false);
    }

    private void applyItemEquipSpell(Item item, boolean apply, boolean formChange) {
        if (item == null || item.getTemplate().hasFlag(ItemFlags.legacy)) {
            return;
        }

        for (var effectData : item.getEffects()) {
            // wrong triggering type
            if (apply && effectData.triggerType != ItemSpelltriggerType.OnEquip) {
                continue;
            }

            // check if it is valid spell
            var spellproto = global.getSpellMgr().getSpellInfo((int) effectData.spellID, Difficulty.NONE);

            if (spellproto == null) {
                continue;
            }

            if (effectData.chrSpecializationID != 0 && effectData.chrSpecializationID != getPrimarySpecialization()) {
                continue;
            }

            applyEquipSpell(spellproto, item, apply, formChange);
        }
    }

    private void applyEquipCooldown(Item pItem) {
        if (pItem.getTemplate().hasFlag(ItemFlags.NoEquipCooldown)) {
            return;
        }

        var now = gameTime.Now();

        for (var effectData : pItem.getEffects()) {
            var effectSpellInfo = global.getSpellMgr().getSpellInfo((int) effectData.spellID, Difficulty.NONE);

            if (effectSpellInfo == null) {
                continue;
            }

            // apply proc cooldown to equip auras if we have any
            if (effectData.triggerType == ItemSpelltriggerType.OnEquip) {
                var procEntry = global.getSpellMgr().getSpellProcEntry(effectSpellInfo);

                if (procEntry == null) {
                    continue;
                }

                var itemAura = getAura((int) effectData.spellID, getGUID(), pItem.getGUID());

                if (itemAura != null) {
                    itemAura.addProcCooldown(procEntry, now);
                }

                continue;
            }

            // no spell
            if (effectData.spellID == 0) {
                continue;
            }

            // wrong triggering type
            if (effectData.triggerType != ItemSpelltriggerType.OnUse) {
                continue;
            }

            // Don't replace longer cooldowns by equip cooldown if we have any.
            if (getSpellHistory().getRemainingCooldown(effectSpellInfo) > duration.FromSeconds(30)) {
                continue;
            }

            getSpellHistory().addCooldown((int) effectData.spellID, pItem.getEntry(), duration.FromSeconds(30));

            ItemCooldown data = new ItemCooldown();
            data.itemGuid = pItem.getGUID();
            data.spellID = (int) effectData.spellID;
            data.cooldown = 30 * time.InMilliseconds; //Always 30secs?
            sendPacket(data);
        }
    }

    private void _RemoveAllItemMods() {
        Log.outDebug(LogFilter.player, "_RemoveAllItemMods start.");

        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] != null) {
                var proto = _items[i].getTemplate();

                if (proto == null) {
                    continue;
                }

                // item set bonuses not dependent from item broken state
                if (proto.getItemSet() != 0) {
                    item.removeItemsSetItem(this, _items[i]);
                }

                if (_items[i].isBroken() || !canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                applyItemEquipSpell(_items[i], false);
                applyEnchantment(_items[i], false);
                applyArtifactPowers(_items[i], false);
            }
        }

        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] != null) {
                if (_items[i].isBroken() || !canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                applyItemDependentAuras(_items[i], false);
                _ApplyItemBonuses(_items[i], i, false);
            }
        }

        Log.outDebug(LogFilter.player, "_RemoveAllItemMods complete.");
    }

    private void _ApplyAllItemMods() {
        Log.outDebug(LogFilter.player, "_ApplyAllItemMods start.");

        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] != null) {
                if (_items[i].isBroken() || !canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                applyItemDependentAuras(_items[i], true);
                _ApplyItemBonuses(_items[i], i, true);

                var attackType = getAttackBySlot(i, _items[i].getTemplate().getInventoryType());

                if (attackType != WeaponAttackType.max) {
                    updateWeaponDependentAuras(attackType);
                }
            }
        }

        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] != null) {
                var proto = _items[i].getTemplate();

                if (proto == null) {
                    continue;
                }

                // item set bonuses not dependent from item broken state
                if (proto.getItemSet() != 0) {
                    item.addItemsSetItem(this, _items[i]);
                }

                if (_items[i].isBroken() || !canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                applyItemEquipSpell(_items[i], true);
                applyArtifactPowers(_items[i], true);
                applyEnchantment(_items[i], true);
            }
        }

        Log.outDebug(LogFilter.player, "_ApplyAllItemMods complete.");
    }

    private void applyAllAzeriteItemMods(boolean apply) {
        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i]) {
                if (!_items[i].isAzeriteItem() || _items[i].isBroken() || !canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                applyAzeritePowers(_items[i], apply);
            }
        }
    }

    private void applyAllAzeriteEmpoweredItemMods(boolean apply) {
        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i]) {
                if (!_items[i].isAzeriteEmpoweredItem() || _items[i].isBroken() || !canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                    continue;
                }

                applyAzeritePowers(_items[i], apply);
            }
        }
    }


    private InventoryResult canStoreItem_InInventorySlots(byte slot_begin, byte slot_end, ArrayList<ItemPosCount> dest, ItemTemplate pProto, tangible.RefObject<Integer> count, boolean merge, Item pSrcItem, byte skip_bag, byte skip_slot) {
        //this is never called for non-bag slots so we can do this
        if (pSrcItem != null && pSrcItem.isNotEmptyBag()) {
            return InventoryResult.DestroyNonemptyBag;
        }

        for (var j = slot_begin; j < slot_end; j++) {
            // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
            if (InventorySlots.Bag0 == skip_bag && j == skip_slot) {
                continue;
            }

            var pItem2 = getItemByPos(InventorySlots.Bag0, j);

            // ignore move item (this slot will be empty at move)
            if (pItem2 == pSrcItem) {
                pItem2 = null;
            }

            // if merge skip empty, if !merge skip non-empty
            if ((pItem2 == null) == merge) {
                continue;
            }

            var need_space = pProto.getMaxStackSize();

            if (pItem2 != null) {
                // can be merged at least partly
                var res = pItem2.canBeMergedPartlyWith(pProto);

                if (res != InventoryResult.Ok) {
                    continue;
                }

                // descrease at current stacksize
                need_space -= pItem2.getCount();
            }

            if (need_space > count.refArgValue) {
                need_space = count.refArgValue;
            }

            ItemPosCount newPosition = new ItemPosCount((short) (InventorySlots.Bag0 << 8 | j), need_space);

            if (!newPosition.isContainedIn(dest)) {
                dest.add(newPosition);
                count.refArgValue -= need_space;

                if (count.refArgValue == 0) {
                    return InventoryResult.Ok;
                }
            }
        }

        return InventoryResult.Ok;
    }


    private InventoryResult canStoreItem_InSpecificSlot(byte bag, byte slot, ArrayList<ItemPosCount> dest, ItemTemplate pProto, tangible.RefObject<Integer> count, boolean swap, Item pSrcItem) {
        var pItem2 = getItemByPos(bag, slot);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem) {
            pItem2 = null;
        }

        int need_space;

        if (pSrcItem) {
            if (pSrcItem.isNotEmptyBag() && !isBagPos((short) ((short) bag << 8 | slot))) {
                return InventoryResult.DestroyNonemptyBag;
            }

            if (pSrcItem.hasItemFlag(ItemFieldFlags.Child) && !isEquipmentPos(bag, slot) && !isChildEquipmentPos(bag, slot)) {
                return InventoryResult.WrongBagType3;
            }

            if (!pSrcItem.hasItemFlag(ItemFieldFlags.Child) && isChildEquipmentPos(bag, slot)) {
                return InventoryResult.WrongBagType3;
            }
        }

        // empty specific slot - check item fit to slot
        if (pItem2 == null || swap) {
            if (bag == InventorySlots.Bag0) {
                // prevent cheating
                if ((slot >= InventorySlots.BuyBackStart && slot < InventorySlots.BuyBackEnd) || slot >= (byte) PlayerSlot.End.getValue()) {
                    return InventoryResult.WrongBagType;
                }

                // can't store anything else than crafting reagents in Reagent Bank
                if (isReagentBankPos(bag, slot) && (!isReagentBankUnlocked() || !pProto.isCraftingReagent())) {
                    return InventoryResult.WrongBagType;
                }
            } else {
                var pBag = getBagByPos(bag);

                if (pBag == null) {
                    return InventoryResult.WrongBagType;
                }

                var pBagProto = pBag.getTemplate();

                if (pBagProto == null) {
                    return InventoryResult.WrongBagType;
                }

                if (slot >= pBagProto.getContainerSlots()) {
                    return InventoryResult.WrongBagType;
                }

                if (!item.itemCanGoIntoBag(pProto, pBagProto)) {
                    return InventoryResult.WrongBagType;
                }
            }

            // non empty stack with space
            need_space = pProto.getMaxStackSize();
        }
        // non empty slot, check item type
        else {
            // can be merged at least partly
            var res = pItem2.canBeMergedPartlyWith(pProto);

            if (res != InventoryResult.Ok) {
                return res;
            }

            // free stack space or infinity
            need_space = pProto.getMaxStackSize() - pItem2.getCount();
        }

        if (need_space > count.refArgValue) {
            need_space = count.refArgValue;
        }

        ItemPosCount newPosition = new ItemPosCount((short) (bag << 8 | slot), need_space);

        if (!newPosition.isContainedIn(dest)) {
            dest.add(newPosition);
            count.refArgValue -= need_space;
        }

        return InventoryResult.Ok;
    }


    private InventoryResult canStoreItem_InBag(byte bag, ArrayList<ItemPosCount> dest, ItemTemplate pProto, tangible.RefObject<Integer> count, boolean merge, boolean non_specialized, Item pSrcItem, byte skip_bag, byte skip_slot) {
        // skip specific bag already processed in first called CanStoreItem_InBag
        if (bag == skip_bag) {
            return InventoryResult.WrongBagType;
        }

        // skip not existed bag or self targeted bag
        var pBag = getBagByPos(bag);

        if (pBag == null || pBag == pSrcItem) {
            return InventoryResult.WrongBagType;
        }

        if (pSrcItem) {
            if (pSrcItem.isNotEmptyBag()) {
                return InventoryResult.DestroyNonemptyBag;
            }

            if (pSrcItem.hasItemFlag(ItemFieldFlags.Child)) {
                return InventoryResult.WrongBagType3;
            }
        }

        var pBagProto = pBag.getTemplate();

        if (pBagProto == null) {
            return InventoryResult.WrongBagType;
        }

        // specialized bag mode or non-specilized
        if (non_specialized != (pBagProto.getClass() == itemClass.Container && pBagProto.getSubClass() == (int) ItemSubClassContainer.Container.getValue())) {
            return InventoryResult.WrongBagType;
        }

        if (!item.itemCanGoIntoBag(pProto, pBagProto)) {
            return InventoryResult.WrongBagType;
        }

        for (byte j = 0; j < pBag.getBagSize(); j++) {
            // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
            if (j == skip_slot) {
                continue;
            }

            var pItem2 = getItemByPos(bag, j);

            // ignore move item (this slot will be empty at move)
            if (pItem2 == pSrcItem) {
                pItem2 = null;
            }

            // if merge skip empty, if !merge skip non-empty
            if ((pItem2 == null) == merge) {
                continue;
            }

            var need_space = pProto.getMaxStackSize();

            if (pItem2 != null) {
                // can be merged at least partly
                var res = pItem2.canBeMergedPartlyWith(pProto);

                if (res != InventoryResult.Ok) {
                    continue;
                }

                // descrease at current stacksize
                need_space -= pItem2.getCount();
            }

            if (need_space > count.refArgValue) {
                need_space = count.refArgValue;
            }

            ItemPosCount newPosition = new ItemPosCount((short) (bag << 8 | j), need_space);

            if (!newPosition.isContainedIn(dest)) {
                dest.add(newPosition);
                count.refArgValue -= need_space;

                if (count.refArgValue == 0) {
                    return InventoryResult.Ok;
                }
            }
        }

        return InventoryResult.Ok;
    }


    private byte findEquipSlot(Item item, int slot, boolean swap) {
        var slots = new byte[4];
        slots[0] = ItemConst.NullSlot;
        slots[1] = ItemConst.NullSlot;
        slots[2] = ItemConst.NullSlot;
        slots[3] = ItemConst.NullSlot;

        switch (item.getTemplate().getInventoryType()) {
            case Head:
                slots[0] = EquipmentSlot.Head;

                break;
            case Neck:
                slots[0] = EquipmentSlot.Neck;

                break;
            case Shoulders:
                slots[0] = EquipmentSlot.Shoulders;

                break;
            case Body:
                slots[0] = EquipmentSlot.Shirt;

                break;
            case Chest:
                slots[0] = EquipmentSlot.chest;

                break;
            case Robe:
                slots[0] = EquipmentSlot.chest;

                break;
            case Waist:
                slots[0] = EquipmentSlot.Waist;

                break;
            case Legs:
                slots[0] = EquipmentSlot.Legs;

                break;
            case Feet:
                slots[0] = EquipmentSlot.Feet;

                break;
            case Wrists:
                slots[0] = EquipmentSlot.Wrist;

                break;
            case Hands:
                slots[0] = EquipmentSlot.Hands;

                break;
            case Finger:
                slots[0] = EquipmentSlot.Finger1;
                slots[1] = EquipmentSlot.Finger2;

                break;
            case Trinket:
                slots[0] = EquipmentSlot.Trinket1;
                slots[1] = EquipmentSlot.Trinket2;

                break;
            case Cloak:
                slots[0] = EquipmentSlot.Cloak;

                break;
            case Weapon: {
                slots[0] = EquipmentSlot.MainHand;

                // suggest offhand slot only if know dual wielding
                // (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
                if (canDualWield) {
                    slots[1] = EquipmentSlot.OffHand;
                }

                break;
            }
            case Shield:
                slots[0] = EquipmentSlot.OffHand;

                break;
            case Ranged:
                slots[0] = EquipmentSlot.MainHand;

                break;
            case Weapon2Hand:
                slots[0] = EquipmentSlot.MainHand;

                if (canDualWield && canTitanGrip()) {
                    slots[1] = EquipmentSlot.OffHand;
                }

                break;
            case Tabard:
                slots[0] = EquipmentSlot.Tabard;

                break;
            case WeaponMainhand:
                slots[0] = EquipmentSlot.MainHand;

                break;
            case WeaponOffhand:
                slots[0] = EquipmentSlot.OffHand;

                break;
            case Holdable:
                slots[0] = EquipmentSlot.OffHand;

                break;
            case RangedRight:
                slots[0] = EquipmentSlot.MainHand;

                break;
            case Bag:
                slots[0] = InventorySlots.BagStart + 0;
                slots[1] = InventorySlots.BagStart + 1;
                slots[2] = InventorySlots.BagStart + 2;
                slots[3] = InventorySlots.BagStart + 3;

                break;
            case ProfessionTool:
            case ProfessionGear: {
                var isProfessionTool = item.getTemplate().getInventoryType() == inventoryType.ProfessionTool;

                // Validate item class
                if (!(item.getTemplate().getClass() == itemClass.profession)) {
                    return ItemConst.NullSlot;
                }

                // Check if player has profession skill
                var itemSkill = (int) item.getTemplate().getSkill().getValue();

                if (!hasSkill(itemSkill)) {
                    return ItemConst.NullSlot;
                }

                switch (ItemSubclassProfession.forValue(item.getTemplate().getSubClass())) {
                    case Cooking:
                        slots[0] = isProfessionTool ? ProfessionSlots.CookingTool : ProfessionSlots.CookingGear1;

                        break;
                    case Fishing: {
                        // Fishing doesn't make use of gear slots (clientside)
                        if (!isProfessionTool) {
                            return ItemConst.NullSlot;
                        }

                        slots[0] = ProfessionSlots.FishingTool;

                        break;
                    }
                    case Blacksmithing:
                    case Leatherworking:
                    case Alchemy:
                    case Herbalism:
                    case Mining:
                    case Tailoring:
                    case Engineering:
                    case Enchanting:
                    case Skinning:
                    case Jewelcrafting:
                    case Inscription: {
                        var professionSlot = getProfessionSlotFor(itemSkill);

                        if (professionSlot == -1) {
                            return ItemConst.NullSlot;
                        }

                        if (isProfessionTool) {
                            slots[0] = (byte) (ProfessionSlots.Profession1Tool + professionSlot * ProfessionSlots.maxCount);
                        } else {
                            slots[0] = (byte) (ProfessionSlots.Profession1Gear1 + professionSlot * ProfessionSlots.maxCount);
                            slots[0] = (byte) (ProfessionSlots.Profession1Gear2 + professionSlot * ProfessionSlots.maxCount);
                        }

                        break;
                    }
                    default:
                        return ItemConst.NullSlot;
                }

                break;
            }
            default:
                return ItemConst.NullSlot;
        }


        if (slot != ItemConst.NullSlot) {
            if (swap || getItemByPos(InventorySlots.Bag0, (byte) slot) == null) {
                for (byte i = 0; i < 4; ++i) {
                    if (slots[i] == slot) {
                        return (byte) slot;
                    }
                }
            }
        } else {
            // search free slot at first
            for (byte i = 0; i < 4; ++i) {
                if (slots[i] != ItemConst.NullSlot && getItemByPos(InventorySlots.Bag0, slots[i]) == null) {
                    // in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
                    if (slots[i] != EquipmentSlot.OffHand || !isTwoHandUsed()) {
                        return slots[i];
                    }
                }
            }

            // if not found free and can swap return slot with lower item level equipped
            if (swap) {
                var minItemLevel = Integer.MAX_VALUE;
                byte minItemLevelIndex = 0;

                for (byte i = 0; i < 4; ++i) {
                    if (slots[i] != ItemConst.NullSlot) {
                        var equipped = getItemByPos(InventorySlots.Bag0, slots[i]);

                        if (equipped != null) {
                            var itemLevel = equipped.getItemLevel(this);

                            if (itemLevel < minItemLevel) {
                                minItemLevel = itemLevel;
                                minItemLevelIndex = i;
                            }
                        }
                    }
                }

                return slots[minItemLevelIndex];
            }
        }

        // no free position
        return ItemConst.NullSlot;
    }


    private InventoryResult canEquipNewItem(byte slot, tangible.OutObject<SHORT> dest, int item, boolean swap) {
        dest.outArgValue = 0;
        var pItem = item.createItem(item, 1, itemContext.NONE, this);

        if (pItem != null) {
            var result = canEquipItem(slot, dest, pItem, swap);

            return result;
        }

        return InventoryResult.ItemNotFound;
    }

    //Artifact
    private void applyArtifactPowers(Item item, boolean apply) {
        if (item.isArtifactDisabled()) {
            return;
        }

        for (var artifactPower : item.getItemData().artifactPowers) {
            var rank = artifactPower.currentRankWithBonus;

            if (rank == 0) {
                continue;
            }

            if (CliDB.ArtifactPowerStorage.get(artifactPower.artifactPowerId).flags.hasFlag(ArtifactPowerFlag.ScalesWithNumPowers)) {
                rank = 1;
            }

            var artifactPowerRank = global.getDB2Mgr().GetArtifactPowerRank(artifactPower.artifactPowerId, (byte) (rank - 1));

            if (artifactPowerRank == null) {
                continue;
            }

            applyArtifactPowerRank(item, artifactPowerRank, apply);
        }

        var artifactAppearance = CliDB.ArtifactAppearanceStorage.get(item.getModifier(ItemModifier.artifactAppearanceId));

        if (artifactAppearance != null) {
            if (artifactAppearance.OverrideShapeshiftDisplayID != 0 && getShapeshiftForm() == ShapeShiftForm.forValue(artifactAppearance.OverrideShapeshiftFormID)) {
                restoreDisplayId();
            }
        }
    }

    private void applyAzeritePowers(Item item, boolean apply) {
        var azeriteItem = item.getAsAzeriteItem();

        if (azeriteItem != null) {
            // milestone powers
            for (var azeriteItemMilestonePowerId : azeriteItem.AzeriteItemData.UnlockedEssenceMilestones) {
                applyAzeriteItemMilestonePower(azeriteItem, CliDB.AzeriteItemMilestonePowerStorage.get(azeriteItemMilestonePowerId), apply);
            }

            // essences
            var selectedEssences = azeriteItem.GetSelectedAzeriteEssences();

            if (selectedEssences != null) {
                for (byte slot = 0; slot < SharedConst.MaxAzeriteEssenceSlot; ++slot) {
                    if (selectedEssences.azeriteEssenceID.get(slot) != 0) {
                        applyAzeriteEssence(azeriteItem, selectedEssences.azeriteEssenceID.get(slot), azeriteItem.GetEssenceRank(selectedEssences.azeriteEssenceID.get(slot)), global.getDB2Mgr().GetAzeriteItemMilestonePower(slot).type == AzeriteItemMilestoneType.MajorEssence.getValue(), apply);
                    }
                }
            }
        } else {
            var azeriteEmpoweredItem = item.getAsAzeriteEmpoweredItem();

            if (azeriteEmpoweredItem) {
                if (!apply || getItemByEntry(PlayerConst.ItemIdHeartOfAzeroth, ItemSearchLocation.Equipment)) {
                    for (var i = 0; i < SharedConst.MaxAzeriteEmpoweredTier; ++i) {
                        var azeritePower = CliDB.AzeritePowerStorage.get(azeriteEmpoweredItem.GetSelectedAzeritePower(i));

                        if (azeritePower != null) {
                            applyAzeritePower(azeriteEmpoweredItem, azeritePower, apply);
                        }
                    }
                }
            }
        }
    }

    private void applyAzeriteEssencePower(AzeriteItem item, AzeriteEssencePowerRecord azeriteEssencePower, boolean major, boolean apply) {
        var powerSpell = global.getSpellMgr().getSpellInfo(azeriteEssencePower.MinorPowerDescription, Difficulty.NONE);

        if (powerSpell != null) {
            if (apply) {
                castSpell(this, powerSpell.getId(), item);
            } else {
                removeAurasDueToItemSpell(powerSpell.getId(), item.getGUID());
            }
        }

        if (major) {
            powerSpell = global.getSpellMgr().getSpellInfo(azeriteEssencePower.MajorPowerDescription, Difficulty.NONE);

            if (powerSpell != null) {
                if (powerSpell.isPassive()) {
                    if (apply) {
                        castSpell(this, powerSpell.getId(), item);
                    } else {
                        removeAurasDueToItemSpell(powerSpell.getId(), item.getGUID());
                    }
                } else {
                    if (apply) {
                        learnSpell(powerSpell.getId(), true, 0, true);
                    } else {
                        removeSpell(powerSpell.getId(), false, false, true);
                    }
                }
            }
        }
    }


    private boolean hasItemWithLimitCategoryEquipped(int limitCategory, int count, byte except_slot) {
        int tempcount = 0;

        return !forEachItem(ItemSearchLocation.Equipment, pItem ->
        {
            if (pItem.slot == except_slot) {
                return true;
            }

            if (pItem.template.ItemLimitCategory != limitCategory) {
                return true;
            }

            tempcount += pItem.count;

            if (tempcount >= count) {
                return false;
            }

            return true;
        });
    }


    private boolean hasGemWithLimitCategoryEquipped(int limitCategory, int count, byte except_slot) {
        int tempcount = 0;

        return !forEachItem(ItemSearchLocation.Equipment, pItem ->
        {
            if (pItem.slot == except_slot) {
                return true;
            }

            var pProto = pItem.template;

            if (pProto == null) {
                return true;
            }

            tempcount += pItem.getGemCountWithLimitCategory(limitCategory);

            if (tempcount >= count) {
                return false;
            }

            return true;
        });
    }


    private void visualizeItem(int slot, Item pItem) {
        if (pItem == null) {
            return;
        }

        // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
        if (pItem.getBonding() == ItemBondingType.OnEquip || pItem.getBonding() == ItemBondingType.OnAcquire || pItem.getBonding() == ItemBondingType.Quest) {
            pItem.setBinding(true);

            if (isInWorld()) {
                getSession().getCollectionMgr().addItemAppearance(pItem);
            }
        }

        Log.outDebug(LogFilter.player, "STORAGE: EquipItem slot = {0}, item = {1}", slot, pItem.getEntry());

        _items[slot] = pItem;
        setInvSlot(slot, pItem.getGUID());
        pItem.setContainedIn(getGUID());
        pItem.setOwnerGUID(getGUID());
        pItem.setSlot((byte) slot);
        pItem.setContainer(null);

        if (slot < EquipmentSlot.End) {
            setVisibleItemSlot(slot, pItem);
        }

        pItem.setState(ItemUpdateState.changed, this);
    }

    private void autoStoreLoot(byte bag, byte slot, int loot_id, LootStore store, ItemContext context, boolean broadcast) {
        autoStoreLoot(bag, slot, loot_id, store, context, broadcast, false);
    }

    private void autoStoreLoot(byte bag, byte slot, int loot_id, LootStore store, ItemContext context) {
        autoStoreLoot(bag, slot, loot_id, store, context, false, false);
    }

    private void autoStoreLoot(byte bag, byte slot, int loot_id, LootStore store) {
        autoStoreLoot(bag, slot, loot_id, store, 0, false, false);
    }

    private void autoStoreLoot(byte bag, byte slot, int loot_id, LootStore store, ItemContext context, boolean broadcast, boolean createdByPlayer) {
        Loot loot = new loot(null, ObjectGuid.Empty, LootType.NONE, null);
        loot.fillLoot(loot_id, store, this, true, false, LootModes.Default, context);

        loot.autoStore(this, bag, slot, broadcast, createdByPlayer);
        procSkillsAndAuras(this, null, new ProcFlagsInit(procFlags.Looted), new ProcFlagsInit(procFlags.NONE), ProcFlagsSpellType.MaskAll, ProcFlagsSpellPhase.NONE, ProcFlagsHit.NONE, null, null, null);
    }

    private void sendEquipmentSetList() {
        LoadEquipmentSet data = new LoadEquipmentSet();

        for (var pair : equipmentSets.entrySet()) {
            if (pair.getValue().state == EquipmentSetUpdateState.Deleted) {
                continue;
            }

            data.setData.add(pair.getValue().data);
        }

        sendPacket(data);
    }

    //Misc
    private void updateItemLevelAreaBasedScaling() {
        // @todo Activate pvp item levels during world pvp
        var map = getMap();
        var pvpActivity = map.isBattlegroundOrArena() || (new integer(map.getEntry().Flags[1])).hasFlag(0x40) || hasPvpRulesEnabled();

        if (usePvpItemLevels != pvpActivity) {
            var healthPct = getHealthPct();
            _RemoveAllItemMods();
            activatePvpItemLevels(pvpActivity);
            _ApplyAllItemMods();
            setHealth(MathUtil.CalculatePct(getMaxHealth(), healthPct));
        }
        // @todo other types of power scaling such as timewalking
    }

    private boolean forEachEquipmentSlot(InventoryType inventoryType, boolean canDualWield, boolean canTitanGrip, EquipmentSlotDelegate callback) {
        switch (inventoryType) {
            case Head:
                callback.invoke(EquipmentSlot.Head);

                return true;
            case Neck:
                callback.invoke(EquipmentSlot.Neck);

                return true;
            case Shoulders:
                callback.invoke(EquipmentSlot.Shoulders);

                return true;
            case Body:
                callback.invoke(EquipmentSlot.Shirt);

                return true;
            case Robe:
            case Chest:
                callback.invoke(EquipmentSlot.chest);

                return true;
            case Waist:
                callback.invoke(EquipmentSlot.Waist);

                return true;
            case Legs:
                callback.invoke(EquipmentSlot.Legs);

                return true;
            case Feet:
                callback.invoke(EquipmentSlot.Feet);

                return true;
            case Wrists:
                callback.invoke(EquipmentSlot.Wrist);

                return true;
            case Hands:
                callback.invoke(EquipmentSlot.Hands);

                return true;
            case Cloak:
                callback.invoke(EquipmentSlot.Cloak);

                return true;
            case Finger:
                callback.invoke(EquipmentSlot.Finger1);
                callback.invoke(EquipmentSlot.Finger2, true);

                return true;
            case Trinket:
                callback.invoke(EquipmentSlot.Trinket1);
                callback.invoke(EquipmentSlot.Trinket2, true);

                return true;
            case Weapon:
                callback.invoke(EquipmentSlot.MainHand);

                if (canDualWield) {
                    callback.invoke(EquipmentSlot.OffHand, true);
                }

                return true;
            case Weapon2Hand:
                callback.invoke(EquipmentSlot.MainHand);

                if (canDualWield && canTitanGrip) {
                    callback.invoke(EquipmentSlot.OffHand, true);
                }

                return true;
            case Ranged:
            case RangedRight:
            case WeaponMainhand:
                callback.invoke(EquipmentSlot.MainHand);

                return true;
            case Shield:
            case Holdable:
            case WeaponOffhand:
                callback.invoke(EquipmentSlot.OffHand);

                return true;
            default:
                return false;
        }
    }

    public final Difficulty getDungeonDifficultyId() {
        return dungeonDifficulty;
    }

    public final void setDungeonDifficultyId(Difficulty value) {
        dungeonDifficulty = value;
    }

    public final Difficulty getRaidDifficultyId() {
        return raidDifficulty;
    }

    public final void setRaidDifficultyId(Difficulty value) {
        raidDifficulty = value;
    }

    public final Difficulty getLegacyRaidDifficultyId() {
        return legacyRaidDifficulty;
    }

    public final void setLegacyRaidDifficultyId(Difficulty value) {
        legacyRaidDifficulty = value;
    }

    public final ZonePVPTypeOverride getOverrideZonePvpType() {
        return ZonePVPTypeOverride.forValue((int) getActivePlayerData().overrideZonePVPType);
    }

    public final void setOverrideZonePvpType(ZonePVPTypeOverride value) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().overrideZonePVPType), (int) value.getValue());
    }

    public final Difficulty getDifficultyId(MapEntry mapEntry) {
        if (!mapEntry.isRaid()) {
            return dungeonDifficulty;
        }

        var defaultDifficulty = getWorldContext().getDbcObjectManager().getDefaultMapDifficulty(mapEntry.getId());

        if (defaultDifficulty == null) {
            return legacyRaidDifficulty;
        }

        var difficulty = getWorldContext().getDbcObjectManager().difficulty(defaultDifficulty.getDifficultyID());

        if (difficulty == null || difficulty.flags().hasFlag(DifficultyFlag.LEGACY)) {
            return legacyRaidDifficulty;
        }

        return raidDifficulty;
    }

    public final void sendRaidGroupOnlyMessage(RaidGroupReason reason, int delay) {
        RaidGroupOnly raidGroupOnly = new RaidGroupOnly();
        raidGroupOnly.delay = delay;
        raidGroupOnly.reason = reason;

        sendPacket(raidGroupOnly);
    }


    public final void updateZone(int newZone, int newArea) {
        if (!isInWorld()) {
            return;
        }

        var oldZone = zoneUpdateId;
        zoneUpdateId = newZone;
        zoneUpdateTimer = 1 * time.InMilliseconds;

        getMap().updatePlayerZoneStats(oldZone, newZone);

        // call leave script hooks immedately (before updating flags)
        if (oldZone != newZone) {
            global.getOutdoorPvPMgr().handlePlayerLeaveZone(this, oldZone);
            global.getBattleFieldMgr().handlePlayerLeaveZone(this, oldZone);
        }

        // group update
        if (getGroup()) {
            setGroupUpdateFlag(GroupUpdateFlags.Full);

            var pet = getCurrentPet();

            if (pet) {
                pet.setGroupUpdateFlag(GroupUpdatePetFlags.Full);
            }
        }

        // zone changed, so area changed as well, update it
        updateArea(newArea);

        var zone = CliDB.AreaTableStorage.get(newZone);

        if (zone == null) {
            return;
        }

        if (WorldConfig.getBoolValue(WorldCfg.Weather)) {
            getMap().getOrGenerateZoneDefaultWeather(newZone);
        }

        getMap().sendZoneDynamicInfo(newZone, this);

        updateWarModeAuras();

        updateHostileAreaState(zone);

        if (zone.hasFlag(AreaFlags.Capital)) // Is in a capital city
        {
            if (!pvpInfo.isInHostileArea || zone.IsSanctuary()) {
                restMgr.setRestFlag(RestFlag.City);
            }

            pvpInfo.isInNoPvPArea = true;
        } else {
            restMgr.removeRestFlag(RestFlag.City);
        }

        updatePvPState();

        // remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
        // if player resurrected at teleport this will be applied in resurrect code
        if (isAlive()) {
            destroyZoneLimitedItem(true, newZone);
        }

        // check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
        autoUnequipOffhandIfNeed();

        // recent client version not send leave/join channel packets for built-in local channels
        updateLocalChannels(newZone);

        updateZoneDependentAuras(newZone);

        // call enter script hooks after everyting else has processed
        global.getScriptMgr().<IPlayerOnUpdateZone>ForEach(p -> p.OnUpdateZone(this, newZone, newArea));

        if (oldZone != newZone) {
            global.getOutdoorPvPMgr().handlePlayerEnterZone(this, newZone);
            global.getBattleFieldMgr().handlePlayerEnterZone(this, newZone);
            sendInitWorldStates(newZone, newArea); // only if really enters to new zone, not just area change, works strange...
            var guild = getGuild();

            if (guild) {
                guild.updateMemberData(this, GuildMemberData.zoneId, newZone);
            }
        }
    }

    public final void updateHostileAreaState(AreaTableRecord area) {
        var overrideZonePvpType = getOverrideZonePvpType();

        pvpInfo.isInHostileArea = false;

        if (area.IsSanctuary()) // sanctuary and arena cannot be overriden
        {
            pvpInfo.isInHostileArea = false;
        } else if (area.hasFlag(AreaFlags.Arena)) {
            pvpInfo.isInHostileArea = true;
        } else if (overrideZonePvpType == ZonePVPTypeOverride.NONE) {
            if (getInBattleground() || area.hasFlag(AreaFlags.Combat) || (area.PvpCombatWorldStateID != -1 && global.getWorldStateMgr().getValue(area.PvpCombatWorldStateID, getMap()) != 0)) {
                pvpInfo.isInHostileArea = true;
            } else if (isWarModeLocalActive() || area.hasFlag(AreaFlags.unk3)) {
                if (area.hasFlag(AreaFlags.ContestedArea)) {
                    pvpInfo.isInHostileArea = isWarModeLocalActive();
                } else {
                    var factionTemplate = getFactionTemplateEntry();

                    if (factionTemplate == null || factionTemplate.FriendGroup.hasFlag(area.FactionGroupMask)) {
                        pvpInfo.isInHostileArea = false; // friend area are considered hostile if war mode is active
                    } else if (factionTemplate.EnemyGroup.hasFlag(area.FactionGroupMask)) {
                        pvpInfo.isInHostileArea = true;
                    } else {
                        pvpInfo.isInHostileArea = global.getWorldMgr().isPvPRealm();
                    }
                }
            }
        } else {
            switch (overrideZonePvpType) {
                case Friendly:
                    pvpInfo.isInHostileArea = false;

                    break;
                case Hostile:
                case Contested:
                case Combat:
                    pvpInfo.isInHostileArea = true;

                    break;
            }
        }

        // Treat players having a quest flagging for PvP as always in hostile area
        pvpInfo.isHostile = pvpInfo.isInHostileArea || hasPvPForcingQuest() || isWarModeLocalActive();
    }

    public final void confirmPendingBind() {
        var map = getMap().getToInstanceMap();

        if (map == null || map.getInstanceId() != pendingBindId) {
            return;
        }

        if (!isGameMaster()) {
            map.createInstanceLockForPlayer(this);
        }
    }


    public final void setPendingBind(int instanceId, int bindTimer) {
        pendingBindId = instanceId;
        pendingBindTimer = bindTimer;
    }

    public final void sendRaidInfo() {
        var now = gameTime.GetSystemTime();

        var instanceLocks = global.getInstanceLockMgr().getInstanceLocksForPlayer(getGUID());

        InstanceInfoPkt instanceInfo = new InstanceInfoPkt();

        for (var instanceLock : instanceLocks) {
            InstanceLockPkt lockInfos = new InstanceLockPkt();
            lockInfos.instanceID = instanceLock.getInstanceId();
            lockInfos.mapID = instanceLock.getMapId();
            lockInfos.difficultyID = (int) instanceLock.getDifficultyId().getValue();
            lockInfos.timeRemaining = (int) Math.max((instanceLock.getEffectiveExpiryTime() - now).TotalSeconds, 0);
            lockInfos.completedMask = instanceLock.getData().getCompletedEncountersMask();

            lockInfos.locked = !instanceLock.isExpired();
            lockInfos.extended = instanceLock.isExtended();

            instanceInfo.lockList.add(lockInfos);
        }

        sendPacket(instanceInfo);
    }

    public final boolean satisfy(AccessRequirement ar, int targetMap, TransferAbortParams abortParams) {
        return satisfy(ar, targetMap, abortParams, false);
    }

    public final boolean satisfy(AccessRequirement ar, int targetMap) {
        return satisfy(ar, targetMap, null, false);
    }

    public final boolean satisfy(AccessRequirement ar, int targetMap, TransferAbortParams abortParams, boolean report) {
        if (!isGameMaster()) {
            byte levelMin = 0;
            byte levelMax = 0;
            int failedMapDifficultyXCondition = 0;
            int missingItem = 0;
            int missingQuest = 0;
            int missingAchievement = 0;

            var mapEntry = CliDB.MapStorage.get(targetMap);

            if (mapEntry == null) {
                return false;
            }

            var targetDifficulty = getDifficultyId(mapEntry);
            tangible.RefObject<Difficulty> tempRef_targetDifficulty = new tangible.RefObject<Difficulty>(targetDifficulty);
            var mapDiff = global.getDB2Mgr().GetDownscaledMapDifficultyData(targetMap, tempRef_targetDifficulty);
            targetDifficulty = tempRef_targetDifficulty.refArgValue;

            if (!WorldConfig.getBoolValue(WorldCfg.InstanceIgnoreLevel)) {
                var mapDifficultyConditions = global.getDB2Mgr().GetMapDifficultyConditions(mapDiff.id);

                for (var pair : mapDifficultyConditions) {
                    if (!ConditionManager.isPlayerMeetingCondition(this, pair.item2)) {
                        failedMapDifficultyXCondition = pair.Item1;

                        break;
                    }
                }
            }

            if (ar != null) {
                if (!WorldConfig.getBoolValue(WorldCfg.InstanceIgnoreLevel)) {
                    if (ar.getLevelMin() != 0 && getLevel() < ar.getLevelMin()) {
                        levelMin = ar.getLevelMin();
                    }

                    if (ar.getLevelMax() != 0 && getLevel() > ar.getLevelMax()) {
                        levelMax = ar.getLevelMax();
                    }
                }

                if (ar.getItem() != 0) {
                    if (!hasItemCount(ar.getItem()) && (ar.getItem2() == 0 || !hasItemCount(ar.getItem2()))) {
                        missingItem = ar.getItem();
                    }
                } else if (ar.getItem2() != 0 && !hasItemCount(ar.getItem2())) {
                    missingItem = ar.getItem2();
                }

                if (getTeam() == Team.ALLIANCE && ar.getQuestA() != 0 && !getQuestRewardStatus(ar.getQuestA())) {
                    missingQuest = ar.getQuestA();
                } else if (getTeam() == Team.Horde && ar.getQuestH() != 0 && !getQuestRewardStatus(ar.getQuestH())) {
                    missingQuest = ar.getQuestH();
                }

                var leader = this;
                var leaderGuid = getGroup() != null ? getGroup().getLeaderGUID() : getGUID();

                if (ObjectGuid.opNotEquals(leaderGuid, getGUID())) {
                    leader = global.getObjAccessor().findPlayer(leaderGuid);
                }

                if (ar.getAchievement() != 0) {
                    if (leader == null || !leader.hasAchieved(ar.getAchievement())) {
                        missingAchievement = ar.getAchievement();
                    }
                }
            }

            if (levelMin != 0 || levelMax != 0 || failedMapDifficultyXCondition != 0 || missingItem != 0 || missingQuest != 0 || missingAchievement != 0) {
                if (abortParams != null) {
                    abortParams.setReason(TransferAbortReason.error);
                }

                if (report) {
                    if (missingQuest != 0 && ar != null && !StringUtil.isEmpty(ar.getQuestFailedText())) {
                        sendSysMessage("{0}", ar.getQuestFailedText());
                    } else if (!mapDiff.message.get(global.getWorldMgr().getDefaultDbcLocale()).isEmpty() && mapDiff.message.get(global.getWorldMgr().getDefaultDbcLocale()).charAt(0) != '\0' || failedMapDifficultyXCondition != 0) // if (missingAchievement) covered by this case
                    {
                        if (abortParams != null) {
                            abortParams.setReason(TransferAbortReason.Difficulty);
                            abortParams.setArg((byte) targetDifficulty.getValue());
                            abortParams.setMapDifficultyXConditionId(failedMapDifficultyXCondition);
                        }
                    } else if (missingItem != 0) {
                        getSession().sendNotification(global.getObjectMgr().getCypherString(CypherStrings.LevelMinrequiredAndItem), levelMin, global.getObjectMgr().getItemTemplate(missingItem).getName());
                    } else if (levelMin != 0) {
                        getSession().sendNotification(global.getObjectMgr().getCypherString(CypherStrings.LevelMinrequired), levelMin);
                    }
                }

                return false;
            }
        }

        return true;
    }

    public final boolean checkInstanceValidity(boolean isLogin) {
        // game masters' instances are always valid
        if (isGameMaster()) {
            return true;
        }

        // non-instances are always valid
        var map = getMap();
        var instance = map == null ? null : map.getToInstanceMap();

        if (instance == null) {
            return true;
        }

        var group = getGroup();

        // raid instances require the player to be in a raid group to be valid
        if (map.isRaid() && !WorldConfig.getBoolValue(WorldCfg.InstanceIgnoreRaid) && (map.getEntry().expansion() >= expansion.forValue(WorldConfig.getIntValue(WorldCfg.expansion)))) {
            if (group == null || group.isRaidGroup()) {
                return false;
            }
        }

        if (group) {
            // check if player's group is bound to this instance
            return group == instance.getOwningGroup();
        } else {
            // instance is invalid if we are not grouped and there are other players
            return map.getPlayersCountExceptGMs() <= 1;
        }
    }


    public final boolean checkInstanceCount(int instanceId) {
        if (instanceResetTimes.size() < WorldConfig.getIntValue(WorldCfg.MaxInstancesPerHour)) {
            return true;
        }

        return instanceResetTimes.containsKey(instanceId);
    }


    public final void addInstanceEnterTime(int instanceId, long enterTime) {
        if (!instanceResetTimes.containsKey(instanceId)) {
            instanceResetTimes.put(instanceId, enterTime + time.Hour);
        }
    }

    public final void sendDungeonDifficulty() {
        sendDungeonDifficulty(-1);
    }

    public final void sendDungeonDifficulty(int forcedDifficulty) {
        DungeonDifficultySet dungeonDifficultySet = new DungeonDifficultySet();
        dungeonDifficultySet.difficultyID = forcedDifficulty == -1 ? getDungeonDifficultyId().getValue() : forcedDifficulty;
        sendPacket(dungeonDifficultySet);
    }

    public final void sendRaidDifficulty(boolean legacy) {
        sendRaidDifficulty(legacy, -1);
    }

    public final void sendRaidDifficulty(boolean legacy, int forcedDifficulty) {
        RaidDifficultySet raidDifficultySet = new RaidDifficultySet();
        raidDifficultySet.difficultyID = forcedDifficulty == -1 ? (int) (legacy ? getLegacyRaidDifficultyId() : getRaidDifficultyId()) : forcedDifficulty;
        raidDifficultySet.legacy = legacy;
        sendPacket(raidDifficultySet);
    }


    public final void sendResetFailedNotify(int mapid) {
        sendPacket(new ResetFailedNotify());
    }

    // Reset all solo instances and optionally send a message on success for each
    public final void resetInstances(InstanceResetMethod method) {
// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(mapId, instanceId) : recentInstances.ToList()) {
            var map = global.getMapMgr().findMap(mapId, instanceId);
            var forgetInstance = false;

            if (map) {
                var instance = map.getToInstanceMap();

                if (instance != null) {
                    switch (instance.reset(method)) {
                        case Success:
                            sendResetInstanceSuccess(map.getId());
                            forgetInstance = true;

                            break;
                        case NotEmpty:
                            if (method == InstanceResetMethod.Manual) {
                                sendResetInstanceFailed(resetFailedReason.Failed, map.getId());
                            } else if (method == InstanceResetMethod.OnChangeDifficulty) {
                                forgetInstance = true;
                            }

                            break;
                        case CannotReset:
                            break;
                    }
                }
            }

            if (forgetInstance) {
                recentInstances.remove(mapId);
            }
        }
    }


    public final void sendResetInstanceSuccess(int mapId) {
        InstanceReset data = new InstanceReset();
        data.mapID = mapId;
        sendPacket(data);
    }


    public final void sendResetInstanceFailed(ResetFailedReason reason, int mapId) {
        InstanceResetFailed data = new InstanceResetFailed();
        data.mapID = mapId;
        data.resetFailedReason = reason;
        sendPacket(data);
    }

    public final void sendTransferAborted(int mapid, TransferAbortReason reason, byte arg) {
        sendTransferAborted(mapid, reason, arg, 0);
    }

    public final void sendTransferAborted(int mapid, TransferAbortReason reason) {
        sendTransferAborted(mapid, reason, 0, 0);
    }

    public final void sendTransferAborted(int mapid, TransferAbortReason reason, byte arg, int mapDifficultyXConditionId) {
        TransferAborted transferAborted = new TransferAborted();
        transferAborted.mapID = mapid;
        transferAborted.arg = arg;
        transferAborted.transfertAbort = reason;
        transferAborted.mapDifficultyXConditionID = mapDifficultyXConditionId;
        sendPacket(transferAborted);
    }


    public final boolean isLockedToDungeonEncounter(int dungeonEncounterId) {
        var dungeonEncounter = CliDB.DungeonEncounterStorage.get(dungeonEncounterId);

        if (dungeonEncounter == null) {
            return false;
        }

        var instanceLock = global.getInstanceLockMgr().findActiveInstanceLock(getGUID(), new MapDb2Entries(getMap().getEntry(), getMap().getMapDifficulty()));

        if (instanceLock == null) {
            return false;
        }

        return (instanceLock.getData().getCompletedEncountersMask() & (1 << dungeonEncounter.bit)) != 0;
    }

    @Override
    public void processTerrainStatusUpdate(ZLiquidStatus oldLiquidStatus, LiquidData newLiquidData) {
        // process liquid auras using generic unit code
        super.processTerrainStatusUpdate(oldLiquidStatus, newLiquidData);

        mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() & ~(PlayerUnderwaterState.InWater.getValue() | PlayerUnderwaterState.InLava.getValue().getValue() | PlayerUnderwaterState.InSlime.getValue().getValue().getValue() | PlayerUnderwaterState.InDarkWater.getValue().getValue().getValue()).getValue());

        // player specific logic for mirror timers
        if (getLiquidStatus() != 0 && newLiquidData != null) {
            // Breath bar state (under water in any liquid type)
            if (newLiquidData.type_flags.hasFlag(LiquidHeaderTypeFlags.AllLiquids)) {
                if (getLiquidStatus().hasFlag(ZLiquidStatus.UnderWater)) {
                    mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() | PlayerUnderwaterState.InWater.getValue());
                }
            }

            // Fatigue bar state (if not on flight path or transport)
            if (newLiquidData.type_flags.hasFlag(LiquidHeaderTypeFlags.DarkWater) && !isInFlight() && getTransport() == null) {
                mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() | PlayerUnderwaterState.InDarkWater.getValue());
            }

            // Lava state (any contact)
            if (newLiquidData.type_flags.hasFlag(LiquidHeaderTypeFlags.Magma)) {
                if (getLiquidStatus().hasFlag(ZLiquidStatus.InContact)) {
                    mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() | PlayerUnderwaterState.InLava.getValue());
                }
            }

            // Slime state (any contact)
            if (newLiquidData.type_flags.hasFlag(LiquidHeaderTypeFlags.Slime)) {
                if (getLiquidStatus().hasFlag(ZLiquidStatus.InContact)) {
                    mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() | PlayerUnderwaterState.InSlime.getValue());
                }
            }
        }

        if (hasAuraType(AuraType.ForceBeathBar)) {
            mirrorTimerFlags = PlayerUnderwaterState.forValue(mirrorTimerFlags.getValue() | PlayerUnderwaterState.InWater.getValue());
        }
    }


    public final int getRecentInstanceId(int mapId) {
        return recentInstances.get(mapId);
    }


    public final void setRecentInstance(int mapId, int instanceId) {
        recentInstances.put(mapId, instanceId);
    }


    private void updateArea(int newArea) {
        // FFA_PVP flags are area and not zone id dependent
        // so apply them accordingly
        areaUpdateId = newArea;

        var area = CliDB.AreaTableStorage.get(newArea);
        var oldFfaPvPArea = pvpInfo.isInFfaPvPArea;
        pvpInfo.isInFfaPvPArea = area != null && area.hasFlag(AreaFlags.Arena);
        updatePvPState(true);

        // check if we were in ffa arena and we left
        if (oldFfaPvPArea && !pvpInfo.isInFfaPvPArea) {
            validateAttackersAndOwnTarget();
        }

        PhasingHandler.onAreaChange(this);
        updateAreaDependentAuras(newArea);

        if (isAreaThatActivatesPvpTalents(newArea)) {
            enablePvpRules();
        } else {
            disablePvpRules();
        }

        // previously this was in UpdateZone (but after UpdateArea) so nothing will break
        pvpInfo.isInNoPvPArea = false;

        if (area != null && area.IsSanctuary()) // in sanctuary
        {
            setPvpFlag(UnitPVPStateFlags.Sanctuary);
            pvpInfo.isInNoPvPArea = true;

            if (getDuel() == null && getCombatManager().hasPvPCombat()) {
                combatStopWithPets();
            }
        } else {
            removePvpFlag(UnitPVPStateFlags.Sanctuary);
        }

        var areaRestFlag = (getTeam() == Team.ALLIANCE) ? AreaFlags.RestZoneAlliance : AreaFlags.RestZoneHorde;

        if (area != null && area.hasFlag(areaRestFlag)) {
            restMgr.setRestFlag(RestFlag.FactionArea);
        } else {
            restMgr.removeRestFlag(RestFlag.FactionArea);
        }

        pushQuests();

        updateCriteria(CriteriaType.EnterTopLevelArea, newArea);

        updateMountCapability();
    }

    private boolean isInstanceLoginGameMasterException() {
        if (!getCanBeGameMaster()) {
            return false;
        }

        sendSysMessage(CypherStrings.InstanceLoginGamemasterException);

        return true;
    }


    public final int getHonorLevel() {
        return getPlayerData().honorLevel;
    }

    private void setHonorLevel(byte level) {
        var oldHonorLevel = (byte) getHonorLevel();

        if (level == oldHonorLevel) {
            return;
        }

        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().honorLevel), level);
        updateHonorNextLevel();

        updateCriteria(CriteriaType.HonorLevelIncrease);
    }

    public final boolean isMaxHonorLevel() {
        return getHonorLevel() == PlayerConst.MaxHonorLevel;
    }

    public final boolean isUsingPvpItemLevels() {
        return usePvpItemLevels;
    }

    //BGs
    public final Battleground getBattleground() {
        if (getBattlegroundId() == 0) {
            return null;
        }

        return global.getBattlegroundMgr().getBattleground(getBattlegroundId(), bgData.getBgTypeId());
    }

    public final boolean getHasFreeBattlegroundQueueId() {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), null)) {
                return true;
            }
        }

        return false;
    }

    public final WorldLocation getBattlegroundEntryPoint() {
        return bgData.getJoinPos();
    }

    public final boolean getInBattleground() {
        return bgData.getBgInstanceId() != 0;
    }

    public final int getBattlegroundId() {
        return bgData.getBgInstanceId();
    }

    public final BattlegroundTypeId getBattlegroundTypeId() {
        return bgData.getBgTypeId();
    }

    public final boolean getCanCaptureTowerPoint() {
        return (!getHasStealthAura() && !getHasInvisibilityAura() && isAlive());
    }

    //PvP
    public final void updateHonorFields() {
        // called when rewarding honor and at each save
        var now = gameTime.GetGameTime();
        var today = (gameTime.GetGameTime() / time.Day) * time.Day;

        if (lastHonorUpdateTime < today) {
            var yesterday = today - time.Day;

            // update yesterday's contribution
            if (lastHonorUpdateTime >= yesterday) {
                // this is the first update today, reset today's contribution
                setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().yesterdayHonorableKills), getActivePlayerData().todayHonorableKills);
            } else {
                // no honor/kills yesterday or today, reset
                setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().yesterdayHonorableKills), (short) 0);
            }

            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().todayHonorableKills), (short) 0);
        }

        lastHonorUpdateTime = now;
    }

    public final boolean rewardHonor(Unit victim, int groupsize, int honor) {
        return rewardHonor(victim, groupsize, honor, false);
    }

    public final boolean rewardHonor(Unit victim, int groupsize) {
        return rewardHonor(victim, groupsize, -1, false);
    }

    public final boolean rewardHonor(Unit victim, int groupsize, int honor, boolean pvptoken) {
        // do not reward honor in arenas, but enable onkill spellproc
        if (getInArena()) {
            if (!victim || victim == this || !victim.isTypeId(TypeId.PLAYER)) {
                return false;
            }

            return getBgTeam() != victim.toPlayer().getBgTeam();
        }

        // 'Inactive' this aura prevents the player from gaining honor points and BattlegroundTokenizer
        if (hasAura(BattlegroundConst.SpellAuraPlayerInactive)) {
            return false;
        }

        var victimGuid = ObjectGuid.Empty;
        int victim_rank = 0;

        // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
        updateHonorFields();

        // do not reward honor in arenas, but return true to enable onkill spellproc
        if (getInBattleground() && getBattleground() && getBattleground().isArena()) {
            return true;
        }

        // Promote to float for calculations
        float honorF = honor;

        if (honorF <= 0) {
            if (!victim || victim == this || victim.hasAuraType(AuraType.NoPvpCredit)) {
                return false;
            }

            victimGuid = victim.getGUID();
            var plrVictim = victim.toPlayer();

            if (plrVictim) {
                if (getEffectiveTeam() == plrVictim.getEffectiveTeam() && !global.getWorldMgr().isFFAPvPRealm()) {
                    return false;
                }

                var kLevel = (byte) getLevel();
                var kGrey = (byte) Formulas.getGrayLevel(kLevel);
                var vLevel = (byte) victim.getLevelForTarget(this);

                if (vLevel <= kGrey) {
                    return false;
                }

                // PLAYER_CHOSEN_TITLE VALUES DESCRIPTION
                //  [0]      Just name
                //  [1..14]  Alliance honor titles and player name
                //  [15..28] Horde honor titles and player name
                //  [29..38] Other title and player name
                //  [39+]    Nothing
                // this is all wrong, should be going off pvpTitle, not PlayerTitle
                int victimTitle = plrVictim.getPlayerData().playerTitle;

                // Get Killer titles, CharTitlesEntry.bit_index
                // Ranks:
                //  title[1..14]  . rank[5..18]
                //  title[15..28] . rank[5..18]
                //  title[other]  . 0
                if (victimTitle == 0) {
                    victimGuid.clear(); // Don't show HK: <rank> message, only log.
                } else if (victimTitle < 15) {
                    victim_rank = victimTitle + 4;
                } else if (victimTitle < 29) {
                    victim_rank = victimTitle - 14 + 4;
                } else {
                    victimGuid.clear(); // Don't show HK: <rank> message, only log.
                }

                honorF = (float) Math.ceil(Formulas.HKHonorAtLevelF(kLevel) * (vLevel - kGrey) / (kLevel - kGrey));

                // count the number of playerkills in one day
                applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().todayHonorableKills), (short) 1, true);
                // and those in a lifetime
                applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().lifetimeHonorableKills), 1, true);
                updateCriteria(CriteriaType.honorableKills);
                updateCriteria(CriteriaType.DeliverKillingBlowToClass, (int) victim.getClass().getValue());
                updateCriteria(CriteriaType.DeliverKillingBlowToRace, (int) victim.getRace().getValue());
                updateCriteria(CriteriaType.PVPKillInArea, getArea());
                updateCriteria(CriteriaType.EarnHonorableKill, 1, 0, 0, victim);
                updateCriteria(CriteriaType.KillPlayer, 1, 0, 0, victim);
            } else {
                if (!victim.toCreature().isRacialLeader()) {
                    return false;
                }

                honorF = 100.0f; // ??? need more info
                victim_rank = 19; // HK: Leader
            }
        }

        if (victim != null) {
            if (groupsize > 1) {
                honorF /= groupsize;
            }

            // apply honor multiplier from aura (not stacking-get highest)
            tangible.RefObject<Float> tempRef_honorF = new tangible.RefObject<Float>(honorF);
            MathUtil.AddPct(tempRef_honorF, getMaxPositiveAuraModifier(AuraType.ModHonorGainPct));
            honorF = tempRef_honorF.refArgValue;
            honorF += (float) restMgr.getRestBonusFor(RestTypes.honor, (int) honorF);
        }

        honorF *= WorldConfig.getFloatValue(WorldCfg.RateHonor);
        // Back to int now
        honor = (int) honorF;
        // honor - for show honor points in log
        // victim_guid - for show victim name in log
        // victim_rank [1..4]  HK: <dishonored rank>
        // victim_rank [5..19] HK: <alliance\horde rank>
        // victim_rank [0, 20+] HK: <>
        PvPCredit data = new PvPCredit();
        data.honor = honor;
        data.originalHonor = honor;
        data.target = victimGuid;
        data.rank = victim_rank;

        sendPacket(data);

        addHonorXp(honor);

        if (getInBattleground() && honor > 0) {
            var bg = getBattleground();

            if (bg != null) {
                bg.updatePlayerScore(this, ScoreType.bonusHonor, (int) honor, false); //false: prevent looping
            }
        }

        if (WorldConfig.getBoolValue(WorldCfg.PvpTokenEnable) && pvptoken) {
            if (victim != null && (!victim || victim == this || victim.hasAuraType(AuraType.NoPvpCredit))) {
                return true;
            }

            if (victim != null && victim.isTypeId(TypeId.PLAYER)) {
                // Check if allowed to receive it in current map
                var mapType = WorldConfig.getIntValue(WorldCfg.PvpTokenMapType);

                if ((mapType == 1 && !getInBattleground() && !isFFAPvP()) || (mapType == 2 && !isFFAPvP()) || (mapType == 3 && !getInBattleground())) {
                    return true;
                }

                var itemId = WorldConfig.getUIntValue(WorldCfg.PvpTokenId);
                var count = WorldConfig.getUIntValue(WorldCfg.PvpTokenCount);

                if (addItem(itemId, count)) {
                    sendSysMessage("You have been awarded a token for slaying another player.");
                }
            }
        }

        return true;
    }

    public final void resetHonorStats() {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().todayHonorableKills), (short) 0);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().yesterdayHonorableKills), (short) 0);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().lifetimeHonorableKills), 0);
    }

    public final void addHonorXp(int xp) {
        int currentHonorXp = getActivePlayerData().honor;
        int nextHonorLevelXp = getActivePlayerData().honorNextLevel;
        var newHonorXp = currentHonorXp + xp;
        var honorLevel = getHonorLevel();

        if (xp < 1 || getLevel() < PlayerConst.LevelMinHonor || isMaxHonorLevel()) {
            return;
        }

        while (newHonorXp >= nextHonorLevelXp) {
            newHonorXp -= nextHonorLevelXp;

            if (honorLevel < PlayerConst.MaxHonorLevel) {
                setHonorLevel((byte) (honorLevel + 1));
            }

            honorLevel = getHonorLevel();
            nextHonorLevelXp = getActivePlayerData().honorNextLevel;
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().honor), isMaxHonorLevel() ? 0 : newHonorXp);
    }

    public final void activatePvpItemLevels(boolean activate) {
        usePvpItemLevels = activate;
    }

    public final void enablePvpRules() {
        enablePvpRules(false);
    }

    public final void enablePvpRules(boolean dueToCombat) {
        if (hasPvpRulesEnabled()) {
            return;
        }

        if (!hasSpell(195710)) // Honorable Medallion
        {
            castSpell(this, 208682); // Learn Gladiator's Medallion
        }

        castSpell(this, PlayerConst.SpellPvpRulesEnabled);

        if (!dueToCombat) {
            var aura = getAura(PlayerConst.SpellPvpRulesEnabled);

            if (aura != null) {
                aura.setMaxDuration(-1);
                aura.setDuration(-1);
            }
        }

        updateItemLevelAreaBasedScaling();
    }

    public final int[] getPvpTalentMap(byte spec) {
        return specializationInfo.getPvpTalents()[spec];
    }

    public final boolean inBattlegroundQueue() {
        return inBattlegroundQueue(false);
    }

    public final boolean inBattlegroundQueue(boolean ignoreArena) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opNotEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), null) && (!ignoreArena || _battlegroundQueueIdRecs[i].getBgQueueTypeId().battlemasterListId != (short) getBattlegroundTypeId().AA.getValue())) {
                return true;
            }
        }

        return false;
    }

    public final BattlegroundQueueTypeId getBattlegroundQueueTypeId(int index) {
        if (index < SharedConst.MaxPlayerBGQueues) {
            return _battlegroundQueueIdRecs[index].getBgQueueTypeId();
        }

        return null;
    }

    public final int getBattlegroundQueueIndex(BattlegroundQueueTypeId bgQueueTypeId) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), bgQueueTypeId)) {
                return i;
            }
        }

        return SharedConst.MaxPlayerBGQueues;
    }

    public final boolean isInvitedForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), bgQueueTypeId)) {
                return _battlegroundQueueIdRecs[i].getInvitedToInstance() != 0;
            }
        }

        return false;
    }

    public final boolean inBattlegroundQueueForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId) {
        return getBattlegroundQueueIndex(bgQueueTypeId) < SharedConst.MaxPlayerBGQueues;
    }

    public final void setBattlegroundId(int val, BattlegroundTypeId bgTypeId) {
        bgData.setBgInstanceId(val);
        bgData.setBgTypeId(bgTypeId);
    }

    public final int addBattlegroundQueueId(BattlegroundQueueTypeId val) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), null) || BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), val)) {
                _battlegroundQueueIdRecs[i].setBgQueueTypeId(val);
                _battlegroundQueueIdRecs[i].setInvitedToInstance(0);
                _battlegroundQueueIdRecs[i].setJoinTime((int) gameTime.GetGameTime());
                _battlegroundQueueIdRecs[i].setMercenary(hasAura(BattlegroundConst.SpellMercenaryContractHorde) || hasAura(BattlegroundConst.SpellMercenaryContractAlliance));

                return i;
            }
        }

        return SharedConst.MaxPlayerBGQueues;
    }

    public final void removeBattlegroundQueueId(BattlegroundQueueTypeId val) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), val)) {
                _battlegroundQueueIdRecs[i].setBgQueueTypeId(null);
                _battlegroundQueueIdRecs[i].setInvitedToInstance(0);
                _battlegroundQueueIdRecs[i].setJoinTime(0);
                _battlegroundQueueIdRecs[i].setMercenary(false);

                return;
            }
        }
    }

    public final void setInviteForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId, int instanceId) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), bgQueueTypeId)) {
                _battlegroundQueueIdRecs[i].setInvitedToInstance(instanceId);
            }
        }
    }

    public final boolean isInvitedForBattlegroundInstance(int instanceId) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (_battlegroundQueueIdRecs[i].getInvitedToInstance() == instanceId) {
                return true;
            }
        }

        return false;
    }

    public final boolean isMercenaryForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), bgQueueTypeId)) {
                return _battlegroundQueueIdRecs[i].getMercenary();
            }
        }

        return false;
    }

    public final int getBattlegroundQueueJoinTime(BattlegroundQueueTypeId bgQueueTypeId) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), bgQueueTypeId)) {
                return _battlegroundQueueIdRecs[i].getJoinTime();
            }
        }

        return 0;
    }

    public final boolean canUseBattlegroundObject(GameObject gameobject) {
        // It is possible to call this method with a null pointer, only skipping faction check.
        if (gameobject) {
            var playerFaction = getFactionTemplateEntry();
            var faction = CliDB.FactionTemplateStorage.get(gameobject.getFaction());

            if (playerFaction != null && faction != null && !playerFaction.isFriendlyTo(faction)) {
                return false;
            }
        }

        // BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
        // Note: mount, stealth and invisibility will be removed when used
        return (!isTotalImmune() && !hasAura(BattlegroundConst.SpellRecentlyDroppedFlag) && isAlive()); // Alive
    }

    public final void setBattlegroundEntryPoint() {
        // Taxi path store
        if (!getTaxi().isEmpty()) {
            bgData.setMountSpell(0);
            bgData.getTaxiPath()[0] = getTaxi().getTaxiSource();
            bgData.getTaxiPath()[1] = getTaxi().getTaxiDestination();

            // On taxi we don't need check for dungeon
            bgData.setJoinPos(new worldLocation(getLocation().getMapId(), getLocation().getX(), getLocation().getY(), getLocation().getZ(), getLocation().getO()));
        } else {
            bgData.clearTaxiPath();

            // Mount spell id storing
            if (isMounted()) {
                var auras = getAuraEffectsByType(AuraType.Mounted);

                if (!auras.isEmpty()) {
                    bgData.setMountSpell(auras.get(0).getId());
                }
            } else {
                bgData.setMountSpell(0);
            }

            // If map is dungeon find linked graveyard
            if (getMap().isDungeon()) {
                var entry = global.getObjectMgr().getClosestGraveYard(getLocation(), getTeam(), this);

                if (entry != null) {
                    bgData.setJoinPos(entry.loc);
                } else {
                    Log.outError(LogFilter.player, "SetBattlegroundEntryPoint: Dungeon map {0} has no linked graveyard, setting home location as entry point.", getLocation().getMapId());
                }
            }
            // If new entry point is not BG or arena set it
            else if (!getMap().isBattlegroundOrArena()) {
                bgData.setJoinPos(new worldLocation(getLocation().getMapId(), getLocation().getX(), getLocation().getY(), getLocation().getZ(), getLocation().getO()));
            }
        }

        if (bgData.getJoinPos().getMapId() == 0xFFFFFFFF) // In error cases use homebind position
        {
            bgData.setJoinPos(new worldLocation(getHomeBind()));
        }
    }

    public final Team getBgTeam() {
        return bgData.getBgTeam() != 0 ? Team.forValue(bgData.getBgTeam()) : getTeam();
    }

    public final void setBgTeam(Team team) {
        bgData.setBgTeam((int) team.getValue());
        setArenaFaction((byte) (team == Team.ALLIANCE ? 1 : 0));
    }

    public final void leaveBattleground() {
        leaveBattleground(true);
    }

    public final void leaveBattleground(boolean teleportToEntryPoint) {
        var bg = getBattleground();

        if (bg) {
            bg.removePlayerAtLeave(getGUID(), teleportToEntryPoint, true);

            // call after remove to be sure that player resurrected for correct cast
            if (bg.isBattleground() && !isGameMaster() && WorldConfig.getBoolValue(WorldCfg.BattlegroundCastDeserter)) {
                if (bg.getStatus() == BattlegroundStatus.inProgress || bg.getStatus() == BattlegroundStatus.WaitJoin) {
                    //lets check if player was teleported from BG and schedule delayed Deserter spell cast
                    if (isBeingTeleportedFar()) {
                        scheduleDelayedOperation(PlayerDelayedOperations.SpellCastDeserter);

                        return;
                    }

                    castSpell(this, 26013, true); // Deserter
                }
            }
        }
    }

    public final boolean isDeserter() {
        return hasAura(26013);
    }

    public final boolean canJoinToBattleground(Battleground bg) {
        var perm = RBACPermissions.JoinNormalBg;

        if (bg.isArena()) {
            perm = RBACPermissions.JoinArenas;
        } else if (bg.isRandom()) {
            perm = RBACPermissions.JoinRandomBg;
        }

        return getSession().hasPermission(perm);
    }

    public final void clearAfkReports() {
        bgData.getBgAfkReporter().clear();
    }

    /**
     * This player has been blamed to be inactive in a Battleground
     *
     * @param reporter
     */
    public final void reportedAfkBy(Player reporter) {
        ReportPvPPlayerAFKResult reportAfkResult = new ReportPvPPlayerAFKResult();
        reportAfkResult.offender = getGUID();
        var bg = getBattleground();

        // Battleground also must be in progress!
        if (!bg || bg != reporter.getBattleground() || getEffectiveTeam() != reporter.getEffectiveTeam() || bg.getStatus() != BattlegroundStatus.inProgress) {
            reporter.sendPacket(reportAfkResult);

            return;
        }

        // check if player has 'Idle' or 'Inactive' debuff
        if (!bgData.getBgAfkReporter().contains(reporter.getGUID()) && !hasAura(43680) && !hasAura(43681) && reporter.canReportAfkDueToLimit()) {
            bgData.getBgAfkReporter().add(reporter.getGUID());

            // by default 3 players have to complain to apply debuff
            if (bgData.getBgAfkReporter().size() >= WorldConfig.getIntValue(WorldCfg.BattlegroundReportAfk)) {
                // cast 'Idle' spell
                castSpell(this, 43680, true);
                bgData.getBgAfkReporter().clear();
                reportAfkResult.numBlackMarksOnOffender = (byte) bgData.getBgAfkReporter().size();
                reportAfkResult.numPlayersIHaveReported = reporter.bgData.getBgAfkReportedCount();
                reportAfkResult.result = ReportPvPPlayerAFKResult.resultCode.success;
            }
        }

        reporter.sendPacket(reportAfkResult);
    }

    public final boolean getRandomWinner() {
        return isBgRandomWinner;
    }

    public final void setRandomWinner(boolean isWinner) {
        isBgRandomWinner = isWinner;

        if (isBgRandomWinner) {
            var stmt = DB.characters.GetPreparedStatement(CharStatements.INS_BATTLEGROUND_RANDOM);
            stmt.AddValue(0, getGUID().getCounter());
            DB.characters.execute(stmt);
        }
    }

    public final boolean getBgAccessByLevel(BattlegroundTypeId bgTypeId) {
        // get a template bg instead of running one
        var bg = global.getBattlegroundMgr().getBattlegroundTemplate(bgTypeId);

        if (!bg) {
            return false;
        }

        // limit check leel to dbc compatible level range
        var level = getLevel();

        if (level > WorldConfig.getIntValue(WorldCfg.MaxPlayerLevel)) {
            level = WorldConfig.getUIntValue(WorldCfg.MaxPlayerLevel);
        }

        return level >= bg.getMinLevel() && level <= bg.getMaxLevel();
    }

    public final void sendPvpRewards() {
        //WorldPacket packet(SMSG_REQUEST_PVP_REWARDS_RESPONSE, 24);
        //SendPacket(packet);
    }

    //Arenas
    public final void setArenaTeamInfoField(byte slot, ArenaTeamInfoType type, int value) {
    }

    public final void setInArenaTeam(int arenaTeamId, byte slot, byte type) {
        setArenaTeamInfoField(slot, ArenaTeamInfoType.id, arenaTeamId);
        setArenaTeamInfoField(slot, ArenaTeamInfoType.type, type);
    }

    public final int getArenaTeamId(byte slot) {
        return 0;
    }

    public final int getArenaTeamIdInvited() {
        return arenaTeamIdInvited;
    }

    public final void setArenaTeamIdInvited(int arenaTeamId) {
        arenaTeamIdInvited = arenaTeamId;
    }

    public final int getRbgPersonalRating() {
        return getArenaPersonalRating((byte) 3);
    }

    public final int getArenaPersonalRating(byte slot) {
        var pvpInfo = getPvpInfoForBracket(slot);

        if (pvpInfo != null) {
            return pvpInfo.rating;
        }

        return 0;
    }

    public final PVPInfo getPvpInfoForBracket(byte bracket) {
        var index = getActivePlayerData().pvpInfo.FindIndexIf(pvpInfo ->
        {
            return pvpInfo.bracket == bracket && !pvpInfo.disqualified;
        });

        if (index >= 0) {
            return getActivePlayerData().pvpInfo.get(index);
        }

        return null;
    }

    //OutdoorPVP
    public final boolean isOutdoorPvPActive() {
        return isAlive() && !getHasInvisibilityAura() && !getHasStealthAura() && isPvP() && !hasUnitMovementFlag(MovementFlag.Flying) && !isInFlight();
    }

    public final OutdoorPvP getOutdoorPvP() {
        return global.getOutdoorPvPMgr().getOutdoorPvPToZoneId(getMap(), getZone());
    }

    private void _InitHonorLevelOnLoadFromDB(int honor, int honorLevel) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().honorLevel), honorLevel);
        updateHonorNextLevel();

        addHonorXp(honor);
    }

    private void rewardPlayerWithRewardPack(int rewardPackId) {
        rewardPlayerWithRewardPack(CliDB.RewardPackStorage.get(rewardPackId));
    }

    private void rewardPlayerWithRewardPack(RewardPackRecord rewardPackEntry) {
        if (rewardPackEntry == null) {
            return;
        }

        var charTitlesEntry = CliDB.CharTitlesStorage.get(rewardPackEntry.CharTitleID);

        if (charTitlesEntry != null) {
            setTitle(charTitlesEntry);
        }

        modifyMoney(rewardPackEntry.money);

        var rewardCurrencyTypes = global.getDB2Mgr().GetRewardPackCurrencyTypesByRewardID(rewardPackEntry.id);

        for (var currency : rewardCurrencyTypes) {
            addCurrency(currency.CurrencyTypeID, (int) currency.quantity);
        }

        var rewardPackXItems = global.getDB2Mgr().GetRewardPackItemsByRewardID(rewardPackEntry.id);

        for (var rewardPackXItem : rewardPackXItems) {
            addItem(rewardPackXItem.itemID, rewardPackXItem.itemQuantity);
        }
    }

    private void updateHonorNextLevel() {
        // 5500 at honor level 1
        // no idea what between here
        // 8800 at honor level ~14 (never goes above 8800)
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().honorNextLevel), 8800);
    }

    private void disablePvpRules() {
        // Don't disable pvp rules when in pvp zone.
        if (isInAreaThatActivatesPvpTalents()) {
            return;
        }

        if (!getCombatManager().hasPvPCombat()) {
            removeAura(PlayerConst.SpellPvpRulesEnabled);
            updateItemLevelAreaBasedScaling();
        } else {
            var aura = getAura(PlayerConst.SpellPvpRulesEnabled);

            if (aura != null) {
                aura.setDuration(aura.getSpellInfo().getMaxDuration());
            }
        }
    }

    private boolean hasPvpRulesEnabled() {
        return hasAura(PlayerConst.SpellPvpRulesEnabled);
    }

    private boolean isInAreaThatActivatesPvpTalents() {
        return isAreaThatActivatesPvpTalents(getArea());
    }


    private boolean isAreaThatActivatesPvpTalents(int areaId) {
        if (getInBattleground()) {
            return true;
        }

        var area = CliDB.AreaTableStorage.get(areaId);

        if (area != null) {
            do {
                if (area.IsSanctuary()) {
                    return false;
                }

                if (area.hasFlag(AreaFlags.Arena)) {
                    return true;
                }

                if (global.getBattleFieldMgr().isWorldPvpArea(area.id)) {
                    return true;
                }

                area = CliDB.AreaTableStorage.get(area.ParentAreaID);
            } while (area != null);
        }

        return false;
    }

    private void setMercenaryForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId, boolean mercenary) {
        for (byte i = 0; i < SharedConst.MaxPlayerBGQueues; ++i) {
            if (BattlegroundQueueTypeId.opEquals(_battlegroundQueueIdRecs[i].getBgQueueTypeId(), bgQueueTypeId)) {
                _battlegroundQueueIdRecs[i].setMercenary(mercenary);
            }
        }
    }

    private boolean canReportAfkDueToLimit() {
        // a player can complain about 15 people per 5 minutes
        if (bgData.getBgAfkReportedCount() >= 15) {
            bgData.setBgAfkReportedCount((byte) (bgData.getBgAfkReportedCount() + 1));
            return false;
        } else {
            bgData.setBgAfkReportedCount((byte) (bgData.getBgAfkReportedCount() + 1));
        }

        return true;
    }


    public final int getSharedQuestID() {
        return sharedQuestId;
    }

    public final ObjectGuid getPlayerSharingQuest() {
        return playerSharingQuest;
    }


    public final void setQuestSharingInfo(ObjectGuid guid, int id) {
        playerSharingQuest = guid;
        sharedQuestId = id;
    }

    public final void clearQuestSharingInfo() {
        playerSharingQuest = ObjectGuid.Empty;
        sharedQuestId = 0;
    }

    public final void removeTimedQuest(int questId) {
        timedquests.remove((Integer) questId);
    }

    public final ArrayList<Integer> getRewardedQuests() {
        return rewardedQuests;
    }

    public final int getQuestMinLevel(Quest quest) {
        return getQuestMinLevel(quest.contentTuningId);
    }

    public final int getQuestLevel(Quest quest) {
        if (quest == null) {
            return 0;
        }

        return getQuestLevel(quest.contentTuningId);
    }

    public final int getQuestLevel(int contentTuningId) {
        var questLevels = global.getDB2Mgr().GetContentTuningData(contentTuningId, getPlayerData().ctrOptions.getValue().contentTuningConditionMask);

        if (questLevels != null) {
            var minLevel = getQuestMinLevel(contentTuningId);
            int maxLevel = questLevels.getValue().maxLevel;
            var level = getLevel();

            if (level >= minLevel) {
                return Math.min(level, maxLevel);
            }

            return minLevel;
        }

        return 0;
    }

    public final int getRewardedQuestCount() {
        return rewardedQuests.size();
    }

    public final void learnQuestRewardedSpells(Quest quest) {
        //wtf why is rewardspell a uint if it can me -1
        var spell_id = quest.getRewardSpell();
        var src_spell_id = quest.getSourceSpellID();

        // skip quests without rewarded spell
        if (spell_id == 0) {
            return;
        }

        // if RewSpellCast = -1 we remove aura do to SrcSpell from player.
        if (spell_id == -1 && src_spell_id != 0) {
            removeAura(src_spell_id);

            return;
        }

        var spellInfo = global.getSpellMgr().getSpellInfo((int) spell_id, Difficulty.NONE);

        if (spellInfo == null) {
            return;
        }

        // check learned spells state
        var found = false;

        for (var spellEffectInfo : spellInfo.getEffects()) {
            if (spellEffectInfo.isEffect(SpellEffectName.LearnSpell) && !hasSpell(spellEffectInfo.triggerSpell)) {
                found = true;

                break;
            }
        }

        // skip quests with not teaching spell or already known spell
        if (!found) {
            return;
        }

        var effect = spellInfo.getEffect(0);
        var learned_0 = effect.triggerSpell;

        if (!hasSpell(learned_0)) {
            found = false;
            var skills = global.getSpellMgr().getSkillLineAbilityMapBounds(learned_0);

            for (var skillLine : skills) {
                if (skillLine.AcquireMethod == AbilityLearnType.RewardedFromQuest) {
                    found = true;

                    break;
                }
            }

            // profession specialization can be re-learned from npc
            if (!found) {
                return;
            }
        }

        castSpell(this, spell_id, true);
    }

    public final void learnQuestRewardedSpells() {
        // learn spells received from quest completing
        for (var questId : rewardedQuests) {
            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (quest == null) {
                continue;
            }

            learnQuestRewardedSpells(quest);
        }
    }

    public final void dailyReset() {
        for (var questId : getActivePlayerData().dailyQuestsCompleted) {
            var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(questId);

            if (questBit != 0) {
                setQuestCompletedBit(questBit, false);
            }
        }

        DailyQuestsReset dailyQuestsReset = new DailyQuestsReset();
        dailyQuestsReset.count = getActivePlayerData().dailyQuestsCompleted.size();
        sendPacket(dailyQuestsReset);

        clearDynamicUpdateFieldValues(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().dailyQuestsCompleted));

        dfQuests.clear(); // Dungeon Finder Quests.

        // DB data deleted in caller
        dailyQuestChanged = false;
        lastDailyQuestTime = 0;

        if (garrison != null) {
            garrison.resetFollowerActivationLimit();
        }
    }

    public final void resetWeeklyQuestStatus() {
        if (weeklyquests.isEmpty()) {
            return;
        }

        for (var questId : weeklyquests) {
            var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(questId);

            if (questBit != 0) {
                setQuestCompletedBit(questBit, false);
            }
        }

        weeklyquests.clear();
        // DB data deleted in caller
        weeklyQuestChanged = false;
    }

    public final void resetSeasonalQuestStatus(short event_id, long eventStartTime) {
        // DB data deleted in caller
        seasonalQuestChanged = false;

        var eventList = seasonalquests.get(event_id);

        if (eventList == null) {
            return;
        }

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
        for (var(questId, completedTime) : eventList.ToList()) {
            if (completedTime < eventStartTime) {
                var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(questId);

                if (questBit != 0) {
                    setQuestCompletedBit(questBit, false);
                }

                eventList.remove(questId);
            }
        }

        if (eventList.isEmpty()) {
            seasonalquests.remove(event_id);
        }
    }

    public final void resetMonthlyQuestStatus() {
        if (monthlyquests.isEmpty()) {
            return;
        }

        for (var questId : monthlyquests) {
            var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(questId);

            if (questBit != 0) {
                setQuestCompletedBit(questBit, false);
            }
        }

        monthlyquests.clear();
        // DB data deleted in caller
        monthlyQuestChanged = false;
    }

    public final boolean canInteractWithQuestGiver(WorldObject questGiver) {
        switch (questGiver.getTypeId()) {
            case Unit:
                return getNPCIfCanInteractWith(questGiver.getGUID(), NPCFlags.questGiver, NPCFlags2.NONE) != null;
            case GameObject:
                return getGameObjectIfCanInteractWith(questGiver.getGUID(), GameObjectTypes.questGiver) != null;
            case Player:
                return isAlive() && questGiver.toPlayer().isAlive();
            case Item:
                return isAlive();
            default:
                break;
        }

        return false;
    }

    public final boolean isQuestRewarded(int quest_id) {
        return rewardedQuests.contains(quest_id);
    }

    public final void prepareQuestMenu(ObjectGuid guid) {
        QuestRelationResult questRelations;
        QuestRelationResult questInvolvedRelations;

        // pets also can have quests
        var creature = ObjectAccessor.GetCreatureOrPetOrVehicle(this, guid);

        if (creature != null) {
            questRelations = global.getObjectMgr().getCreatureQuestRelations(creature.getEntry());
            questInvolvedRelations = global.getObjectMgr().getCreatureQuestInvolvedRelations(creature.getEntry());
        } else {
            //we should obtain map from getMap() in 99% of cases. Special case
            //only for quests which cast teleport spells on player
            var map = isInWorld() ? getMap() : global.getMapMgr().findMap(getLocation().getMapId(), getInstanceId());

            var gameObject = map.getGameObject(guid);

            if (gameObject != null) {
                questRelations = global.getObjectMgr().getGOQuestRelations(gameObject.getEntry());
                questInvolvedRelations = global.getObjectMgr().getGOQuestInvolvedRelations(gameObject.getEntry());
            } else {
                return;
            }
        }

        var qm = getPlayerTalkClass().getQuestMenu();
        qm.clearMenu();

        for (var questId : questInvolvedRelations) {
            var status = getQuestStatus(questId);

            if (status == QuestStatus.Complete) {
                qm.addMenuItem(questId, (byte) 4);
            } else if (status == QuestStatus.INCOMPLETE) {
                qm.addMenuItem(questId, (byte) 4);
            }
        }

        for (var questId : questRelations) {
            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (quest == null) {
                continue;
            }

            if (!canTakeQuest(quest, false)) {
                continue;
            }

            if (quest.isAutoComplete() && (!quest.isRepeatable() || quest.isDaily() || quest.isWeekly() || quest.isMonthly())) {
                qm.addMenuItem(questId, (byte) 0);
            } else if (quest.isAutoComplete()) {
                qm.addMenuItem(questId, (byte) 4);
            } else if (getQuestStatus(questId) == QuestStatus.NONE) {
                qm.addMenuItem(questId, (byte) 2);
            }
        }
    }

    public final void sendPreparedQuest(WorldObject source) {
        var questMenu = getPlayerTalkClass().getQuestMenu();

        if (questMenu.isEmpty()) {
            return;
        }

        // single element case
        if (questMenu.getMenuItemCount() == 1) {
            var qmi0 = questMenu.getItem(0);
            var questId = qmi0.questId;

            // Auto open
            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (quest != null) {
                if (qmi0.questIcon == 4) {
                    getPlayerTalkClass().sendQuestGiverRequestItems(quest, source.getGUID(), canRewardQuest(quest, false), true);
                }

                // Send completable on repeatable and autoCompletable quest if player don't have quest
                // @todo verify if check for !quest.IsDaily() is really correct (possibly not)
                else if (!source.hasQuest(questId) && !source.hasInvolvedQuest(questId)) {
                    getPlayerTalkClass().sendCloseGossip();
                } else {
                    if (quest.isAutoAccept() && canAddQuest(quest, true) && canTakeQuest(quest, true)) {
                        addQuestAndCheckCompletion(quest, source);
                    }

                    if (quest.isAutoComplete() && quest.isRepeatable() && !quest.isDailyOrWeekly() && !quest.isMonthly()) {
                        getPlayerTalkClass().sendQuestGiverRequestItems(quest, source.getGUID(), canCompleteRepeatableQuest(quest), true);
                    } else if (quest.isAutoComplete() && !quest.isDailyOrWeekly() && !quest.isMonthly()) {
                        getPlayerTalkClass().sendQuestGiverRequestItems(quest, source.getGUID(), canRewardQuest(quest, false), true);
                    } else {
                        getPlayerTalkClass().sendQuestGiverQuestDetails(quest, source.getGUID(), true, false);
                    }
                }

                return;
            }
        }

        getPlayerTalkClass().sendQuestGiverQuestListMessage(source);
    }

    public final boolean isActiveQuest(int quest_id) {
        return mQuestStatus.containsKey(quest_id);
    }

    public final Quest getNextQuest(ObjectGuid guid, Quest quest) {
        QuestRelationResult quests;
        var nextQuestID = quest.getNextQuestInChain();

        switch (guid.getHigh()) {
            case Player:
                return global.getObjectMgr().getQuestTemplate(nextQuestID);
            case Creature:
            case Pet:
            case Vehicle: {
                var creature = ObjectAccessor.GetCreatureOrPetOrVehicle(this, guid);

                if (creature != null) {
                    quests = global.getObjectMgr().getCreatureQuestRelations(creature.getEntry());
                } else {
                    return null;
                }

                break;
            }
            case GameObject: {
                //we should obtain map from getMap() in 99% of cases. Special case
                //only for quests which cast teleport spells on player
                var map = isInWorld() ? getMap() : global.getMapMgr().findMap(getLocation().getMapId(), getInstanceId());

                var gameObject = map.getGameObject(guid);

                if (gameObject != null) {
                    quests = global.getObjectMgr().getGOQuestRelations(gameObject.getEntry());
                } else {
                    return null;
                }

                break;
            }
            default:
                return null;
        }

        if (nextQuestID != 0) {
            if (quests.hasQuest(nextQuestID)) {
                return global.getObjectMgr().getQuestTemplate(nextQuestID);
            }
        }

        return null;
    }

    public final boolean canSeeStartQuest(Quest quest) {
        if (!global.getDisableMgr().isDisabledFor(DisableType.Quest, quest.id, this) && satisfyQuestClass(quest, false) && satisfyQuestRace(quest, false) && satisfyQuestSkill(quest, false) && satisfyQuestExclusiveGroup(quest, false) && satisfyQuestReputation(quest, false) && satisfyQuestDependentQuests(quest, false) && satisfyQuestDay(quest, false) && satisfyQuestWeek(quest, false) && satisfyQuestMonth(quest, false) && satisfyQuestSeasonal(quest, false)) {
            return getLevel() + WorldConfig.getIntValue(WorldCfg.QuestHighLevelHideDiff) >= getQuestMinLevel(quest);
        }

        return false;
    }

    public final boolean canTakeQuest(Quest quest, boolean msg) {
        return !global.getDisableMgr().isDisabledFor(DisableType.Quest, quest.id, this) && satisfyQuestStatus(quest, msg) && satisfyQuestExclusiveGroup(quest, msg) && satisfyQuestClass(quest, msg) && satisfyQuestRace(quest, msg) && satisfyQuestLevel(quest, msg) && satisfyQuestSkill(quest, msg) && satisfyQuestReputation(quest, msg) && satisfyQuestDependentQuests(quest, msg) && satisfyQuestTimed(quest, msg) && satisfyQuestDay(quest, msg) && satisfyQuestWeek(quest, msg) && satisfyQuestMonth(quest, msg) && satisfyQuestSeasonal(quest, msg) && satisfyQuestConditions(quest, msg);
    }

    public final boolean canAddQuest(Quest quest, boolean msg) {
        if (!satisfyQuestLog(msg)) {
            return false;
        }

        var srcitem = quest.getSourceItemId();

        if (srcitem > 0) {
            var count = quest.getSourceItemIdCount();
            ArrayList<ItemPosCount> dest = new ArrayList<>();
            var msg2 = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, srcitem, count);

            // player already have max number (in most case 1) source item, no additional item needed and quest can be added.
            if (msg2 == InventoryResult.ItemMaxCount) {
                return true;
            }

            if (msg2 != InventoryResult.Ok) {
                sendEquipError(msg2, null, null, srcitem);

                return false;
            }
        }

        return true;
    }

    public final boolean canCompleteQuest(int questId) {
        return canCompleteQuest(questId, 0);
    }

    public final boolean canCompleteQuest(int questId, int ignoredQuestObjectiveId) {
        if (questId != 0) {
            var qInfo = global.getObjectMgr().getQuestTemplate(questId);

            if (qInfo == null) {
                return false;
            }

            if (!qInfo.isRepeatable() && getQuestRewardStatus(questId)) {
                return false; // not allow re-complete quest
            }

            // auto complete quest
            if (qInfo.isAutoComplete() && canTakeQuest(qInfo, false)) {
                return true;
            }

            var q_status = mQuestStatus.get(questId);

            if (q_status == null) {
                return false;
            }

            if (q_status.status == QuestStatus.INCOMPLETE) {
                for (var obj : qInfo.objectives) {
                    if (ignoredQuestObjectiveId != 0 && obj.id == ignoredQuestObjectiveId) {
                        continue;
                    }

                    if (!obj.flags.hasFlag(QuestObjectiveFlags.Optional) && !obj.flags.hasFlag(QuestObjectiveFlags.PartOfProgressBar)) {
                        if (!isQuestObjectiveComplete(q_status.slot, qInfo, obj)) {
                            return false;
                        }
                    }
                }

                if (qInfo.hasSpecialFlag(QuestSpecialFlag.ExplorationOrEvent) && !q_status.explored) {
                    return false;
                }

                return qInfo.limitTime == 0 || q_status.timer != 0;
            }
        }

        return false;
    }

    public final boolean canCompleteRepeatableQuest(Quest quest) {
        // Solve problem that player don't have the quest and try complete it.
        // if repeatable she must be able to complete event if player don't have it.
        // Seem that all repeatable quest are DELIVER Flag so, no need to add more.
        if (!canTakeQuest(quest, false)) {
            return false;
        }

        if (quest.hasQuestObjectiveType(QuestObjectiveType.item)) {
            for (var obj : quest.objectives) {
                if (obj.type == QuestObjectiveType.item && !hasItemCount(obj.objectID, obj.amount)) {
                    return false;
                }
            }
        }

        return canRewardQuest(quest, false);
    }

    public final boolean canRewardQuest(Quest quest, boolean msg) {
        // quest is disabled
        if (global.getDisableMgr().isDisabledFor(DisableType.Quest, quest.id, this)) {
            return false;
        }

        // not auto complete quest and not completed quest (only cheating case, then ignore without message)
        if (!quest.isDFQuest() && !quest.isAutoComplete() && getQuestStatus(quest.id) != QuestStatus.Complete) {
            return false;
        }

        // daily quest can't be rewarded (25 daily quest already completed)
        if (!satisfyQuestDay(quest, msg) || !satisfyQuestWeek(quest, msg) || !satisfyQuestMonth(quest, msg) || !satisfyQuestSeasonal(quest, msg)) {
            return false;
        }

        // player no longer satisfies the quest's requirements (skill level etc.)
        if (!satisfyQuestLevel(quest, msg) || !satisfyQuestSkill(quest, msg) || !satisfyQuestReputation(quest, msg)) {
            return false;
        }

        // rewarded and not repeatable quest (only cheating case, then ignore without message)
        if (getQuestRewardStatus(quest.id)) {
            return false;
        }

        // prevent receive reward with quest items in bank
        if (quest.hasQuestObjectiveType(QuestObjectiveType.item)) {
            for (var obj : quest.objectives) {
                if (obj.type != QuestObjectiveType.item) {
                    continue;
                }

                if (getItemCount(obj.objectID) < obj.amount) {
                    if (msg) {
                        sendEquipError(InventoryResult.ItemNotFound, null, null, (int) obj.objectID);
                    }

                    return false;
                }
            }
        }

        for (var obj : quest.objectives) {
            switch (obj.type) {
                case Currency:
                    if (!hasCurrency(obj.objectID, obj.amount)) {
                        return false;
                    }

                    break;
                case Money:
                    if (!hasEnoughMoney(obj.amount)) {
                        return false;
                    }

                    break;
            }
        }

        return true;
    }

    public final boolean canRewardQuest(Quest quest, LootItemType rewardType, int rewardId, boolean msg) {
        ArrayList<ItemPosCount> dest = new ArrayList<>();

        if (quest.getRewChoiceItemsCount() > 0) {
            switch (rewardType) {
                case Item:
                    for (int i = 0; i < SharedConst.QuestRewardChoicesCount; ++i) {
                        if (quest.RewardChoiceItemId[i] != 0 && quest.RewardChoiceItemType[i] == lootItemType.item && quest.RewardChoiceItemId[i] == rewardId) {
                            var res = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, quest.RewardChoiceItemId[i], quest.RewardChoiceItemCount[i]);

                            if (res != InventoryResult.Ok) {
                                if (msg) {
                                    sendQuestFailed(quest.id, res);
                                }

                                return false;
                            }
                        }
                    }

                    break;
                case Currency:
                    break;
            }
        }

        if (quest.getRewItemsCount() > 0) {
            for (int i = 0; i < quest.getRewItemsCount(); ++i) {
                if (quest.RewardItemId[i] != 0) {
                    var res = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, quest.RewardItemId[i], quest.RewardItemCount[i]);

                    if (res != InventoryResult.Ok) {
                        if (msg) {
                            sendQuestFailed(quest.id, res);
                        }

                        return false;
                    }
                }
            }
        }

        // QuestPackageItem.db2
        if (quest.packageID != 0) {
            var hasFilteredQuestPackageReward = false;
            var questPackageItems = global.getDB2Mgr().GetQuestPackageItems(quest.packageID);

            if (questPackageItems != null) {
                for (var questPackageItem : questPackageItems) {
                    if (questPackageItem.itemID != rewardId) {
                        continue;
                    }

                    if (canSelectQuestPackageItem(questPackageItem)) {
                        hasFilteredQuestPackageReward = true;
                        var res = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, questPackageItem.itemID, questPackageItem.itemQuantity);

                        if (res != InventoryResult.Ok) {
                            sendEquipError(res, null, null, questPackageItem.itemID);

                            return false;
                        }
                    }
                }
            }

            if (!hasFilteredQuestPackageReward) {
                var questPackageItems1 = global.getDB2Mgr().GetQuestPackageItemsFallback(quest.packageID);

                if (questPackageItems1 != null) {
                    for (var questPackageItem : questPackageItems1) {
                        if (questPackageItem.itemID != rewardId) {
                            continue;
                        }

                        var res = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, questPackageItem.itemID, questPackageItem.itemQuantity);

                        if (res != InventoryResult.Ok) {
                            sendEquipError(res, null, null, questPackageItem.itemID);

                            return false;
                        }
                    }
                }
            }
        }

        return true;
    }

    public final void addQuestAndCheckCompletion(Quest quest, WorldObject questGiver) {
        addQuest(quest, questGiver);

        for (var obj : quest.objectives) {
            if (obj.type == QuestObjectiveType.CriteriaTree) {
                if (questObjectiveCriteriaManager.hasCompletedObjective(obj)) {
                    killCreditCriteriaTreeObjective(obj);
                }
            }
        }

        if (canCompleteQuest(quest.id)) {
            completeQuest(quest.id);
        }

        if (!questGiver) {
            return;
        }

        switch (questGiver.getTypeId()) {
            case Unit:
                getPlayerTalkClass().clearMenus();
                questGiver.toCreature().getAI().onQuestAccept(this, quest);

                break;
            case Item:
            case Container:
            case AzeriteItem:
            case AzeriteEmpoweredItem: {
                var item = (item) questGiver;
                global.getScriptMgr().<IItemOnQuestAccept>RunScriptRet(p -> p.onQuestAccept(this, item, quest), item.getScriptId());

                // There are two cases where the source item is not destroyed when the quest is accepted:
                // - It is required to finish the quest, and is an unique item
                // - It is the same item present in the source item field (item that would be given on quest accept)
                var destroyItem = true;

                for (var obj : quest.objectives) {
                    if (obj.type == QuestObjectiveType.item && obj.objectID == item.getEntry() && item.getTemplate().getMaxCount() > 0) {
                        destroyItem = false;

                        break;
                    }
                }

                if (quest.getSourceItemId() == item.getEntry()) {
                    destroyItem = false;
                }

                if (destroyItem) {
                    destroyItem(item.getBagSlot(), item.getSlot(), true);
                }

                break;
            }
            case GameObject:
                getPlayerTalkClass().clearMenus();
                questGiver.toGameObject().getAI().onQuestAccept(this, quest);

                break;
            default:
                break;
        }
    }

    public final void addQuest(Quest quest, WorldObject questGiver) {
        var logSlot = findQuestSlot(0);

        if (logSlot >= SharedConst.MaxQuestLogSize) // Player does not have any free slot in the quest log
        {
            return;
        }

        var questId = quest.id;

        // if not exist then created with set uState == NEW and rewarded=false
        if (!mQuestStatus.containsKey(questId)) {
            mQuestStatus.put(questId, new QuestStatusData());
        }

        var questStatusData = mQuestStatus.get(questId);
        var oldStatus = questStatusData.status;

        // check for repeatable quests status reset
        setQuestSlot(logSlot, questId);
        questStatusData.slot = logSlot;
        questStatusData.status = QuestStatus.INCOMPLETE;
        questStatusData.explored = false;

        for (var obj : quest.objectives) {
            QuestObjectiveStatusData tempVar = new QuestObjectiveStatusData();
            tempVar.questStatusPair = (questId, questStatusData)
            tempVar.objective = obj;
            _questObjectiveStatus.add((obj.type, obj.objectID), tempVar)

            switch (obj.type) {
                case MinReputation:
                case MaxReputation:
                    var factionEntry = CliDB.FactionStorage.get(obj.objectID);

                    if (factionEntry != null) {
                        getReputationMgr().setVisible(factionEntry);
                    }

                    break;
                case CriteriaTree:
                    questObjectiveCriteriaManager.resetCriteriaTree((int) obj.objectID);

                    break;
                default:
                    break;
            }
        }

        giveQuestSourceItem(quest);
        adjustQuestObjectiveProgress(quest);

        long endTime = 0;
        var limittime = quest.limitTime;

        if (limittime != 0) {
            // shared timed quest
            if (questGiver != null && questGiver.isTypeId(TypeId.PLAYER)) {
                limittime = questGiver.toPlayer().mQuestStatus.get(questId).Timer / time.InMilliseconds;
            }

            addTimedQuest(questId);
            questStatusData.timer = limittime * time.InMilliseconds;
            endTime = gameTime.GetGameTime() + limittime;
        } else {
            questStatusData.timer = 0;
        }

        if (quest.hasFlag(QuestFlag.Pvp)) {
            pvpInfo.isHostile = true;
            updatePvPState();
        }

        if (quest.getSourceSpellID() > 0) {
            var spellInfo = global.getSpellMgr().getSpellInfo(quest.getSourceSpellID(), getMap().getDifficultyID());
            Unit caster = this;

            if (questGiver != null && questGiver.isType(TypeMask.unit) && !quest.hasFlag(QuestFlag.PlayerCastOnAccept) && !spellInfo.hasTargetType(targets.UnitCaster) && !spellInfo.hasTargetType(targets.DestCasterSummon)) {
                var unit = questGiver.toUnit();

                if (unit != null) {
                    caster = unit;
                }
            }

            caster.castSpell(this, spellInfo.getId(), (new CastSpellExtraArgs(TriggerCastFlags.FullMask)).setCastDifficulty(spellInfo.getDifficulty()));
        }

        setQuestSlotEndTime(logSlot, endTime);
        setQuestSlotAcceptTime(logSlot, gameTime.GetGameTime());

        questStatusSave.put(questId, QuestSaveType.Default);

        startCriteriaTimer(CriteriaStartEvent.AcceptQuest, questId);

        sendQuestUpdate(questId);

        global.getScriptMgr().<IPlayerOnQuestStatusChange>ForEach(p -> p.OnQuestStatusChange(this, questId));
        global.getScriptMgr().<IQuestOnQuestStatusChange>RunScript(script -> script.OnQuestStatusChange(this, quest, oldStatus, questStatusData.status), quest.getScriptId());
    }

    public final void completeQuest(int quest_id) {
        if (quest_id != 0) {
            setQuestStatus(quest_id, QuestStatus.Complete);

            var questStatus = mQuestStatus.get(quest_id);

            if (questStatus != null) {
                setQuestSlotState(questStatus.slot, QuestSlotStateMask.Complete);
            }

            var qInfo = global.getObjectMgr().getQuestTemplate(quest_id);

            if (qInfo != null) {
                if (qInfo.hasFlag(QuestFlag.Tracking)) {
                    rewardQuest(qInfo, lootItemType.item, 0, this, false);
                }
            }
        }
    }

    public final void incompleteQuest(int quest_id) {
        if (quest_id != 0) {
            setQuestStatus(quest_id, QuestStatus.INCOMPLETE);

            var log_slot = findQuestSlot(quest_id);

            if (log_slot < SharedConst.MaxQuestLogSize) {
                removeQuestSlotState(log_slot, QuestSlotStateMask.Complete);
            }
        }
    }

    public final int getQuestMoneyReward(Quest quest) {
        return (int) (quest.moneyValue(this) * WorldConfig.getFloatValue(WorldCfg.RateMoneyQuest));
    }

    public final int getQuestXPReward(Quest quest) {
        var rewarded = isQuestRewarded(quest.id) && !quest.isDFQuest();

        // Not give XP in case already completed once repeatable quest
        if (rewarded) {
            return 0;
        }

        var XP = (int) (quest.XPValue(this) * WorldConfig.getFloatValue(WorldCfg.RateXpQuest));

        // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
        var ModXPPctAuras = getAuraEffectsByType(AuraType.ModXpQuestPct);

        for (var eff : ModXPPctAuras) {
            tangible.RefObject<Integer> tempRef_XP = new tangible.RefObject<Integer>(XP);
            MathUtil.AddPct(tempRef_XP, eff.getAmount());
            XP = tempRef_XP.refArgValue;
        }

        return XP;
    }

    public final boolean canSelectQuestPackageItem(QuestPackageItemRecord questPackageItem) {
        var rewardProto = global.getObjectMgr().getItemTemplate(questPackageItem.itemID);

        if (rewardProto == null) {
            return false;
        }

        if ((rewardProto.hasFlag(ItemFlags2.FactionAlliance) && getTeam() != Team.ALLIANCE) || (rewardProto.hasFlag(ItemFlags2.FactionHorde) && getTeam() != Team.Horde)) {
            return false;
        }

        switch (questPackageItem.displayType) {
            case LootSpecialization:
                return rewardProto.isUsableByLootSpecialization(this, true);
            case Class:
                return rewardProto.getItemSpecClassMask() == 0 || (rewardProto.getItemSpecClassMask() & getClassMask()) != 0;
            case Everyone:
                return true;
            default:
                break;
        }

        return false;
    }

    public final void rewardQuestPackage(int questPackageId) {
        rewardQuestPackage(questPackageId, 0);
    }

    public final void rewardQuestPackage(int questPackageId, int onlyItemId) {
        var hasFilteredQuestPackageReward = false;
        var questPackageItems = global.getDB2Mgr().GetQuestPackageItems(questPackageId);

        if (questPackageItems != null) {
            for (var questPackageItem : questPackageItems) {
                if (onlyItemId != 0 && questPackageItem.itemID != onlyItemId) {
                    continue;
                }

                if (canSelectQuestPackageItem(questPackageItem)) {
                    hasFilteredQuestPackageReward = true;
                    ArrayList<ItemPosCount> dest = new ArrayList<>();

                    if (canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, questPackageItem.itemID, questPackageItem.itemQuantity) == InventoryResult.Ok) {
                        var item = storeNewItem(dest, questPackageItem.itemID, true, ItemEnchantmentManager.generateItemRandomBonusListId(questPackageItem.itemID));
                        sendNewItem(item, questPackageItem.itemQuantity, true, false);
                    }
                }
            }
        }

        if (!hasFilteredQuestPackageReward) {
            var questPackageItemsFallback = global.getDB2Mgr().GetQuestPackageItemsFallback(questPackageId);

            if (questPackageItemsFallback != null) {
                for (var questPackageItem : questPackageItemsFallback) {
                    if (onlyItemId != 0 && questPackageItem.itemID != onlyItemId) {
                        continue;
                    }

                    ArrayList<ItemPosCount> dest = new ArrayList<>();

                    if (canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, questPackageItem.itemID, questPackageItem.itemQuantity) == InventoryResult.Ok) {
                        var item = storeNewItem(dest, questPackageItem.itemID, true, ItemEnchantmentManager.generateItemRandomBonusListId(questPackageItem.itemID));
                        sendNewItem(item, questPackageItem.itemQuantity, true, false);
                    }
                }
            }
        }
    }

    public final void rewardQuest(Quest quest, LootItemType rewardType, int rewardId, WorldObject questGiver) {
        rewardQuest(quest, rewardType, rewardId, questGiver, true);
    }

    public final void rewardQuest(Quest quest, LootItemType rewardType, int rewardId, WorldObject questGiver, boolean announce) {
        //this THING should be here to protect code from quest, which cast on player far teleport as a reward
        //should work fine, cause far teleport will be executed in update()
        setCanDelayTeleport(true);

        var questId = quest.id;
        var oldStatus = getQuestStatus(questId);

        for (var obj : quest.objectives) {
            switch (obj.type) {
                case Item:
                    destroyItemCount(obj.objectID, obj.amount, true);

                    break;
                case Currency:
                    removeCurrency((int) obj.objectID, obj.amount, CurrencyDestroyReason.QuestTurnin);

                    break;
            }
        }

        if (!quest.flagsEx.hasFlag(questFlagsEx.KeepAdditionalItems)) {
            for (byte i = 0; i < SharedConst.QuestItemDropCount; ++i) {
                if (quest.ItemDrop[i] != 0) {
                    var count = quest.ItemDropQuantity[i];
                    destroyItemCount(quest.ItemDrop[i], count != 0 ? count : 9999, true);
                }
            }
        }

        removeTimedQuest(questId);

        if (quest.getRewItemsCount() > 0) {
            for (int i = 0; i < quest.getRewItemsCount(); ++i) {
                var itemId = quest.RewardItemId[i];

                if (itemId != 0) {
                    ArrayList<ItemPosCount> dest = new ArrayList<>();

                    if (canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, itemId, quest.RewardItemCount[i]) == InventoryResult.Ok) {
                        var item = storeNewItem(dest, itemId, true, ItemEnchantmentManager.generateItemRandomBonusListId(itemId));
                        sendNewItem(item, quest.RewardItemCount[i], true, false);
                    } else if (quest.isDFQuest()) {
                        sendItemRetrievalMail(itemId, quest.RewardItemCount[i], itemContext.QuestReward);
                    }
                }
            }
        }

        var currencyGainSource = CurrencyGainSource.QuestReward;

        if (quest.isDaily()) {
            currencyGainSource = CurrencyGainSource.DailyQuestReward;
        } else if (quest.isWeekly()) {
            currencyGainSource = CurrencyGainSource.WeeklyQuestReward;
        } else if (quest.isWorldQuest()) {
            currencyGainSource = CurrencyGainSource.WorldQuestReward;
        }

        switch (rewardType) {
            case Item:
                var rewardProto = global.getObjectMgr().getItemTemplate(rewardId);

                if (rewardProto != null && quest.getRewChoiceItemsCount() != 0) {
                    for (int i = 0; i < SharedConst.QuestRewardChoicesCount; ++i) {
                        if (quest.RewardChoiceItemId[i] != 0 && quest.RewardChoiceItemType[i] == lootItemType.item && quest.RewardChoiceItemId[i] == rewardId) {
                            ArrayList<ItemPosCount> dest = new ArrayList<>();

                            if (canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, rewardId, quest.RewardChoiceItemCount[i]) == InventoryResult.Ok) {
                                var item = storeNewItem(dest, rewardId, true, ItemEnchantmentManager.generateItemRandomBonusListId(rewardId));
                                sendNewItem(item, quest.RewardChoiceItemCount[i], true, false);
                            }
                        }
                    }
                }


                // QuestPackageItem.db2
                if (rewardProto != null && quest.packageID != 0) {
                    rewardQuestPackage(quest.packageID, rewardId);
                }

                break;
            case Currency:
                if (CliDB.CurrencyTypesStorage.HasRecord(rewardId) && quest.getRewChoiceItemsCount() != 0) {
                    for (int i = 0; i < SharedConst.QuestRewardChoicesCount; ++i) {
                        if (quest.RewardChoiceItemId[i] != 0 && quest.RewardChoiceItemType[i] == lootItemType.currency && quest.RewardChoiceItemId[i] == rewardId) {
                            addCurrency(quest.RewardChoiceItemId[i], quest.RewardChoiceItemCount[i], currencyGainSource);
                        }
                    }
                }

                break;
        }

        for (byte i = 0; i < SharedConst.QuestRewardCurrencyCount; ++i) {
            if (quest.RewardCurrencyId[i] != 0) {
                addCurrency(quest.RewardCurrencyId[i], quest.RewardCurrencyCount[i], currencyGainSource);
            }
        }

        var skill = quest.rewardSkillId;

        if (skill != 0) {
            updateSkillPro(skill, 1000, quest.rewardSkillPoints);
        }

        var log_slot = findQuestSlot(questId);

        if (log_slot < SharedConst.MaxQuestLogSize) {
            setQuestSlot(log_slot, 0);
        }

        var XP = getQuestXPReward(quest);

        var moneyRew = 0;

        if (!isMaxLevel()) {
            giveXP(XP, null);
        } else {
            moneyRew = (int) (quest.getRewMoneyMaxLevel() * WorldConfig.getFloatValue(WorldCfg.RateDropMoney));
        }

        moneyRew += getQuestMoneyReward(quest);

        if (moneyRew != 0) {
            modifyMoney(moneyRew);

            if (moneyRew > 0) {
                updateCriteria(CriteriaType.MoneyEarnedFromQuesting, (int) moneyRew);
            }

            sendDisplayToast(0, DisplayToastType.money, false, (int) moneyRew, displayToastMethod.QuestComplete, questId);
        }

        // honor reward
        var honor = quest.calculateHonorGain(getLevel());

        if (honor != 0) {
            rewardHonor(null, 0, honor);
        }

        // title reward
        if (quest.getRewardTitleId() != 0) {
            var titleEntry = CliDB.CharTitlesStorage.get(quest.getRewardTitleId());

            if (titleEntry != null) {
                setTitle(titleEntry);
            }
        }

        // Send reward mail
        var mail_template_id = quest.getRewardMailTemplateId();

        if (mail_template_id != 0) {
            SQLTransaction trans = new SQLTransaction();
            // @todo Poor design of mail system
            var questMailSender = quest.getRewardMailSenderEntry();

            if (questMailSender != 0) {
                (new MailDraft(mail_template_id)).sendMailTo(trans, this, new MailSender(questMailSender), MailCheckMask.HasBody, quest.getRewardMailDelay());
            } else {
                (new MailDraft(mail_template_id)).sendMailTo(trans, this, new MailSender(questGiver), MailCheckMask.HasBody, quest.getRewardMailDelay());
            }

            DB.characters.CommitTransaction(trans);
        }

        if (quest.isDaily() || quest.isDFQuest()) {
            setDailyQuestStatus(questId);

            if (quest.isDaily()) {
                updateCriteria(CriteriaType.CompleteDailyQuest, questId);
                updateCriteria(CriteriaType.CompleteAnyDailyQuestPerDay, questId);
            }
        } else if (quest.isWeekly()) {
            setWeeklyQuestStatus(questId);
        } else if (quest.isMonthly()) {
            setMonthlyQuestStatus(questId);
        } else if (quest.isSeasonal()) {
            setSeasonalQuestStatus(questId);
        }

        removeActiveQuest(questId, false);

        if (quest.canIncreaseRewardedQuestCounters()) {
            setRewardedQuest(questId);
        }

        sendQuestReward(quest, (questGiver == null ? null : questGiver.toCreature()), XP, !announce);

        rewardReputation(quest);

        // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
        if (quest.getRewardSpell() > 0) {
            var spellInfo = global.getSpellMgr().getSpellInfo(quest.getRewardSpell(), getMap().getDifficultyID());
            Unit caster = this;

            if (questGiver != null && questGiver.isType(TypeMask.unit) && !quest.hasFlag(QuestFlag.PlayerCastOnComplete) && !spellInfo.hasTargetType(targets.UnitCaster)) {
                var unit = questGiver.toUnit();

                if (unit != null) {
                    caster = unit;
                }
            }

            caster.castSpell(this, spellInfo.getId(), (new CastSpellExtraArgs(TriggerCastFlags.FullMask)).setCastDifficulty(spellInfo.getDifficulty()));
        } else {
            for (var displaySpell : quest.rewardDisplaySpell) {
                var playerCondition = CliDB.PlayerConditionStorage.get(displaySpell.playerConditionId);

                if (playerCondition != null) {
                    if (!ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                        continue;
                    }
                }

                var spellInfo = global.getSpellMgr().getSpellInfo(displaySpell.spellId, getMap().getDifficultyID());
                Unit caster = this;

                if (questGiver && questGiver.isType(TypeMask.unit) && !quest.hasFlag(QuestFlag.PlayerCastOnComplete) && !spellInfo.hasTargetType(targets.UnitCaster)) {
                    var unit = questGiver.toUnit();

                    if (unit) {
                        caster = unit;
                    }
                }

                caster.castSpell(this, spellInfo.getId(), (new CastSpellExtraArgs(TriggerCastFlags.FullMask)).setCastDifficulty(spellInfo.getDifficulty()));
            }
        }

        if (quest.questSortID > 0) {
            updateCriteria(CriteriaType.CompleteQuestsInZone, quest.id);
        }

        updateCriteria(CriteriaType.CompleteQuestsCount);
        updateCriteria(CriteriaType.CompleteQuest, quest.id);
        updateCriteria(CriteriaType.CompleteAnyReplayQuest, 1);

        // make full db save
        saveToDB(false);

        var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(questId);

        if (questBit != 0) {
            setQuestCompletedBit(questBit, true);
        }

        if (quest.hasFlag(QuestFlag.Pvp)) {
            pvpInfo.isHostile = pvpInfo.isInHostileArea || hasPvPForcingQuest();
            updatePvPState();
        }

        sendQuestGiverStatusMultiple();

        var conditionChanged = sendQuestUpdate(questId, false);

        //lets remove flag for delayed teleports
        setCanDelayTeleport(false);

        if (questGiver != null) {
            var canHaveNextQuest = quest.hasFlag(QuestFlag.AutoComplete) || !questGiver.isPlayer();

            if (canHaveNextQuest) {
                switch (questGiver.getTypeId()) {
                    case Unit:
                    case Player: {
                        //For AutoSubmition was added plr case there as it almost same exclute AI script cases.
                        // Send next quest
                        var nextQuest = getNextQuest(questGiver.getGUID(), quest);

                        if (nextQuest != null) {
                            // Only send the quest to the player if the conditions are met
                            if (canTakeQuest(nextQuest, false)) {
                                if (nextQuest.isAutoAccept() && canAddQuest(nextQuest, true)) {
                                    addQuestAndCheckCompletion(nextQuest, questGiver);
                                }

                                getPlayerTalkClass().sendQuestGiverQuestDetails(nextQuest, questGiver.getGUID(), true, false);
                            }
                        }

                        getPlayerTalkClass().clearMenus();
                        var creatureQGiver = questGiver.toCreature();

                        if (creatureQGiver != null) {
                            creatureQGiver.getAI().onQuestReward(this, quest, rewardType, rewardId);
                        }

                        break;
                    }
                    case GameObject: {
                        var questGiverGob = questGiver.toGameObject();
                        // Send next quest
                        var nextQuest = getNextQuest(questGiverGob.getGUID(), quest);

                        if (nextQuest != null) {
                            // Only send the quest to the player if the conditions are met
                            if (canTakeQuest(nextQuest, false)) {
                                if (nextQuest.isAutoAccept() && canAddQuest(nextQuest, true)) {
                                    addQuestAndCheckCompletion(nextQuest, questGiver);
                                }

                                getPlayerTalkClass().sendQuestGiverQuestDetails(nextQuest, questGiverGob.getGUID(), true, false);
                            }
                        }

                        getPlayerTalkClass().clearMenus();
                        questGiverGob.getAI().onQuestReward(this, quest, rewardType, rewardId);

                        break;
                    }
                    default:
                        break;
                }
            }
        }

        global.getScriptMgr().<IPlayerOnQuestStatusChange>ForEach(p -> p.OnQuestStatusChange(this, questId));
        global.getScriptMgr().<IQuestOnQuestStatusChange>RunScript(script -> script.OnQuestStatusChange(this, quest, oldStatus, QuestStatus.Rewarded), quest.getScriptId());

        if (conditionChanged) {
            updateObjectVisibility();
        }
    }

    public final void setRewardedQuest(int quest_id) {
        rewardedQuests.add(quest_id);
        rewardedQuestsSave.put(quest_id, QuestSaveType.Default);
    }

    public final void failQuest(int questId) {
        var quest = global.getObjectMgr().getQuestTemplate(questId);

        if (quest != null) {
            var qStatus = getQuestStatus(questId);

            // we can only fail incomplete quest or...
            if (qStatus != QuestStatus.INCOMPLETE) {
                // completed timed quest with no requirements
                if (qStatus != QuestStatus.Complete || quest.limitTime == 0 || !quest.objectives.isEmpty()) {
                    return;
                }
            }

            setQuestStatus(questId, QuestStatus.Failed);

            var log_slot = findQuestSlot(questId);

            if (log_slot < SharedConst.MaxQuestLogSize) {
                setQuestSlotState(log_slot, QuestSlotStateMask.Fail);
            }

            if (quest.limitTime != 0) {
                var q_status = mQuestStatus.get(questId);

                removeTimedQuest(questId);
                q_status.timer = 0;

                sendQuestTimerFailed(questId);
            } else {
                sendQuestFailed(questId);
            }

            // Destroy quest items on quest failure.
            for (var obj : quest.objectives) {
                if (obj.type == QuestObjectiveType.item) {
                    var itemTemplate = global.getObjectMgr().getItemTemplate((int) obj.objectID);

                    if (itemTemplate != null) {
                        if (itemTemplate.getBonding() == ItemBondingType.Quest) {
                            destroyItemCount((int) obj.objectID, (int) obj.amount, true, true);
                        }
                    }
                }
            }

            // Destroy items received during the quest.
            for (byte i = 0; i < SharedConst.QuestItemDropCount; ++i) {
                var itemTemplate = global.getObjectMgr().getItemTemplate(quest.ItemDrop[i]);

                if (itemTemplate != null) {
                    if (quest.ItemDropQuantity[i] != 0 && itemTemplate.getBonding() == ItemBondingType.Quest) {
                        destroyItemCount(quest.ItemDrop[i], quest.ItemDropQuantity[i], true, true);
                    }
                }
            }
        }
    }

    public final void abandonQuest(int questId) {
        var quest = global.getObjectMgr().getQuestTemplate(questId);

        if (quest != null) {
            // Destroy quest items on quest abandon.
            for (var obj : quest.objectives) {
                if (obj.type == QuestObjectiveType.item) {
                    var itemTemplate = global.getObjectMgr().getItemTemplate((int) obj.objectID);

                    if (itemTemplate != null) {
                        if (itemTemplate.getBonding() == ItemBondingType.Quest) {
                            destroyItemCount((int) obj.objectID, (int) obj.amount, true, true);
                        }
                    }
                }
            }

            // Destroy items received during the quest.
            for (byte i = 0; i < SharedConst.QuestItemDropCount; ++i) {
                var itemTemplate = global.getObjectMgr().getItemTemplate(quest.ItemDrop[i]);

                if (itemTemplate != null) {
                    if (quest.ItemDropQuantity[i] != 0 && itemTemplate.getBonding() == ItemBondingType.Quest) {
                        destroyItemCount(quest.ItemDrop[i], quest.ItemDropQuantity[i], true, true);
                    }
                }
            }
        }
    }

    public final boolean satisfyQuestSkill(Quest qInfo, boolean msg) {
        var skill = qInfo.getRequiredSkillId();

        // skip 0 case RequiredSkill
        if (skill == 0) {
            return true;
        }

        // check skill second
        if (getSkillValue(SkillType.forValue(skill)).getValue() < qInfo.getRequiredSkillPoints()) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                Log.outDebug(LogFilter.Server, "SatisfyQuestSkill: Sent QuestFailedReason.NONE (questId: {0}) because player does not have required skill second.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestMinLevel(Quest qInfo, boolean msg) {
        if (getLevel() < getQuestMinLevel(qInfo)) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.FailedLowLevel);
                Log.outDebug(LogFilter.Server, "SatisfyQuestMinLevel: Sent QuestFailedReasons.FailedLowLevel (questId: {0}) because player does not have required (min) level.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestMaxLevel(Quest qInfo, boolean msg) {
        if (qInfo.getMaxLevel() > 0 && getLevel() > qInfo.getMaxLevel()) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE); // There doesn't seem to be a specific response for too high player level
                Log.outDebug(LogFilter.Server, "SatisfyQuestMaxLevel: Sent QuestFailedReasons.NONE (questId: {0}) because player does not have required (max) level.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestLog(boolean msg) {
        // exist free slot
        if (findQuestSlot(0) < SharedConst.MaxQuestLogSize) {
            return true;
        }

        if (msg) {
            sendPacket(new QuestLogFull());
        }

        return false;
    }

    public final boolean satisfyQuestDependentQuests(Quest qInfo, boolean msg) {
        return satisfyQuestPreviousQuest(qInfo, msg) && satisfyQuestDependentPreviousQuests(qInfo, msg) && satisfyQuestBreadcrumbQuest(qInfo, msg) && satisfyQuestDependentBreadcrumbQuests(qInfo, msg);
    }

    public final boolean satisfyQuestPreviousQuest(Quest qInfo, boolean msg) {
        // No previous quest (might be first quest in a series)
        if (qInfo.getPrevQuestId() == 0) {
            return true;
        }

        var prevId = Math.abs(qInfo.getPrevQuestId());

        // If positive previous quest rewarded, return true
        if (qInfo.getPrevQuestId() > 0 && rewardedQuests.contains(prevId)) {
            return true;
        }

        // If negative previous quest active, return true
        if (qInfo.getPrevQuestId() < 0 && getQuestStatus(prevId) == QuestStatus.INCOMPLETE) {
            return true;
        }

        // Has positive prev. quest in non-rewarded state
        // and negative prev. quest in non-active state
        if (msg) {
            sendCanTakeQuestResponse(QuestFailedReasons.NONE);
            Log.outDebug(LogFilter.misc, String.format("Player.SatisfyQuestPreviousQuest: Sent QUEST_ERR_NONE (QuestID: %1$s) because player '%2$s' (%3$s) doesn't have required quest %4$s.", qInfo.id, getName(), getGUID(), prevId));
        }

        return false;
    }

    public final boolean satisfyQuestClass(Quest qInfo, boolean msg) {
        var reqClass = qInfo.getAllowableClasses();

        if (reqClass == 0) {
            return true;
        }

        if ((reqClass & getClassMask()) == 0) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                Log.outDebug(LogFilter.Server, "SatisfyQuestClass: Sent QuestFailedReason.NONE (questId: {0}) because player does not have required class.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestRace(Quest qInfo, boolean msg) {
        var reqraces = qInfo.getAllowableRaces();

        if (reqraces == -1) {
            return true;
        }

        if ((reqraces & (long) SharedConst.GetMaskForRace(getRace())) == 0) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.FailedWrongRace);
                Log.outDebug(LogFilter.Server, "SatisfyQuestRace: Sent QuestFailedReasons.FailedWrongRace (questId: {0}) because player does not have required race.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestReputation(Quest qInfo, boolean msg) {
        var fIdMin = qInfo.getRequiredMinRepFaction(); //Min required rep

        if (fIdMin != 0 && getReputationMgr().getReputation(fIdMin) < qInfo.getRequiredMinRepValue()) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                Log.outDebug(LogFilter.Server, "SatisfyQuestReputation: Sent QuestFailedReason.NONE (questId: {0}) because player does not have required reputation (min).", qInfo.id);
            }

            return false;
        }

        var fIdMax = qInfo.getRequiredMaxRepFaction(); //Max required rep

        if (fIdMax != 0 && getReputationMgr().getReputation(fIdMax) >= qInfo.getRequiredMaxRepValue()) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                Log.outDebug(LogFilter.Server, "SatisfyQuestReputation: Sent QuestFailedReason.NONE (questId: {0}) because player does not have required reputation (max).", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestStatus(Quest qInfo, boolean msg) {
        if (getQuestStatus(qInfo.id) == QuestStatus.Rewarded) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.AlreadyDone);

                Log.outDebug(LogFilter.misc, "Player.SatisfyQuestStatus: Sent QUEST_STATUS_REWARDED (QuestID: {0}) because player '{1}' ({2}) quest status is already REWARDED.", qInfo.id, getName(), getGUID().toString());
            }

            return false;
        }

        if (getQuestStatus(qInfo.id) != QuestStatus.NONE) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.AlreadyOn1);
                Log.outDebug(LogFilter.Server, "SatisfyQuestStatus: Sent QuestFailedReasons.AlreadyOn1 (questId: {0}) because player quest status is not NONE.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestConditions(Quest qInfo, boolean msg) {
        if (!global.getConditionMgr().isObjectMeetingNotGroupedConditions(ConditionSourceType.QuestAvailable, qInfo.id, this)) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                Log.outDebug(LogFilter.Server, "SatisfyQuestConditions: Sent QuestFailedReason.NONE (questId: {0}) because player does not meet conditions.", qInfo.id);
            }

            Log.outDebug(LogFilter.condition, "SatisfyQuestConditions: conditions not met for quest {0}", qInfo.id);

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestTimed(Quest qInfo, boolean msg) {
        if (!timedquests.isEmpty() && qInfo.limitTime != 0) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.OnlyOneTimed);
                Log.outDebug(LogFilter.Server, "SatisfyQuestTimed: Sent QuestFailedReasons.OnlyOneTimed (questId: {0}) because player is already on a timed quest.", qInfo.id);
            }

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestExclusiveGroup(Quest qInfo, boolean msg) {
        // non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
        if (qInfo.getExclusiveGroup() <= 0) {
            return true;
        }

        var range = global.getObjectMgr().getExclusiveQuestGroupBounds(qInfo.getExclusiveGroup());
        // always must be found if qInfo.exclusiveGroup != 0

        for (var exclude_Id : range) {
            // skip checked quest id, only state of other quests in group is interesting
            if (exclude_Id == qInfo.id) {
                continue;
            }

            // not allow have daily quest if daily quest from exclusive group already recently completed
            var Nquest = global.getObjectMgr().getQuestTemplate(exclude_Id);

            if (!satisfyQuestDay(Nquest, false) || !satisfyQuestWeek(Nquest, false) || !satisfyQuestSeasonal(Nquest, false)) {
                if (msg) {
                    sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                    Log.outDebug(LogFilter.Server, "SatisfyQuestExclusiveGroup: Sent QuestFailedReason.NONE (questId: {0}) because player already did daily quests in exclusive group.", qInfo.id);
                }

                return false;
            }

            // alternative quest already started or completed - but don't check rewarded states if both are repeatable
            if (getQuestStatus(exclude_Id) != QuestStatus.NONE || (!(qInfo.isRepeatable() && Nquest.isRepeatable()) && getQuestRewardStatus(exclude_Id))) {
                if (msg) {
                    sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                    Log.outDebug(LogFilter.Server, "SatisfyQuestExclusiveGroup: Sent QuestFailedReason.NONE (questId: {0}) because player already did quest in exclusive group.", qInfo.id);
                }

                return false;
            }
        }

        return true;
    }

    public final boolean satisfyQuestDay(Quest qInfo, boolean msg) {
        if (!qInfo.isDaily() && !qInfo.isDFQuest()) {
            return true;
        }

        if (qInfo.isDFQuest()) {
            return !dfQuests.contains(qInfo.id);
        }

        return getActivePlayerData().dailyQuestsCompleted.FindIndex(qInfo.id) == -1;
    }

    public final boolean satisfyQuestWeek(Quest qInfo, boolean msg) {
        if (!qInfo.isWeekly() || weeklyquests.isEmpty()) {
            return true;
        }

        // if not found in cooldown list
        return !weeklyquests.contains(qInfo.id);
    }

    public final boolean satisfyQuestSeasonal(Quest qInfo, boolean msg) {
        if (!qInfo.isSeasonal() || seasonalquests.isEmpty()) {
            return true;
        }

        var list = seasonalquests.get(qInfo.getEventIdForQuest());

        if (list == null || list.isEmpty()) {
            return true;
        }

        // if not found in cooldown list
        return !list.ContainsKey(qInfo.id);
    }

    public final boolean satisfyQuestExpansion(Quest qInfo, boolean msg) {
        if (getSession().getExpansion().getValue() < qInfo.expansion) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.FailedExpansion);
            }

            Log.outDebug(LogFilter.misc, String.format("Player.SatisfyQuestExpansion: Sent QUEST_ERR_FAILED_EXPANSION (QuestID: %1$s) because player '%2$s' (%3$s) does not have required expansion.", qInfo.id, getName(), getGUID()));

            return false;
        }

        return true;
    }

    public final boolean satisfyQuestMonth(Quest qInfo, boolean msg) {
        if (!qInfo.isMonthly() || monthlyquests.isEmpty()) {
            return true;
        }

        // if not found in cooldown list
        return !monthlyquests.contains(qInfo.id);
    }

    public final boolean giveQuestSourceItem(Quest quest) {
        var srcitem = quest.getSourceItemId();

        if (srcitem > 0) {
            // Don't give source item if it is the same item used to start the quest
            var itemTemplate = global.getObjectMgr().getItemTemplate(srcitem);

            if (quest.id == itemTemplate.getStartQuest()) {
                return true;
            }

            var count = quest.getSourceItemIdCount();

            if (count <= 0) {
                count = 1;
            }

            ArrayList<ItemPosCount> dest = new ArrayList<>();
            var msg = canStoreNewItem(ItemConst.NullBag, ItemConst.NullSlot, dest, srcitem, count);

            if (msg == InventoryResult.Ok) {
                var item = storeNewItem(dest, srcitem, true);
                sendNewItem(item, count, true, false);

                return true;
            }

            // player already have max amount required item, just report success
            if (msg == InventoryResult.ItemMaxCount) {
                return true;
            }

            sendEquipError(msg, null, null, srcitem);

            return false;
        }

        return true;
    }

    public final boolean takeQuestSourceItem(int questId, boolean msg) {
        var quest = global.getObjectMgr().getQuestTemplate(questId);

        if (quest != null) {
            var srcItemId = quest.getSourceItemId();
            var item = global.getObjectMgr().getItemTemplate(srcItemId);

            if (srcItemId > 0) {
                var count = quest.getSourceItemIdCount();

                if (count <= 0) {
                    count = 1;
                }

                // There are two cases where the source item is not destroyed:
                // - Item cannot be unequipped (example: non-empty bags)
                // - The source item is the item that started the quest, so the player is supposed to keep it (otherwise it was already destroyed in addQuestAndCheckCompletion())
                var res = canUnequipItems(srcItemId, count);

                if (res != InventoryResult.Ok) {
                    if (msg) {
                        sendEquipError(res, null, null, srcItemId);
                    }

                    return false;
                }

                if (item.getStartQuest() != questId) {
                    destroyItemCount(srcItemId, count, true, true);
                }
            }
        }

        return true;
    }

    public final boolean getQuestRewardStatus(int quest_id) {
        var qInfo = global.getObjectMgr().getQuestTemplate(quest_id);

        if (qInfo != null) {
            if (qInfo.isSeasonal() && !qInfo.isRepeatable()) {
                return !satisfyQuestSeasonal(qInfo, false);
            }

            // for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
            if (!qInfo.isRepeatable()) {
                return isQuestRewarded(quest_id);
            }

            return false;
        }

        return false;
    }

    public final QuestStatus getQuestStatus(int questId) {
        if (questId != 0) {
            var questStatusData = mQuestStatus.get(questId);

            if (questStatusData != null) {
                return questStatusData.status;
            }

            if (getQuestRewardStatus(questId)) {
                return QuestStatus.REWARDED;
            }
        }

        return QuestStatus.NONE;
    }

    public final boolean canShareQuest(int quest_id) {
        var qInfo = global.getObjectMgr().getQuestTemplate(quest_id);

        if (qInfo != null && qInfo.hasFlag(QuestFlag.Sharable)) {
            var questStatusData = mQuestStatus.get(quest_id);

            return questStatusData != null;
        }

        return false;
    }

    public final void setQuestStatus(int questId, QuestStatus status) {
        setQuestStatus(questId, status, true);
    }

    public final void setQuestStatus(int questId, QuestStatus status, boolean update) {
        var quest = global.getObjectMgr().getQuestTemplate(questId);

        if (quest != null) {
            if (!mQuestStatus.containsKey(questId)) {
                mQuestStatus.put(questId, new QuestStatusData());
            }

            var oldStatus = mQuestStatus.get(questId).status;
            mQuestStatus.get(questId).status = status;

            if (!quest.isAutoComplete()) {
                questStatusSave.put(questId, QuestSaveType.Default);
            }

            global.getScriptMgr().<IPlayerOnQuestStatusChange>ForEach(p -> p.OnQuestStatusChange(this, questId));
            global.getScriptMgr().<IQuestOnQuestStatusChange>RunScript(script -> script.OnQuestStatusChange(this, quest, oldStatus, status), quest.getScriptId());
        }

        if (update) {
            sendQuestUpdate(questId);
        }
    }

    public final void removeActiveQuest(int questId) {
        removeActiveQuest(questId, true);
    }

    public final void removeActiveQuest(int questId, boolean update) {
        var questStatus = mQuestStatus.get(questId);

        if (questStatus != null) {
            _questObjectiveStatus.RemoveIfMatching((objective) -> objective.value.questStatusPair.status == questStatus);
            mQuestStatus.remove(questId);
            questStatusSave.put(questId, QuestSaveType.Delete);
        }

        if (update) {
            sendQuestUpdate(questId);
        }
    }

    public final void removeRewardedQuest(int questId) {
        removeRewardedQuest(questId, true);
    }

    public final void removeRewardedQuest(int questId, boolean update) {
        if (rewardedQuests.contains(questId)) {
            rewardedQuests.remove((Integer) questId);
            rewardedQuestsSave.put(questId, QuestSaveType.ForceDelete);
        }

        var questBit = global.getDB2Mgr().GetQuestUniqueBitFlag(questId);

        if (questBit != 0) {
            setQuestCompletedBit(questBit, false);
        }

        // Remove seasonal quest also
        var qInfo = global.getObjectMgr().getQuestTemplate(questId);

        if (qInfo.isSeasonal()) {
            var eventId = qInfo.getEventIdForQuest();

            if (seasonalquests.containsKey(eventId)) {
                seasonalquests.get(eventId).remove(questId);
                seasonalQuestChanged = true;
            }
        }

        if (update) {
            sendQuestUpdate(questId);
        }
    }

    public final QuestGiverStatus getQuestDialogStatus(WorldObject questgiver) {
        QuestRelationResult questRelations;
        QuestRelationResult questInvolvedRelations;

        switch (questgiver.getTypeId()) {
            case GameObject: {
                var ai = questgiver.toGameObject().getAI();

                if (ai != null) {
                    var questStatus = ai.getDialogStatus(this);

                    if (questStatus != null) {
                        return questStatus;
                    }
                }

                questRelations = global.getObjectMgr().getGOQuestRelations(questgiver.getEntry());
                questInvolvedRelations = global.getObjectMgr().getGOQuestInvolvedRelations(questgiver.getEntry());

                break;
            }
            case Unit: {
                var ai = questgiver.toCreature().getAI();

                if (ai != null) {
                    var questStatus = ai.getDialogStatus(this);

                    if (questStatus != null) {
                        return questStatus;
                    }
                }

                questRelations = global.getObjectMgr().getCreatureQuestRelations(questgiver.getEntry());
                questInvolvedRelations = global.getObjectMgr().getCreatureQuestInvolvedRelations(questgiver.getEntry());

                break;
            }
            default:
                // it's impossible, but check
                Log.outError(LogFilter.player, "GetQuestDialogStatus called for unexpected type {0}", questgiver.getTypeId());

                return QuestGiverStatus.NONE;
        }

        var result = QuestGiverStatus.NONE;

        for (var questId : questInvolvedRelations) {
            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (quest == null) {
                continue;
            }

            switch (getQuestStatus(questId)) {
                case Complete:
                    if (quest.getQuestTag() == QuestTagType.CovenantCalling) {
                        result = result.getValue() | quest.hasFlag(QuestFlag.HideRewardPoi).getValue() ? QuestGiverStatus.CovenantCallingRewardCompleteNoPOI : QuestGiverStatus.CovenantCallingRewardCompletePOI;
                    } else if (quest.hasFlagEx(questFlagsEx.LegendaryQuest)) {
                        result = result.getValue() | quest.hasFlag(QuestFlag.HideRewardPoi).getValue() ? QuestGiverStatus.LegendaryRewardCompleteNoPOI : QuestGiverStatus.LegendaryRewardCompletePOI;
                    } else {
                        result = result.getValue() | quest.hasFlag(QuestFlag.HideRewardPoi).getValue() ? QuestGiverStatus.RewardCompleteNoPOI : QuestGiverStatus.RewardCompletePOI;
                    }

                    break;
                case Incomplete:
                    if (quest.getQuestTag() == QuestTagType.CovenantCalling) {
                        result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.CovenantCallingReward.getValue());
                    } else {
                        result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.reward.getValue());
                    }

                    break;
                default:
                    break;
            }

            if (quest.isAutoComplete() && canTakeQuest(quest, false) && quest.isRepeatable() && !quest.isDailyOrWeekly() && !quest.isMonthly()) {
                if (getLevel() <= (getQuestLevel(quest) + WorldConfig.getIntValue(WorldCfg.QuestLowLevelHideDiff))) {
                    result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.RepeatableTurnin.getValue());
                } else {
                    result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.TrivialRepeatableTurnin.getValue());
                }
            }
        }

        for (var questId : questRelations) {
            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (quest == null) {
                continue;
            }

            if (!global.getConditionMgr().isObjectMeetingNotGroupedConditions(ConditionSourceType.QuestAvailable, quest.id, this)) {
                continue;
            }

            if (getQuestStatus(questId) == QuestStatus.NONE) {
                if (canSeeStartQuest(quest)) {
                    if (satisfyQuestLevel(quest, false)) {
                        if (getLevel() <= (getQuestLevel(quest) + WorldConfig.getIntValue(WorldCfg.QuestLowLevelHideDiff))) {
                            if (quest.getQuestTag() == QuestTagType.CovenantCalling) {
                                result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.CovenantCallingQuest.getValue());
                            } else if (quest.hasFlagEx(questFlagsEx.LegendaryQuest)) {
                                result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.LegendaryQuest.getValue());
                            } else if (quest.isDaily()) {
                                result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.DailyQuest.getValue());
                            } else {
                                result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.Quest.getValue());
                            }
                        } else if (quest.isDaily()) {
                            result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.TrivialDailyQuest.getValue());
                        } else {
                            result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.Trivial.getValue());
                        }
                    } else {
                        result = QuestGiverStatus.forValue(result.getValue() | QuestGiverStatus.Future.getValue());
                    }
                }
            }
        }

        return result;
    }

    public final short getReqKillOrCastCurrentCount(int quest_id, int entry) {
        var qInfo = global.getObjectMgr().getQuestTemplate(quest_id);

        if (qInfo == null) {
            return 0;
        }

        var slot = findQuestSlot(quest_id);

        if (slot >= SharedConst.MaxQuestLogSize) {
            return 0;
        }

        for (var obj : qInfo.objectives) {
            if (obj.objectID == entry) {
                return (short) getQuestSlotObjectiveData(slot, obj);
            }
        }

        return 0;
    }

    public final void adjustQuestObjectiveProgress(Quest quest) {
        // adjust progress of quest objectives that rely on external counters, like items
        if (quest.hasQuestObjectiveType(QuestObjectiveType.item)) {
            for (var obj : quest.objectives) {
                if (obj.type == QuestObjectiveType.item) {
                    var reqItemCount = obj.amount;
                    var curItemCount = getItemCount(obj.objectID, true);
                    setQuestObjectiveData(obj, Math.min(curItemCount, reqItemCount));
                } else if (obj.type == QuestObjectiveType.HaveCurrency) {
                    var reqCurrencyCount = obj.amount;
                    var curCurrencyCount = getCurrencyQuantity(obj.objectID);
                    setQuestObjectiveData(obj, Math.min(reqCurrencyCount, curCurrencyCount));
                }
            }
        }
    }

    public final short findQuestSlot(int quest_id) {
        for (short i = 0; i < SharedConst.MaxQuestLogSize; ++i) {
            if (getQuestSlotQuestId(i) == quest_id) {
                return i;
            }
        }

        return SharedConst.MaxQuestLogSize;
    }

    public final int getQuestSlotQuestId(short slot) {
        return getPlayerData().questLog.get(slot).questID;
    }

    public final int getQuestSlotState(short slot, byte counter) {
        return getPlayerData().questLog.get(slot).stateFlags;
    }

    public final short getQuestSlotCounter(short slot, byte counter) {
        if (counter < SharedConst.MaxQuestCounts) {
            return getPlayerData().questLog.get(slot).objectiveProgress.get(counter);
        }

        return 0;
    }

    public final int getQuestSlotEndTime(short slot) {
        return getPlayerData().questLog.get(slot).endTime;
    }

    public final int getQuestSlotAcceptTime(short slot) {
        return getPlayerData().questLog.get(slot).acceptTime;
    }

    public final int getQuestSlotObjectiveData(short slot, QuestObjective objective) {
        if (objective.storageIndex < 0) {
            Log.outError(LogFilter.player, String.format("Player.GetQuestObjectiveData: Called for quest %1$s with invalid StorageIndex %2$s (objective data is not tracked)", objective.questID, objective.storageIndex));

            return 0;
        }

        if (objective.storageIndex >= SharedConst.MaxQuestCounts) {
            Log.outError(LogFilter.player, String.format("Player.GetQuestObjectiveData: Player '%1$s' (%2$s) quest %3$s out of range StorageIndex %4$s", getName(), getGUID(), objective.questID, objective.storageIndex));

            return 0;
        }

        if (!objective.isStoringFlag()) {
            return getQuestSlotCounter(slot, objective.storageIndex);
        }

        return getQuestSlotObjectiveFlag(slot, objective.storageIndex) ? 1 : 0;
    }

    public final void setQuestSlot(short slot, int quest_id) {
        var questLogField = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        setUpdateFieldValue(questLogField.modifyValue(questLogField.questID), quest_id);
        setUpdateFieldValue(questLogField.modifyValue(questLogField.stateFlags), 0);
        setUpdateFieldValue(questLogField.modifyValue(questLogField.endTime), 0);
        setUpdateFieldValue(questLogField.modifyValue(questLogField.acceptTime), 0);
        setUpdateFieldValue(questLogField.modifyValue(questLogField.objectiveFlags), 0);

        for (var i = 0; i < SharedConst.MaxQuestCounts; ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref questLogField.modifyValue(questLogField.objectiveProgress, i), (short) 0);
        }
    }

    public final void setQuestSlotCounter(short slot, byte counter, short count) {
        if (counter >= SharedConst.MaxQuestCounts) {
            return;
        }

        var questLog = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref questLog.modifyValue(questLog.objectiveProgress, counter), count);
    }

    public final void setQuestSlotState(short slot, QuestSlotStateMask state) {
        var questLogField = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        setUpdateFieldFlagValue(questLogField.modifyValue(questLogField.stateFlags), (int) state.getValue());
    }

    public final void removeQuestSlotState(short slot, QuestSlotStateMask state) {
        var questLogField = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        removeUpdateFieldFlagValue(questLogField.modifyValue(questLogField.stateFlags), (int) state.getValue());
    }

    public final void setQuestSlotEndTime(short slot, long endTime) {
        var questLog = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        setUpdateFieldValue(questLog.modifyValue(questLog.endTime), (int) endTime);
    }

    public final void setQuestSlotAcceptTime(short slot, long acceptTime) {
        var questLog = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        setUpdateFieldValue(questLog.modifyValue(questLog.acceptTime), (int) acceptTime);
    }

    public final void areaExploredOrEventHappens(int questId) {
        if (questId != 0) {
            var status = mQuestStatus.get(questId);

            if (status != null) {
                // Dont complete failed quest
                if (!status.explored && status.status != QuestStatus.Failed) {
                    status.explored = true;
                    questStatusSave.put(questId, QuestSaveType.Default);

                    sendQuestComplete(questId);
                }
            }

            if (canCompleteQuest(questId)) {
                completeQuest(questId);
            }
        }
    }

    public final void groupEventHappens(int questId, WorldObject pEventObject) {
        var group = getGroup();

        if (group) {
            for (var refe = group.getFirstMember(); refe != null; refe = refe.next()) {
                var player = refe.getSource();

                // for any leave or dead (with not released body) group member at appropriate distance
                if (player && player.isAtGroupRewardDistance(pEventObject) && !player.getCorpse()) {
                    player.areaExploredOrEventHappens(questId);
                }
            }
        } else {
            areaExploredOrEventHappens(questId);
        }
    }

    public final void itemAddedQuestCheck(int entry, int count) {
        updateQuestObjectiveProgress(QuestObjectiveType.item, (int) entry, count);
    }

    public final void itemRemovedQuestCheck(int entry, int count) {
        for (var objectiveStatusData : _questObjectiveStatus.get((QuestObjectiveType.item, (int) entry)))
        {
            var questId = objectiveStatusData.questStatusPair.questID;
            var quest = global.getObjectMgr().getQuestTemplate(questId);
            var logSlot = objectiveStatusData.questStatusPair.status.slot;
            var objective = objectiveStatusData.objective;

            if (!isQuestObjectiveCompletable(logSlot, quest, objective)) {
                continue;
            }

            var newItemCount = getItemCount(entry, false); // we may have more than what the status shows, so we have to iterate inventory

            if (newItemCount < objective.amount) {
                setQuestObjectiveData(objective, newItemCount);
                incompleteQuest(questId);
            }
        }

        updateVisibleGameobjectsOrSpellClicks();
    }

    public final void killedMonster(CreatureTemplate cInfo, ObjectGuid guid) {
        if (cInfo.entry != 0) {
            killedMonsterCredit(cInfo.entry, guid);
        }

        for (byte i = 0; i < 2; ++i) {
            if (cInfo.KillCredit[i] != 0) {
                killedMonsterCredit(cInfo.KillCredit[i]);
            }
        }
    }

    public final void killedMonsterCredit(int entry) {
        killedMonsterCredit(entry, null);
    }

    public final void killedMonsterCredit(int entry, ObjectGuid guid) {
        short addKillCount = 1;
        var real_entry = entry;
        Creature killed = null;

        if (!guid.isEmpty()) {
            killed = getMap().getCreature(guid);

            if (killed != null && killed.getEntry() != 0) {
                real_entry = killed.getEntry();
            }
        }

        startCriteriaTimer(CriteriaStartEvent.KillNPC, real_entry); // MUST BE CALLED FIRST
        updateCriteria(CriteriaType.KillCreature, real_entry, addKillCount, 0, killed);

        updateQuestObjectiveProgress(QuestObjectiveType.Monster, (int) entry, 1, guid);
    }

    public final void killedPlayerCredit(ObjectGuid victimGuid) {
        updateQuestObjectiveProgress(QuestObjectiveType.PlayerKills, 0, 1, victimGuid);
    }

    public final void killCreditGO(int entry) {
        killCreditGO(entry, null);
    }

    public final void killCreditGO(int entry, ObjectGuid guid) {
        updateQuestObjectiveProgress(QuestObjectiveType.gameObject, (int) entry, 1, guid);
    }

    public final void killCreditCriteriaTreeObjective(QuestObjective questObjective) {
        updateQuestObjectiveProgress(QuestObjectiveType.CriteriaTree, questObjective.objectID, 1);
    }

    public final void talkedToCreature(int entry, ObjectGuid guid) {
        updateQuestObjectiveProgress(QuestObjectiveType.TalkTo, (int) entry, 1, guid);
    }

    public final void moneyChanged(long value) {
        updateQuestObjectiveProgress(QuestObjectiveType.money, 0, value - getMoney());
    }

    public final void reputationChanged(FactionRecord FactionRecord, int change) {
        updateQuestObjectiveProgress(QuestObjectiveType.MinReputation, (int) FactionRecord.id, change);
        updateQuestObjectiveProgress(QuestObjectiveType.MaxReputation, (int) FactionRecord.id, change);
        updateQuestObjectiveProgress(QuestObjectiveType.IncreaseReputation, (int) FactionRecord.id, change);
    }

    public final void updateQuestObjectiveProgress(QuestObjectiveType objectiveType, int objectId, long addCount) {
        updateQuestObjectiveProgress(objectiveType, objectId, addCount, null);
    }

    public final void updateQuestObjectiveProgress(QuestObjectiveType objectiveType, int objectId, long addCount, ObjectGuid victimGuid) {
        var anyObjectiveChangedCompletionState = false;

        for (var objectiveStatusData : _questObjectiveStatus.get((objectiveType, objectId)))
        {
            var questId = objectiveStatusData.questStatusPair.questID;
            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (!questObjective.canAlwaysBeProgressedInRaid(objectiveType)) {
                if (getGroup() && getGroup().isRaidGroup() && quest.isAllowedInRaid(getMap().getDifficultyID())) {
                    continue;
                }
            }

            var logSlot = objectiveStatusData.questStatusPair.status.slot;
            var objective = objectiveStatusData.objective;

            if (!isQuestObjectiveCompletable(logSlot, quest, objective)) {
                continue;
            }

            var objectiveWasComplete = isQuestObjectiveComplete(logSlot, quest, objective);

            if (!objectiveWasComplete || addCount < 0) {
                var objectiveIsNowComplete = false;

                if (objective.isStoringValue()) {
                    if (objectiveType == QuestObjectiveType.PlayerKills && objective.flags.hasFlag(QuestObjectiveFlags.KillPlayersSameFaction)) {
                        var victim = global.getObjAccessor().getPlayer(getMap(), victimGuid);

                        if ((victim == null ? null : victim.getEffectiveTeam()) != getEffectiveTeam()) {
                            continue;
                        }
                    }

                    var currentProgress = getQuestSlotObjectiveData(logSlot, objective);

                    if (addCount > 0 ? (currentProgress < objective.amount) : (currentProgress > 0)) {
                        var newProgress = (int) Math.Clamp(currentProgress + addCount, 0, objective.amount);
                        setQuestObjectiveData(objective, newProgress);

                        if (addCount > 0 && !objective.flags.hasFlag(QuestObjectiveFlags.HideCreditMsg)) {
                            switch (objectiveType) {
                                case Item:
                                    break;
                                case PlayerKills:
                                    sendQuestUpdateAddPlayer(quest, newProgress);

                                    break;
                                default:
                                    sendQuestUpdateAddCredit(quest, victimGuid, objective, newProgress);

                                    break;
                            }
                        }

                        objectiveIsNowComplete = isQuestObjectiveComplete(logSlot, quest, objective);
                    }
                } else if (objective.isStoringFlag()) {
                    setQuestObjectiveData(objective, addCount > 0 ? 1 : 0);

                    if (addCount > 0 && !objective.flags.hasFlag(QuestObjectiveFlags.HideCreditMsg)) {
                        sendQuestUpdateAddCreditSimple(objective);
                    }

                    objectiveIsNowComplete = isQuestObjectiveComplete(logSlot, quest, objective);
                } else {
                    switch (objectiveType) {
                        case Currency:
                            objectiveIsNowComplete = getCurrencyQuantity(objectId) + addCount >= objective.amount;

                            break;
                        case LearnSpell:
                            objectiveIsNowComplete = addCount != 0;

                            break;
                        case MinReputation:
                            objectiveIsNowComplete = getReputationMgr().getReputation(objectId) + addCount >= objective.amount;

                            break;
                        case MaxReputation:
                            objectiveIsNowComplete = getReputationMgr().getReputation(objectId) + addCount <= objective.amount;

                            break;
                        case Money:
                            objectiveIsNowComplete = getMoney() + addCount >= objective.amount;

                            break;
                        case ProgressBar:
                            objectiveIsNowComplete = isQuestObjectiveProgressBarComplete(logSlot, quest);

                            break;
                    }
                }

                if (objective.flags.hasFlag(QuestObjectiveFlags.PartOfProgressBar)) {
                    if (isQuestObjectiveProgressBarComplete(logSlot, quest)) {
                        var progressBarObjective = tangible.ListHelper.find(quest.objectives, otherObjective -> otherObjective.type == QuestObjectiveType.ProgressBar && !otherObjective.flags.hasFlag(QuestObjectiveFlags.PartOfProgressBar));

                        if (progressBarObjective != null) {
                            sendQuestUpdateAddCreditSimple(progressBarObjective);
                        }

                        objectiveIsNowComplete = true;
                    }
                }

                if (objectiveWasComplete != objectiveIsNowComplete) {
                    anyObjectiveChangedCompletionState = true;
                }

                if (objectiveIsNowComplete && canCompleteQuest(questId, objective.id)) {
                    completeQuest(questId);
                } else if (objectiveStatusData.questStatusPair.status.status == QuestStatus.Complete) {
                    incompleteQuest(questId);
                }
            }
        }

        if (anyObjectiveChangedCompletionState) {
            updateVisibleGameobjectsOrSpellClicks();
        }

        PhasingHandler.onConditionChange(this);
    }

    public final boolean hasQuestForItem(int itemid) {
        // Search incomplete objective first
        for (var objectiveItr : _questObjectiveStatus.get((QuestObjectiveType.item, (int) itemid)))
        {
            var qInfo = global.getObjectMgr().getQuestTemplate(objectiveItr.questStatusPair.questID);
            var objective = objectiveItr.objective;

            if (!isQuestObjectiveCompletable(objectiveItr.questStatusPair.status.slot, qInfo, objective)) {
                continue;
            }

            // hide quest if player is in raid-group and quest is no raid quest
            if (getGroup() && getGroup().isRaidGroup() && !qInfo.isAllowedInRaid(getMap().getDifficultyID())) {
                if (!getInBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
                {
                    continue;
                }
            }

            if (!isQuestObjectiveComplete(objectiveItr.questStatusPair.status.slot, qInfo, objective)) {
                return true;
            }
        }

        // This part - for ItemDrop
        for (var questStatus : mQuestStatus.entrySet()) {
            if (questStatus.getValue().status != QuestStatus.INCOMPLETE) {
                continue;
            }

            var qInfo = global.getObjectMgr().getQuestTemplate(questStatus.getKey());

            // hide quest if player is in raid-group and quest is no raid quest
            if (getGroup() && getGroup().isRaidGroup() && !qInfo.isAllowedInRaid(getMap().getDifficultyID())) {
                if (!getInBattleground()) {
                    continue;
                }
            }

            for (byte j = 0; j < SharedConst.QuestItemDropCount; ++j) {
                // examined item is a source item
                if (qInfo.ItemDrop[j] != itemid) {
                    continue;
                }

                var pProto = global.getObjectMgr().getItemTemplate(itemid);

                // allows custom amount drop when not 0
                var maxAllowedCount = qInfo.ItemDropQuantity[j] != 0 ? qInfo.ItemDropQuantity[j] : pProto.getMaxStackSize();

                // 'unique' item
                if (pProto.getMaxCount() != 0 && pProto.getMaxCount() < maxAllowedCount) {
                    maxAllowedCount = pProto.getMaxCount();
                }

                if (getItemCount(itemid, true) < maxAllowedCount) {
                    return true;
                }
            }
        }

        return false;
    }

    public final int getQuestObjectiveData(QuestObjective objective) {
        var slot = findQuestSlot(objective.questID);

        if (slot >= SharedConst.MaxQuestLogSize) {
            return 0;
        }

        return getQuestSlotObjectiveData(slot, objective);
    }

    public final void setQuestObjectiveData(QuestObjective objective, int data) {
        if (objective.storageIndex < 0) {
            Log.outError(LogFilter.player, String.format("Player.SetQuestObjectiveData: called for quest %1$s with invalid StorageIndex %2$s (objective data is not tracked)", objective.questID, objective.storageIndex));

            return;
        }

        var status = mQuestStatus.get(objective.questID);

        if (status == null) {
            Log.outError(LogFilter.player, String.format("Player.SetQuestObjectiveData: player '%1$s' (%2$s) doesn't have quest status data (QuestID: %3$s)", getName(), getGUID(), objective.questID));

            return;
        }

        if (objective.storageIndex >= SharedConst.MaxQuestCounts) {
            Log.outError(LogFilter.player, String.format("Player.SetQuestObjectiveData: player '%1$s' (%2$s) quest %3$s out of range StorageIndex %4$s", getName(), getGUID(), objective.questID, objective.storageIndex));

            return;
        }

        if (status.slot >= SharedConst.MaxQuestLogSize) {
            return;
        }

        // No change
        var oldData = getQuestSlotObjectiveData(status.slot, objective);

        if (oldData == data) {
            return;
        }

        var quest = global.getObjectMgr().getQuestTemplate(objective.questID);

        if (quest != null) {
            global.getScriptMgr().<IQuestOnQuestObjectiveChange>RunScript(script -> script.OnQuestObjectiveChange(this, quest, objective, oldData, data), quest.getScriptId());
        }

        // Add to save
        questStatusSave.put(objective.questID, QuestSaveType.Default);

        // Update quest fields
        if (!objective.isStoringFlag()) {
            setQuestSlotCounter(status.slot, (byte) objective.storageIndex, (short) data);
        } else if (data != 0) {
            setQuestSlotObjectiveFlag(status.slot, objective.storageIndex);
        } else {
            removeQuestSlotObjectiveFlag(status.slot, objective.storageIndex);
        }
    }

    public final boolean isQuestObjectiveCompletable(short slot, Quest quest, QuestObjective objective) {
        if (objective.flags.hasFlag(QuestObjectiveFlags.PartOfProgressBar)) {
            // delegate check to actual progress bar objective
            var progressBarObjective = tangible.ListHelper.find(quest.objectives, otherObjective -> otherObjective.type == QuestObjectiveType.ProgressBar && !otherObjective.flags.hasFlag(QuestObjectiveFlags.PartOfProgressBar));

            if (progressBarObjective == null) {
                return false;
            }

            return isQuestObjectiveCompletable(slot, quest, progressBarObjective) && !isQuestObjectiveComplete(slot, quest, progressBarObjective);
        }

        var objectiveIndex = quest.objectives.indexOf(objective);

        if (objectiveIndex == 0) {
            return true;
        }

        // check sequenced objectives
        var previousIndex = objectiveIndex - 1;
        var objectiveSequenceSatisfied = true;
        var previousSequencedObjectiveComplete = false;
        var previousSequencedObjectiveIndex = -1;

        do {
            var previousObjective = quest.objectives.get(previousIndex);

            if (previousObjective.flags.hasFlag(QuestObjectiveFlags.Sequenced)) {
                previousSequencedObjectiveIndex = previousIndex;
                previousSequencedObjectiveComplete = isQuestObjectiveComplete(slot, quest, previousObjective);

                break;
            }

            if (objectiveSequenceSatisfied) {
                objectiveSequenceSatisfied = isQuestObjectiveComplete(slot, quest, previousObjective) || previousObjective.flags.hasFlag(QuestObjectiveFlags.Optional.getValue() | QuestObjectiveFlags.PartOfProgressBar.getValue());
            }

            --previousIndex;
        } while (previousIndex >= 0);

        if (objective.flags.hasFlag(QuestObjectiveFlags.Sequenced)) {
            if (previousSequencedObjectiveIndex == -1) {
                return objectiveSequenceSatisfied;
            }

            return previousSequencedObjectiveComplete && objectiveSequenceSatisfied;
        } else if (!previousSequencedObjectiveComplete && previousSequencedObjectiveIndex != -1) {
            return isQuestObjectiveCompletable(slot, quest, quest.objectives.get(previousSequencedObjectiveIndex));
        }

        return true;
    }

    public final boolean isQuestObjectiveComplete(short slot, Quest quest, QuestObjective objective) {
        switch (objective.type) {
            case Monster:
            case Item:
            case GameObject:
            case TalkTo:
            case PlayerKills:
            case WinPvpPetBattles:
            case HaveCurrency:
            case ObtainCurrency:
            case IncreaseReputation:
                if (getQuestSlotObjectiveData(slot, objective) < objective.amount) {
                    return false;
                }

                break;
            case MinReputation:
                if (getReputationMgr().getReputation(objective.objectID) < objective.amount) {
                    return false;
                }

                break;
            case MaxReputation:
                if (getReputationMgr().getReputation(objective.objectID) > objective.amount) {
                    return false;
                }

                break;
            case Money:
                if (!hasEnoughMoney(objective.amount)) {
                    return false;
                }

                break;
            case AreaTrigger:
            case WinPetBattleAgainstNpc:
            case DefeatBattlePet:
            case CriteriaTree:
            case AreaTriggerEnter:
            case AreaTriggerExit:
                if (getQuestSlotObjectiveData(slot, objective) == 0) {
                    return false;
                }

                break;
            case LearnSpell:
                if (!hasSpell(objective.objectID)) {
                    return false;
                }

                break;
            case Currency:
                if (!hasCurrency(objective.objectID, objective.amount)) {
                    return false;
                }

                break;
            case ProgressBar:
                if (!isQuestObjectiveProgressBarComplete(slot, quest)) {
                    return false;
                }

                break;
            default:
                Log.outError(LogFilter.player, "Player.CanCompleteQuest: Player '{0}' ({1}) tried to complete a quest (ID: {2}) with an unknown objective type {3}", getName(), getGUID().toString(), objective.questID, objective.type);

                return false;
        }

        return true;
    }

    public final boolean isQuestObjectiveProgressBarComplete(short slot, Quest quest) {
        var progress = 0.0f;

        for (var obj : quest.objectives) {
            if (obj.flags.hasFlag(QuestObjectiveFlags.PartOfProgressBar)) {
                progress += getQuestSlotObjectiveData(slot, obj) * obj.progressBarWeight;

                if (progress >= 100.0f) {
                    return true;
                }
            }
        }

        return false;
    }

    public final void sendQuestComplete(int questId) {
        if (questId != 0) {
            QuestUpdateComplete data = new QuestUpdateComplete();
            data.questID = questId;
            sendPacket(data);
        }
    }

    public final void sendQuestReward(Quest quest, Creature questGiver, int xp, boolean hideChatMessage) {
        var questId = quest.id;
        global.getGameEventMgr().handleQuestComplete(questId);

        int moneyReward;

        if (!isMaxLevel()) {
            moneyReward = getQuestMoneyReward(quest);
        } else // At max level, increase gold reward
        {
            xp = 0;
            moneyReward = getQuestMoneyReward(quest) + (int) (quest.getRewMoneyMaxLevel() * WorldConfig.getFloatValue(WorldCfg.RateDropMoney));
        }

        QuestGiverQuestComplete packet = new QuestGiverQuestComplete();

        packet.questID = questId;
        packet.moneyReward = moneyReward;
        packet.XPReward = xp;
        packet.skillLineIDReward = quest.rewardSkillId;
        packet.numSkillUpsReward = quest.rewardSkillPoints;

        if (questGiver) {
            if (questGiver.isGossip()) {
                packet.launchGossip = true;
            } else if (questGiver.isQuestGiver()) {
                packet.launchQuest = true;
            } else if (quest.getNextQuestInChain() != 0 && !quest.hasFlag(QuestFlag.AutoComplete)) {
                var rewardQuest = global.getObjectMgr().getQuestTemplate(quest.getNextQuestInChain());

                if (rewardQuest != null) {
                    packet.useQuestReward = canTakeQuest(rewardQuest, false);
                }
            }
        }

        packet.hideChatMessage = hideChatMessage;

        sendPacket(packet);
    }

    public final void sendQuestFailed(int questId) {
        sendQuestFailed(questId, InventoryResult.Ok);
    }

    public final void sendQuestFailed(int questId, InventoryResult reason) {
        if (questId != 0) {
            QuestGiverQuestFailed questGiverQuestFailed = new QuestGiverQuestFailed();
            questGiverQuestFailed.questID = questId;
            questGiverQuestFailed.reason = reason; // failed reason (valid reasons: 4, 16, 50, 17, other values show default message)
            sendPacket(questGiverQuestFailed);
        }
    }

    public final void sendQuestTimerFailed(int questId) {
        if (questId != 0) {
            QuestUpdateFailedTimer questUpdateFailedTimer = new QuestUpdateFailedTimer();
            questUpdateFailedTimer.questID = questId;
            sendPacket(questUpdateFailedTimer);
        }
    }

    public final void sendCanTakeQuestResponse(QuestFailedReasons reason, boolean sendErrorMessage) {
        sendCanTakeQuestResponse(reason, sendErrorMessage, "");
    }

    public final void sendCanTakeQuestResponse(QuestFailedReasons reason) {
        sendCanTakeQuestResponse(reason, true, "");
    }

    public final void sendCanTakeQuestResponse(QuestFailedReasons reason, boolean sendErrorMessage, String reasonText) {
        QuestGiverInvalidQuest questGiverInvalidQuest = new QuestGiverInvalidQuest();

        questGiverInvalidQuest.reason = reason;
        questGiverInvalidQuest.sendErrorMessage = sendErrorMessage;
        questGiverInvalidQuest.reasonText = reasonText;

        sendPacket(questGiverInvalidQuest);
    }

    public final void sendQuestConfirmAccept(Quest quest, Player receiver) {
        if (!receiver) {
            return;
        }

        QuestConfirmAcceptResponse packet = new QuestConfirmAcceptResponse();

        packet.questTitle = quest.logTitle;

        var loc_idx = receiver.getSession().getSessionDbLocaleIndex();

        if (loc_idx != locale.enUS) {
            var questLocale = global.getObjectMgr().getQuestLocale(quest.id);

            if (questLocale != null) {
                tangible.RefObject<String> tempRef_QuestTitle = new tangible.RefObject<String>(packet.questTitle);
                ObjectManager.getLocaleString(questLocale.logTitle, loc_idx, tempRef_QuestTitle);
                packet.questTitle = tempRef_QuestTitle.refArgValue;
            }
        }

        packet.questID = quest.id;
        packet.initiatedBy = getGUID();

        receiver.sendPacket(packet);
    }

    public final void sendPushToPartyResponse(Player player, QuestPushReason reason) {
        sendPushToPartyResponse(player, reason, null);
    }

    public final void sendPushToPartyResponse(Player player, QuestPushReason reason, Quest quest) {
        if (player != null) {
            QuestPushResultResponse response = new QuestPushResultResponse();
            response.senderGUID = player.getGUID();
            response.result = reason;

            if (quest != null) {
                response.questTitle = quest.logTitle;
                var localeConstant = getSession().getSessionDbLocaleIndex();

                if (localeConstant != locale.enUS) {
                    var questTemplateLocale = global.getObjectMgr().getQuestLocale(quest.id);

                    if (questTemplateLocale != null) {
                        tangible.RefObject<String> tempRef_QuestTitle = new tangible.RefObject<String>(response.questTitle);
                        ObjectManager.getLocaleString(questTemplateLocale.logTitle, localeConstant, tempRef_QuestTitle);
                        response.questTitle = tempRef_QuestTitle.refArgValue;
                    }
                }
            }

            sendPacket(response);
        }
    }

    public final void sendQuestUpdateAddCreditSimple(QuestObjective obj) {
        QuestUpdateAddCreditSimple packet = new QuestUpdateAddCreditSimple();
        packet.questID = obj.questID;
        packet.objectID = obj.objectID;
        packet.objectiveType = obj.type;
        sendPacket(packet);
    }

    public final void sendQuestUpdateAddPlayer(Quest quest, int newCount) {
        QuestUpdateAddPvPCredit packet = new QuestUpdateAddPvPCredit();
        packet.questID = quest.id;
        packet.count = (short) newCount;
        sendPacket(packet);
    }

    public final void sendQuestGiverStatusMultiple() {
        synchronized (getClientGuiDs()) {
            sendQuestGiverStatusMultiple(getClientGuiDs());
        }
    }

    public final void sendQuestGiverStatusMultiple(ArrayList<ObjectGuid> guids) {
        QuestGiverStatusMultiple response = new QuestGiverStatusMultiple();

        for (var itr : guids) {
            if (itr.isAnyTypeCreature()) {
                // need also pet quests case support
                var questgiver = ObjectAccessor.GetCreatureOrPetOrVehicle(this, itr);

                if (!questgiver || questgiver.isHostileTo(this)) {
                    continue;
                }

                if (!questgiver.hasNpcFlag(NPCFlags.questGiver)) {
                    continue;
                }

                response.questGiver.add(new QuestGiverInfo(questgiver.getGUID(), getQuestDialogStatus(questgiver)));
            } else if (itr.isGameObject()) {
                var questgiver = getMap().getGameObject(itr);

                if (!questgiver || questgiver.getGoType() != GameObjectTypes.questGiver) {
                    continue;
                }

                response.questGiver.add(new QuestGiverInfo(questgiver.getGUID(), getQuestDialogStatus(questgiver)));
            }
        }

        sendPacket(response);
    }

    public final boolean hasPvPForcingQuest() {
        for (byte i = 0; i < SharedConst.MaxQuestLogSize; ++i) {
            var questId = getQuestSlotQuestId(i);

            if (questId == 0) {
                continue;
            }

            var quest = global.getObjectMgr().getQuestTemplate(questId);

            if (quest == null) {
                continue;
            }

            if (quest.hasFlag(QuestFlag.Pvp)) {
                return true;
            }
        }

        return false;
    }

    public final boolean hasQuestForGO(int GOId) {
        for (var objectiveStatusData : _questObjectiveStatus.get((QuestObjectiveType.gameObject, GOId)))
        {
            var qInfo = global.getObjectMgr().getQuestTemplate(objectiveStatusData.questStatusPair.questID);
            var objective = objectiveStatusData.objective;

            if (!isQuestObjectiveCompletable(objectiveStatusData.questStatusPair.status.slot, qInfo, objective)) {
                continue;
            }

            // hide quest if player is in raid-group and quest is no raid quest
            if (getGroup() && getGroup().isRaidGroup() && !qInfo.isAllowedInRaid(getMap().getDifficultyID())) {
                if (!getInBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
                {
                    continue;
                }
            }

            return !isQuestObjectiveComplete(objectiveStatusData.questStatusPair.status.slot, qInfo, objective);
        }

        return false;
    }

    public final void updateVisibleGameobjectsOrSpellClicks() {
        if (getClientGuiDs().isEmpty()) {
            return;
        }

        UpdateData udata = new UpdateData(getLocation().getMapId());

        synchronized (getClientGuiDs()) {
            for (var guid : getClientGuiDs()) {
                if (guid.isGameObject()) {
                    var obj = ObjectAccessor.getGameObject(this, guid);

                    if (obj != null) {
                        ObjectFieldData objMask = new objectFieldData();
                        GameObjectFieldData goMask = new gameObjectFieldData();

                        if (_questObjectiveStatus.ContainsKey((QuestObjectiveType.gameObject, (int) obj.getEntry())))
                        {
                            objMask.markChanged(obj.getObjectData().dynamicFlags);
                        }

                        switch (obj.getGoType()) {
                            case QuestGiver:
                            case Chest:
                            case Goober:
                            case Generic:
                            case GatheringNode:
                                if (global.getObjectMgr().isGameObjectForQuests(obj.getEntry())) {
                                    objMask.markChanged(obj.getObjectData().dynamicFlags);
                                }

                                break;
                            default:
                                break;
                        }

                        if (objMask.getUpdateMask().isAnySet() || goMask.getUpdateMask().isAnySet()) {
                            obj.buildValuesUpdateForPlayerWithMask(udata, objMask.getUpdateMask(), goMask.getUpdateMask(), this);
                        }
                    }
                } else if (guid.isCreatureOrVehicle()) {
                    var obj = ObjectAccessor.GetCreatureOrPetOrVehicle(this, guid);

                    if (obj == null) {
                        continue;
                    }

                    // check if this unit requires quest specific flags
                    if (!obj.hasNpcFlag(NPCFlags.SpellClick)) {
                        continue;
                    }

                    var clickBounds = global.getObjectMgr().getSpellClickInfoMapBounds(obj.getEntry());

                    for (var spellClickInfo : clickBounds) {
                        var conds = global.getConditionMgr().getConditionsForSpellClickEvent(obj.getEntry(), spellClickInfo.spellId);

                        if (conds != null) {
                            ObjectFieldData objMask = new objectFieldData();
                            UnitData unitMask = new unitData();
                            unitMask.markChanged(getUnitData().npcFlags, 0); // NpcFlags[0] has UNIT_NPC_FLAG_SPELLCLICK
                            obj.buildValuesUpdateForPlayerWithMask(udata, objMask.getUpdateMask(), unitMask.getUpdateMask(), this);

                            break;
                        }
                    }
                }
            }
        }

        UpdateObject packet;
        tangible.OutObject<UpdateObject> tempOut_packet = new tangible.OutObject<UpdateObject>();
        udata.buildPacket(tempOut_packet);
        packet = tempOut_packet.outArgValue;
        sendPacket(packet);
    }

    public final boolean isDailyQuestDone(int quest_id) {
        return getActivePlayerData().dailyQuestsCompleted.FindIndex(quest_id) >= 0;
    }

    private int getInGameTime() {
        return ingametime;
    }

    public final void setInGameTime(int time) {
        ingametime = time;
    }

    private void addTimedQuest(int questId) {
        timedquests.add(questId);
    }


    private HashMap<Integer, QuestStatusData> getQuestStatusMap() {
        return mQuestStatus;
    }


    private int getQuestMinLevel(int contentTuningId) {
        var questLevels = global.getDB2Mgr().GetContentTuningData(contentTuningId, getPlayerData().ctrOptions.getValue().contentTuningConditionMask);

        if (questLevels != null) {
            var race = CliDB.ChrRacesStorage.get(getRace());
            var raceFaction = CliDB.FactionTemplateStorage.get(race.factionID);
            var questFactionGroup = CliDB.ContentTuningStorage.get(contentTuningId).GetScalingFactionGroup();

            if (questFactionGroup != 0 && raceFaction.factionGroup != questFactionGroup) {
                return questLevels.getValue().maxLevel;
            }

            return questLevels.getValue().MinLevelWithDelta;
        }

        return 0;
    }

    private boolean satisfyQuestLevel(Quest qInfo, boolean msg) {
        return satisfyQuestMinLevel(qInfo, msg) && satisfyQuestMaxLevel(qInfo, msg);
    }

    private boolean satisfyQuestDependentPreviousQuests(Quest qInfo, boolean msg) {
        // No previous quest (might be first quest in a series)
        if (qInfo.dependentPreviousQuests.isEmpty()) {
            return true;
        }

        for (var prevId : qInfo.dependentPreviousQuests) {
            // checked in startup
            var questInfo = global.getObjectMgr().getQuestTemplate(prevId);

            // If any of the previous quests completed, return true
            if (isQuestRewarded(prevId)) {
                // skip one-from-all exclusive group
                if (questInfo.getExclusiveGroup() >= 0) {
                    return true;
                }

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group completed and rewarded
                var bounds = global.getObjectMgr().getExclusiveQuestGroupBounds(questInfo.getExclusiveGroup());

                for (var exclusiveQuestId : bounds) {
                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclusiveQuestId == prevId) {
                        continue;
                    }

                    // alternative quest from group also must be completed and rewarded (reported)
                    if (!isQuestRewarded(exclusiveQuestId)) {
                        if (msg) {
                            sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                            Log.outDebug(LogFilter.misc, String.format("Player.SatisfyQuestDependentPreviousQuests: Sent QUEST_ERR_NONE (QuestID: %1$s) because player '%2$s' (%3$s) doesn't have the required quest (1).", qInfo.id, getName(), getGUID()));
                        }

                        return false;
                    }
                }

                return true;
            }
        }

        // Has only prev. quests in non-rewarded state
        if (msg) {
            sendCanTakeQuestResponse(QuestFailedReasons.NONE);
            Log.outDebug(LogFilter.misc, String.format("Player.SatisfyQuestDependentPreviousQuests: Sent QUEST_ERR_NONE (QuestID: %1$s) because player '%2$s' (%3$s) doesn't have required quest (2).", qInfo.id, getName(), getGUID()));
        }

        return false;
    }

    private boolean satisfyQuestBreadcrumbQuest(Quest qInfo, boolean msg) {
        var breadcrumbTargetQuestId = Math.abs(qInfo.getBreadcrumbForQuestId());

        //If this is not a breadcrumb quest.
        if (breadcrumbTargetQuestId == 0) {
            return true;
        }

        // If the target quest is not available
        if (!canTakeQuest(global.getObjectMgr().getQuestTemplate(breadcrumbTargetQuestId), false)) {
            if (msg) {
                sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                Log.outDebug(LogFilter.misc, String.format("Player.SatisfyQuestBreadcrumbQuest: Sent INVALIDREASON_DONT_HAVE_REQ (QuestID: %1$s) because target quest (QuestID: %2$s) is not available to player '%3$s' (%4$s).", qInfo.id, breadcrumbTargetQuestId, getName(), getGUID()));
            }

            return false;
        }

        return true;
    }

    private boolean satisfyQuestDependentBreadcrumbQuests(Quest qInfo, boolean msg) {
        for (var breadcrumbQuestId : qInfo.dependentBreadcrumbQuests) {
            var status = getQuestStatus(breadcrumbQuestId);

            // If any of the breadcrumb quests are in the quest log, return false.
            if (status == QuestStatus.INCOMPLETE || status == QuestStatus.Complete || status == QuestStatus.Failed) {
                if (msg) {
                    sendCanTakeQuestResponse(QuestFailedReasons.NONE);
                    Log.outDebug(LogFilter.misc, String.format("Player.SatisfyQuestDependentBreadcrumbQuests: Sent INVALIDREASON_DONT_HAVE_REQ (QuestID: %1$s) because player '%2$s' (%3$s) has a breadcrumb quest towards this quest in the quest log.", qInfo.id, getName(), getGUID()));
                }

                return false;
            }
        }

        return true;
    }


    private boolean sendQuestUpdate(int questId) {
        return sendQuestUpdate(questId, true);
    }

    private boolean sendQuestUpdate(int questId, boolean updateVisiblity) {
        var saBounds = global.getSpellMgr().getSpellAreaForQuestMapBounds(questId);

        if (!saBounds.isEmpty()) {
            ArrayList<Integer> aurasToRemove = new ArrayList<>();
            ArrayList<Integer> aurasToCast = new ArrayList<>();
            int zone;
            tangible.OutObject<Integer> tempOut_zone = new tangible.OutObject<Integer>();
            int area;
            tangible.OutObject<Integer> tempOut_area = new tangible.OutObject<Integer>();
            getZoneAndAreaId(tempOut_zone, tempOut_area);
            area = tempOut_area.outArgValue;
            zone = tempOut_zone.outArgValue;

            for (var spell : saBounds) {
                if (spell.flags.hasFlag(SpellAreaFlag.AutoRemove) && !spell.isFitToRequirements(this, zone, area)) {
                    aurasToRemove.add(spell.spellId);
                } else if (spell.flags.hasFlag(SpellAreaFlag.AutoCast) && !spell.flags.hasFlag(SpellAreaFlag.IgnoreAutocastOnQuestStatusChange)) {
                    aurasToCast.add(spell.spellId);
                }
            }

            // Auras matching the requirements will be inside the aurasToCast container.
            // Auras not matching the requirements may prevent using auras matching the requirements.
            // aurasToCast will erase conflicting auras in aurasToRemove container to handle spells used by multiple quests.

            for (var c = 0; c < aurasToRemove.size(); ) {
                var auraRemoved = false;

                for (var i : aurasToCast) {
                    if (aurasToRemove.get(c).equals(i)) {
                        aurasToRemove.remove(aurasToRemove.get(c));
                        auraRemoved = true;

                        break;
                    }
                }

                if (!auraRemoved) {
                    ++c;
                }
            }

            for (var spellId : aurasToCast) {
                if (!hasAura(spellId)) {
                    castSpell(this, spellId, true);
                }
            }

            for (var spellId : aurasToRemove) {
                removeAura(spellId);
            }
        }

        updateVisibleGameobjectsOrSpellClicks();

        return PhasingHandler.onConditionChange(this, updateVisiblity);
    }


    private boolean getQuestSlotObjectiveFlag(short slot, byte objectiveIndex) {
        if (objectiveIndex < SharedConst.MaxQuestCounts) {
            return ((getPlayerData().questLog.get(slot).objectiveFlags) & (1 << objectiveIndex)) != 0;
        }

        return false;
    }


    private void setQuestSlotObjectiveFlag(short slot, byte objectiveIndex) {
        var questLog = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        setUpdateFieldFlagValue(questLog.modifyValue(questLog.objectiveFlags), 1 << objectiveIndex);
    }


    private void removeQuestSlotObjectiveFlag(short slot, byte objectiveIndex) {
        var questLog = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().questLog, slot);
        removeUpdateFieldFlagValue(questLog.modifyValue(questLog.objectiveFlags), 1 << objectiveIndex);
    }


    private void setQuestCompletedBit(int questBit, boolean completed) {
        if (questBit == 0) {
            return;
        }

        var fieldOffset = (questBit - 1) / com.github.azeroth.game.entity.activePlayerData.QUESTCOMPLETEDBITSPERBLOCK;

        if (fieldOffset >= com.github.azeroth.game.entity.activePlayerData.QUESTCOMPLETEDBITSSIZE) {
            return;
        }

        var flag = 1 << ((questBit - 1) % com.github.azeroth.game.entity.activePlayerData.QUESTCOMPLETEDBITSPERBLOCK);

        if (completed) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldFlagValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().questCompleted, (int) fieldOffset), flag);
        } else {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            removeUpdateFieldFlagValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().questCompleted, (int) fieldOffset), flag);
        }
    }


    private void currencyChanged(int currencyId, int change) {
        updateQuestObjectiveProgress(QuestObjectiveType.currency, (int) currencyId, change);
        updateQuestObjectiveProgress(QuestObjectiveType.HaveCurrency, (int) currencyId, change);
        updateQuestObjectiveProgress(QuestObjectiveType.ObtainCurrency, (int) currencyId, change);
    }


    private void sendQuestUpdateAddCredit(Quest quest, ObjectGuid guid, QuestObjective obj, int count) {
        QuestUpdateAddCredit packet = new QuestUpdateAddCredit();
        packet.victimGUID = guid;
        packet.questID = quest.id;
        packet.objectID = obj.objectID;
        packet.count = (short) count;
        packet.required = (short) obj.amount;
        packet.objectiveType = (byte) obj.type.getValue();
        sendPacket(packet);
    }


    private void setDailyQuestStatus(int quest_id) {
        var qQuest = global.getObjectMgr().getQuestTemplate(quest_id);

        if (qQuest != null) {
            if (!qQuest.isDFQuest()) {
                addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().dailyQuestsCompleted), quest_id);
                lastDailyQuestTime = gameTime.GetGameTime(); // last daily quest time
                dailyQuestChanged = true;
            } else {
                dfQuests.add(quest_id);
                lastDailyQuestTime = gameTime.GetGameTime();
                dailyQuestChanged = true;
            }
        }
    }


    private void setWeeklyQuestStatus(int quest_id) {
        weeklyquests.add(quest_id);
        weeklyQuestChanged = true;
    }


    private void setSeasonalQuestStatus(int quest_id) {
        var quest = global.getObjectMgr().getQuestTemplate(quest_id);

        if (quest == null) {
            return;
        }

        if (!seasonalquests.containsKey(quest.getEventIdForQuest())) {
            seasonalquests.put(quest.getEventIdForQuest(), new HashMap<Integer, Long>());
        }

        seasonalquests.get(quest.getEventIdForQuest()).put(quest_id, gameTime.GetGameTime());
        seasonalQuestChanged = true;
    }


    private void setMonthlyQuestStatus(int quest_id) {
        monthlyquests.add(quest_id);
        monthlyQuestChanged = true;
    }

    private void pushQuests() {
        for (var quest : global.getObjectMgr().getQuestTemplatesAutoPush()) {
            if (quest.getQuestTag() != 0 && quest.getQuestTag() != QuestTagType.tag) {
                continue;
            }

            if (!quest.isUnavailable() && canTakeQuest(quest, false)) {
                addQuestAndCheckCompletion(quest, null);
            }
        }
    }


    private void sendDisplayToast(int entry, DisplayToastType type, boolean isBonusRoll, int quantity, DisplayToastMethod method, int questId) {
        sendDisplayToast(entry, type, isBonusRoll, quantity, method, questId, null);
    }

    private void sendDisplayToast(int entry, DisplayToastType type, boolean isBonusRoll, int quantity, DisplayToastMethod method, int questId, Item item) {
        DisplayToast displayToast = new DisplayToast();
        displayToast.quantity = quantity;
        displayToast.displayToastMethod = method;
        displayToast.questID = questId;
        displayToast.type = type;

        switch (type) {
            case NewItem: {
                if (!item) {
                    return;
                }

                displayToast.bonusRoll = isBonusRoll;
                displayToast.item = new itemInstance(item);
                displayToast.lootSpec = 0; // loot spec that was selected when loot was generated (not at loot time)
                displayToast.gender = getNativeGender();

                break;
            }
            case NewCurrency:
                displayToast.currencyID = entry;

                break;
            default:
                break;
        }

        sendPacket(displayToast);
    }


    public final void updateSkillsForLevel() {
        var race = getRace();
        var maxSkill = getMaxSkillValueForLevel();
        SkillInfo skillInfoField = getActivePlayerData().skill;

        for (var pair : skillStatus.entrySet()) {
            if (pair.getValue().state == SkillState.Deleted || skillInfoField.skillRank.get(pair.getValue().pos) == 0) {
                continue;
            }

            var pskill = pair.getKey();
            var rcEntry = global.getDB2Mgr().GetSkillRaceClassInfo(pskill, getRace(), getClass());

            if (rcEntry == null) {
                continue;
            }

            if (global.getSpellMgr().getSkillRangeType(rcEntry) == SkillRangeType.level) {
                if (rcEntry.flags.hasFlag(SkillRaceClassInfoFlags.AlwaysMaxValue)) {
                    setSkillRank(pair.getValue().pos, maxSkill);
                }

                setSkillMaxRank(pair.getValue().pos, maxSkill);

                if (pair.getValue().state != SkillState.New) {
                    pair.getValue().state = SkillState.changed;
                }
            }

            // Update level dependent skillline spells
            learnSkillRewardedSpells(rcEntry.SkillID, skillInfoField.skillRank.get(pair.getValue().pos), race);
        }
    }


    public final short getSkillValue(SkillType skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        int result = skillInfo.skillRank.get(skillStatusData.pos);
        result += skillInfo.skillTempBonus.get(skillStatusData.pos);
        result += skillInfo.skillPermBonus.get(skillStatusData.pos);

        return (short) (result < 0 ? 0 : result);
    }


    public final short getPureSkillValue(SkillType skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get((int) skill.getValue());

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        return skillInfo.skillRank.get(skillStatusData.pos);
    }


    public final short getSkillStep(SkillType skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        return skillInfo.skillStep.get(skillStatusData.pos);
    }


    public final short getPureMaxSkillValue(SkillType skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        return skillInfo.skillMaxRank.get(skillStatusData.pos);
    }


    public final short getBaseSkillValue(SkillType skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        int result = skillInfo.skillRank.get(skillStatusData.pos);
        result += skillInfo.skillPermBonus.get(skillStatusData.pos);

        return (short) (result < 0 ? 0 : result);
    }


    public final short getSkillPermBonusValue(int skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        return skillInfo.skillPermBonus.get(skillStatusData.pos);
    }


    public final short getSkillTempBonusValue(int skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        return skillInfo.skillTempBonus.get(skillStatusData.pos);
    }

    public final void petSpellInitialize() {
        var pet = getCurrentPet();

        if (!pet) {
            return;
        }

        Log.outDebug(LogFilter.pet, "Pet Spells Groups");

        var charmInfo = pet.getCharmInfo();

        PetSpells petSpellsPacket = new PetSpells();
        petSpellsPacket.petGUID = pet.getGUID();
        petSpellsPacket.creatureFamily = (short) pet.getTemplate().family.getValue(); // creature family (required for pet talents)
        petSpellsPacket.specialization = pet.getSpecialization();
        petSpellsPacket.timeLimit = pet.getDuration();
        petSpellsPacket.reactState = pet.getReactState();
        petSpellsPacket.commandState = charmInfo.getCommandState();

        // action bar loop
        for (byte i = 0; i < SharedConst.ActionBarIndexMax; ++i) {
            petSpellsPacket.ActionButtons[i] = charmInfo.getActionBarEntry(i).packedData;
        }

        if (pet.IsPermanentPetFor(this)) {
            // spells loop
            for (var pair : pet.spells.entrySet()) {
                if (pair.getValue().state == PetSpellState.removed) {
                    continue;
                }

                petSpellsPacket.actions.add(UnitActionBarEntry.MAKE_UNIT_ACTION_BUTTON(pair.getKey(), (int) pair.getValue().active));
            }
        }

        // Cooldowns
        pet.getSpellHistory().writePacket(petSpellsPacket);

        sendPacket(petSpellsPacket);
    }

    public final boolean canSeeSpellClickOn(Creature creature) {
        if (!creature.hasNpcFlag(NPCFlags.SpellClick)) {
            return false;
        }

        var clickBounds = global.getObjectMgr().getSpellClickInfoMapBounds(creature.getEntry());

        if (clickBounds.isEmpty()) {
            return true;
        }

        for (var spellClickInfo : clickBounds) {
            if (!spellClickInfo.isFitToRequirements(this, creature)) {
                return false;
            }

            if (global.getConditionMgr().isObjectMeetingSpellClickConditions(creature.getEntry(), spellClickInfo.spellId, this, creature)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public SpellInfo getCastSpellInfo(SpellInfo spellInfo) {
        var overrides = overrideSpells.get(spellInfo.getId());

        if (!overrides.isEmpty()) {
            for (var spellId : overrides) {
                var newInfo = global.getSpellMgr().getSpellInfo(spellId, getMap().getDifficultyID());

                if (newInfo != null) {
                    return getCastSpellInfo(newInfo);
                }
            }
        }

        return super.getCastSpellInfo(spellInfo);
    }


    public final void setOverrideSpellsId(int overrideSpellsId) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().overrideSpellsID), overrideSpellsId);
    }


    public final void addOverrideSpell(int overridenSpellId, int newSpellId) {
        overrideSpells.add(overridenSpellId, newSpellId);
    }


    public final void removeOverrideSpell(int overridenSpellId, int newSpellId) {
        overrideSpells.remove(overridenSpellId, newSpellId);
    }

    public final void learnSpecializationSpells() {
        var specSpells = global.getDB2Mgr().GetSpecializationSpells(getPrimarySpecialization());

        if (specSpells != null) {
            for (var j = 0; j < specSpells.size(); ++j) {
                var specSpell = specSpells.get(j);
                var spellInfo = global.getSpellMgr().getSpellInfo(specSpell.spellID, Difficulty.NONE);

                if (spellInfo == null || spellInfo.getSpellLevel() > getLevel()) {
                    continue;
                }

                learnSpell(specSpell.spellID, true);

                if (specSpell.OverridesSpellID != 0) {
                    addOverrideSpell(specSpell.OverridesSpellID, specSpell.spellID);
                }
            }
        }
    }

    public final void sendSpellCategoryCooldowns() {
        SpellCategoryCooldown cooldowns = new SpellCategoryCooldown();

        var categoryCooldownAuras = getAuraEffectsByType(AuraType.ModSpellCategoryCooldown);

        for (var aurEff : categoryCooldownAuras) {
            var categoryId = (int) aurEff.getMiscValue();
            var cooldownInfo = tangible.ListHelper.find(cooldowns.categoryCooldowns, p -> p.category == categoryId);

            if (cooldownInfo == null) {
                cooldowns.categoryCooldowns.add(new SpellCategoryCooldown.CategoryCooldownInfo(categoryId, -(int) aurEff.getAmount()));
            } else {
                cooldownInfo.ModCooldown -= (int) aurEff.getAmount();
            }
        }

        sendPacket(cooldowns);
    }


    public final boolean updateSkillPro(SkillType skillId, int chance, int step) {
        return updateSkillPro((int) skillId.getValue(), chance, step);
    }


    public final boolean updateSkillPro(int skillId, int chance, int step) {
        // levels sync. with spell requirement for skill levels to learn
        // bonus abilities in sSkillLineAbilityStore
        // Used only to avoid scan DBC at each skill grow
        int[] bonusSkillLevels = {75, 150, 225, 300, 375, 450, 525, 600, 700, 850};

        Log.outDebug(LogFilter.player, "UpdateSkillPro(SkillId {0}, Chance {0:D3}%)", skillId, chance / 10.0f);

        if (skillId == 0) {
            return false;
        }

        if (chance <= 0) // speedup in 0 chance case
        {
            Log.outDebug(LogFilter.player, "Player:UpdateSkillPro chance={0:D3}% missed", chance / 10.0f);

            return false;
        }

        var skillStatusData = skillStatus.get(skillId);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted) {
            return false;
        }

        SkillInfo skillInfoField = getActivePlayerData().skill;

        var value = skillInfoField.skillRank.get(skillStatusData.pos);
        var max = skillInfoField.skillMaxRank.get(skillStatusData.pos);

        if (max == 0 || value == 0 || value >= max) {
            return false;
        }

        if (RandomUtil.IRand(1, 1000) > chance) {
            Log.outDebug(LogFilter.player, "Player:UpdateSkillPro chance={0:F3}% missed", chance / 10.0f);

            return false;
        }

        var new_value = (short) (value + step);

        if (new_value > max) {
            new_value = max;
        }

        setSkillRank(skillStatusData.pos, new_value);

        if (skillStatusData.state != SkillState.New) {
            skillStatusData.state = SkillState.changed;
        }

        for (var bsl : bonusSkillLevels) {
            if (value < bsl && new_value >= bsl) {
                learnSkillRewardedSpells(skillId, new_value, getRace());

                break;
            }
        }

        updateSkillEnchantments(skillId, value, new_value);
        updateCriteria(CriteriaType.SkillRaised, skillId);
        Log.outDebug(LogFilter.player, "Player:UpdateSkillPro chance={0:F3}% taken", chance / 10.0f);

        return true;
    }


    public final void applyEnchantment(Item item, EnchantmentSlot slot, boolean apply, boolean apply_dur) {
        applyEnchantment(item, slot, apply, apply_dur, false);
    }

    public final void applyEnchantment(Item item, EnchantmentSlot slot, boolean apply) {
        applyEnchantment(item, slot, apply, true, false);
    }

    public final void applyEnchantment(Item item, EnchantmentSlot slot, boolean apply, boolean apply_dur, boolean ignore_condition) {
        if (item == null || !item.isEquipped()) {
            return;
        }

        if (slot.getValue() >= EnchantmentSlot.max.getValue()) {
            return;
        }

        var enchant_id = item.getEnchantmentId(slot);

        if (enchant_id == 0) {
            return;
        }

        var pEnchant = CliDB.SpellItemEnchantmentStorage.get(enchant_id);

        if (pEnchant == null) {
            return;
        }

        if (!ignore_condition && pEnchant.ConditionID != 0 && !enchantmentFitsRequirements(pEnchant.ConditionID, (byte) -1)) {
            return;
        }

        if (pEnchant.minLevel > getLevel()) {
            return;
        }

        if (pEnchant.RequiredSkillID > 0 && pEnchant.RequiredSkillRank > getSkillValue(SkillType.forValue(pEnchant.RequiredSkillID))) {
            return;
        }

        // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
        // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
        if ((slot == EnchantmentSlot.Sock1 || slot == EnchantmentSlot.Sock2 || slot == EnchantmentSlot.Sock3)) {
            if (item.getSocketColor((int) (slot - EnchantmentSlot.Sock1)) == 0) {
                // Check if the requirements for the prismatic socket are met before applying the gem stats
                var pPrismaticEnchant = CliDB.SpellItemEnchantmentStorage.get(item.getEnchantmentId(EnchantmentSlot.Prismatic));

                if (pPrismaticEnchant == null || (pPrismaticEnchant.RequiredSkillID > 0 && pPrismaticEnchant.RequiredSkillRank > getSkillValue(SkillType.forValue(pPrismaticEnchant.RequiredSkillID)))) {
                    return;
                }
            }

            // Cogwheel gems dont have requirement data set in SpellItemEnchantment.dbc, but they do have it in Item-sparse.db2
            var gem = item.getGem((short) (slot - EnchantmentSlot.Sock1));

            if (gem != null) {
                var gemTemplate = global.getObjectMgr().getItemTemplate(gem.itemId);

                if (gemTemplate != null) {
                    if (gemTemplate.getRequiredSkill() != 0 && getSkillValue(SkillType.forValue(gemTemplate.getRequiredSkill())).getValue() < gemTemplate.getRequiredSkillRank()) {
                        return;
                    }
                }
            }
        }

        if (!item.isBroken()) {
            for (var s = 0; s < ItemConst.MaxItemEnchantmentEffects; ++s) {
                var enchant_display_type = ItemEnchantmentType.forValue(pEnchant.Effect[s]);
                int enchant_amount = pEnchant.EffectPointsMin[s];
                var enchant_spell_id = pEnchant.EffectArg[s];

                switch (enchant_display_type) {
                    case None:
                        break;
                    case CombatSpell:
                        // processed in player.CastItemCombatSpell
                        break;
                    case Damage: {
                        var attackType = getAttackBySlot(item.getSlot(), item.getTemplate().getInventoryType());

                        if (attackType != WeaponAttackType.max) {
                            updateDamageDoneMods(attackType, apply ? -1 : slot.getValue());
                        }
                    }

                    break;
                    case EquipSpell:
                        if (enchant_spell_id != 0) {
                            if (apply) {
                                castSpell(this, enchant_spell_id, item);
                            } else {
                                removeAurasDueToItemSpell(enchant_spell_id, item.getGUID());
                            }
                        }

                        break;
                    case Resistance:
                        if (pEnchant.ScalingClass != 0) {
                            int scalingClass = pEnchant.ScalingClass;

                            if ((getUnitData().minItemLevel != 0 || getUnitData().maxItemLevel != 0) && pEnchant.ScalingClassRestricted != 0) {
                                scalingClass = pEnchant.ScalingClassRestricted;
                            }

                            var minLevel = pEnchant.getFlags().hasFlag(SpellItemEnchantmentFlags.ScaleAsAGem) ? 1 : 60;
                            var scalingLevel = getLevel();
                            var maxLevel = (byte) (pEnchant.maxLevel != 0 ? pEnchant.MaxLevel : CliDB.SpellScalingGameTable.GetTableRowCount() - 1);

                            if (minLevel > getLevel()) {
                                scalingLevel = minLevel;
                            } else if (maxLevel < getLevel()) {
                                scalingLevel = maxLevel;
                            }

                            var spellScaling = CliDB.SpellScalingGameTable.GetRow(scalingLevel);

                            if (spellScaling != null) {
                                enchant_amount = (int) (pEnchant.EffectScalingPoints[s] * CliDB.GetSpellScalingColumnForClass(spellScaling, scalingClass));
                            }
                        }

                        enchant_amount = Math.max(enchant_amount, 1);
                        handleStatFlatModifier(UnitMods.forValue((int) UnitMods.ResistanceStart.getValue() + enchant_spell_id), UnitModifierFlatType.Total, enchant_amount, apply);

                        break;
                    case Stat: {
                        if (pEnchant.ScalingClass != 0) {
                            int scalingClass = pEnchant.ScalingClass;

                            if ((getUnitData().minItemLevel != 0 || getUnitData().maxItemLevel != 0) && pEnchant.ScalingClassRestricted != 0) {
                                scalingClass = pEnchant.ScalingClassRestricted;
                            }

                            var minLevel = pEnchant.getFlags().hasFlag(SpellItemEnchantmentFlags.ScaleAsAGem) ? 1 : 60;
                            var scalingLevel = getLevel();
                            var maxLevel = (byte) (pEnchant.maxLevel != 0 ? pEnchant.MaxLevel : CliDB.SpellScalingGameTable.GetTableRowCount() - 1);

                            if (minLevel > getLevel()) {
                                scalingLevel = minLevel;
                            } else if (maxLevel < getLevel()) {
                                scalingLevel = maxLevel;
                            }

                            var spellScaling = CliDB.SpellScalingGameTable.GetRow(scalingLevel);

                            if (spellScaling != null) {
                                enchant_amount = (int) (pEnchant.EffectScalingPoints[s] * CliDB.GetSpellScalingColumnForClass(spellScaling, scalingClass));
                            }
                        }

                        enchant_amount = Math.max(enchant_amount, 1);

                        Log.outDebug(LogFilter.player, "Adding {0} to stat nb {1}", enchant_amount, enchant_spell_id);

                        switch (ItemModType.forValue(enchant_spell_id)) {
                            case Mana:
                                Log.outDebug(LogFilter.player, "+ {0} MANA", enchant_amount);
                                handleStatFlatModifier(UnitMods.mana, UnitModifierFlatType.base, enchant_amount, apply);

                                break;
                            case Health:
                                Log.outDebug(LogFilter.player, "+ {0} HEALTH", enchant_amount);
                                handleStatFlatModifier(UnitMods.health, UnitModifierFlatType.base, enchant_amount, apply);

                                break;
                            case Agility:
                                Log.outDebug(LogFilter.player, "+ {0} AGILITY", enchant_amount);
                                handleStatFlatModifier(UnitMods.StatAgility, UnitModifierFlatType.Total, enchant_amount, apply);
                                updateStatBuffMod(stats.Agility);

                                break;
                            case Strength:
                                Log.outDebug(LogFilter.player, "+ {0} STRENGTH", enchant_amount);
                                handleStatFlatModifier(UnitMods.StatStrength, UnitModifierFlatType.Total, enchant_amount, apply);
                                updateStatBuffMod(stats.Strength);

                                break;
                            case Intellect:
                                Log.outDebug(LogFilter.player, "+ {0} INTELLECT", enchant_amount);
                                handleStatFlatModifier(UnitMods.StatIntellect, UnitModifierFlatType.Total, enchant_amount, apply);
                                updateStatBuffMod(stats.Intellect);

                                break;
                            //case ItemModType.Spirit:
                            //Log.outDebug(LogFilter.player, "+ {0} SPIRIT", enchant_amount);
                            //HandleStatModifier(UnitMods.StatSpirit, UnitModifierType.TotalValue, enchant_amount, apply);
                            //ApplyStatBuffMod(stats.Spirit, enchant_amount, apply);
                            //break;
                            case Stamina:
                                Log.outDebug(LogFilter.player, "+ {0} STAMINA", enchant_amount);
                                handleStatFlatModifier(UnitMods.StatStamina, UnitModifierFlatType.Total, enchant_amount, apply);
                                updateStatBuffMod(stats.Stamina);

                                break;
                            case DefenseSkillRating:
                                applyRatingMod(CombatRating.DefenseSkill, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} DEFENSE", enchant_amount);

                                break;
                            case DodgeRating:
                                applyRatingMod(CombatRating.Dodge, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} DODGE", enchant_amount);

                                break;
                            case ParryRating:
                                applyRatingMod(CombatRating.Parry, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} PARRY", enchant_amount);

                                break;
                            case BlockRating:
                                applyRatingMod(CombatRating.Block, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} SHIELD_BLOCK", enchant_amount);

                                break;
                            case HitMeleeRating:
                                applyRatingMod(CombatRating.HitMelee, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} MELEE_HIT", enchant_amount);

                                break;
                            case HitRangedRating:
                                applyRatingMod(CombatRating.HitRanged, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} RANGED_HIT", enchant_amount);

                                break;
                            case HitSpellRating:
                                applyRatingMod(CombatRating.HitSpell, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} SPELL_HIT", enchant_amount);

                                break;
                            case CritMeleeRating:
                                applyRatingMod(CombatRating.CritMelee, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} MELEE_CRIT", enchant_amount);

                                break;
                            case CritRangedRating:
                                applyRatingMod(CombatRating.CritRanged, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} RANGED_CRIT", enchant_amount);

                                break;
                            case CritSpellRating:
                                applyRatingMod(CombatRating.CritSpell, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} SPELL_CRIT", enchant_amount);

                                break;
                            case HasteSpellRating:
                                applyRatingMod(CombatRating.HasteSpell, (int) enchant_amount, apply);

                                break;
                            case HitRating:
                                applyRatingMod(CombatRating.HitMelee, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.HitRanged, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.HitSpell, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} HIT", enchant_amount);

                                break;
                            case CritRating:
                                applyRatingMod(CombatRating.CritMelee, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.CritRanged, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.CritSpell, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} CRITICAL", enchant_amount);

                                break;
                            case ResilienceRating:
                                applyRatingMod(CombatRating.ResiliencePlayerDamage, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} RESILIENCE", enchant_amount);

                                break;
                            case HasteRating:
                                applyRatingMod(CombatRating.HasteMelee, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.HasteRanged, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.HasteSpell, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} HASTE", enchant_amount);

                                break;
                            case ExpertiseRating:
                                applyRatingMod(CombatRating.Expertise, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} EXPERTISE", enchant_amount);

                                break;
                            case AttackPower:
                                handleStatFlatModifier(UnitMods.attackPower, UnitModifierFlatType.Total, enchant_amount, apply);
                                handleStatFlatModifier(UnitMods.AttackPowerRanged, UnitModifierFlatType.Total, enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} ATTACK_POWER", enchant_amount);

                                break;
                            case RangedAttackPower:
                                handleStatFlatModifier(UnitMods.AttackPowerRanged, UnitModifierFlatType.Total, enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} RANGED_ATTACK_POWER", enchant_amount);

                                break;
                            case ManaRegeneration:
                                applyManaRegenBonus(enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} MANA_REGENERATION", enchant_amount);

                                break;
                            case ArmorPenetrationRating:
                                applyRatingMod(CombatRating.ArmorPenetration, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} ARMOR PENETRATION", enchant_amount);

                                break;
                            case SpellPower:
                                applySpellPowerBonus(enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} SPELL_POWER", enchant_amount);

                                break;
                            case HealthRegen:
                                applyHealthRegenBonus(enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} HEALTH_REGENERATION", enchant_amount);

                                break;
                            case SpellPenetration:
                                applySpellPenetrationBonus(enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} SPELL_PENETRATION", enchant_amount);

                                break;
                            case BlockValue:
                                handleBaseModFlatValue(BaseModGroup.ShieldBlockValue, enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} BLOCK_VALUE", enchant_amount);

                                break;
                            case MasteryRating:
                                applyRatingMod(CombatRating.mastery, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} MASTERY", enchant_amount);

                                break;
                            case Versatility:
                                applyRatingMod(CombatRating.VersatilityDamageDone, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.VersatilityHealingDone, (int) enchant_amount, apply);
                                applyRatingMod(CombatRating.VersatilityDamageTaken, (int) enchant_amount, apply);
                                Log.outDebug(LogFilter.player, "+ {0} VERSATILITY", enchant_amount);

                                break;
                            default:
                                break;
                        }

                        break;
                    }
                    case Totem: // Shaman Rockbiter Weapon
                    {
                        var attackType = getAttackBySlot(item.getSlot(), item.getTemplate().getInventoryType());

                        if (attackType != WeaponAttackType.max) {
                            updateDamageDoneMods(attackType, apply ? -1 : slot.getValue());
                        }

                        break;
                    }
                    case UseSpell:
                        // processed in player.CastItemUseSpell
                        break;
                    case PrismaticSocket:
                    case ArtifactPowerBonusRankByType:
                    case ArtifactPowerBonusRankByID:
                    case BonusListID:
                    case BonusListCurve:
                    case ArtifactPowerBonusRankPicker:
                        // nothing do..
                        break;
                    default:
                        Log.outError(LogFilter.player, "Unknown item enchantment (id = {0}) display type: {1}", enchant_id, enchant_display_type);

                        break;
                }
            }
        }

        // visualize enchantment at player and equipped items
        if (slot == EnchantmentSlot.Perm) {
            var visibleItem = getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().visibleItems, item.getSlot());
            setUpdateFieldValue(visibleItem.modifyValue(visibleItem.itemVisual), item.getVisibleItemVisual(this));
        }

        if (apply_dur) {
            if (apply) {
                // set duration
                var duration = item.getEnchantmentDuration(slot);

                if (duration > 0) {
                    addEnchantmentDuration(item, slot, duration);
                }
            } else {
                // duration == 0 will remove EnchantDuration
                addEnchantmentDuration(item, slot, 0);
            }
        }
    }

    public final void modifySkillBonus(SkillType skillid, int val, boolean talent) {
        modifySkillBonus((int) skillid.getValue(), val, talent);
    }


    public final void modifySkillBonus(int skillid, int val, boolean talent) {
        SkillInfo skillInfoField = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skillid);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfoField.skillRank.get(skillStatusData.pos) == 0) {
            return;
        }

        if (talent) {
            setSkillPermBonus(skillStatusData.pos, (short) (skillInfoField.skillPermBonus.get(skillStatusData.pos) + val));
        } else {
            setSkillTempBonus(skillStatusData.pos, (short) (skillInfoField.skillTempBonus.get(skillStatusData.pos) + val));
        }

        // Apply/Remove bonus to child skill lines
        var childSkillLines = global.getDB2Mgr().GetSkillLinesForParentSkill(skillid);

        if (childSkillLines != null) {
            for (var childSkillLine : childSkillLines) {
                modifySkillBonus(childSkillLine.id, val, talent);
            }
        }
    }

    public final void stopCastingBindSight() {
        var target = getViewpoint();

        if (target) {
            if (target.isType(TypeMask.unit)) {
                ((unit) target).removeAurasByType(AuraType.BindSight, getGUID());
                ((unit) target).removeAurasByType(AuraType.ModPossess, getGUID());
                ((unit) target).removeAurasByType(AuraType.ModPossessPet, getGUID());
            }
        }
    }

    public final void removeArenaEnchantments(EnchantmentSlot slot) {
        // remove enchantments from equipped items first to clean up the m_enchantDuration list
        for (var i = 0; i < enchantDurations.size(); ++i) {
            var enchantDuration = enchantDurations.get(i);

            if (enchantDuration.getSlot() == slot) {
                if (enchantDuration.getItem() && enchantDuration.getItem().getEnchantmentId(slot) != 0) {
                    // Poisons and DK runes are enchants which are allowed on arenas
                    if (global.getSpellMgr().isArenaAllowedEnchancment(enchantDuration.getItem().getEnchantmentId(slot))) {
                        continue;
                    }

                    // remove from stats
                    applyEnchantment(enchantDuration.getItem(), slot, false, false);
                    // remove visual
                    enchantDuration.getItem().clearEnchantment(slot);
                }

                // remove from update list
                enchantDurations.remove(enchantDuration);
            }
        }

        // remove enchants from inventory items
        // NOTE: no need to remove these from stats, since these aren't equipped
        // in inventory
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var i = InventorySlots.ItemStart; i < inventoryEnd; ++i) {
            var pItem = getItemByPos(InventorySlots.Bag0, i);

            if (pItem && !global.getSpellMgr().isArenaAllowedEnchancment(pItem.getEnchantmentId(slot))) {
                pItem.clearEnchantment(slot);
            }
        }

        // in inventory bags
        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; ++i) {
            var pBag = getBagByPos(i);

            if (pBag) {
                for (byte j = 0; j < pBag.getBagSize(); j++) {
                    var pItem = pBag.getItemByPos(j);

                    if (pItem && !global.getSpellMgr().isArenaAllowedEnchancment(pItem.getEnchantmentId(slot))) {
                        pItem.clearEnchantment(slot);
                    }
                }
            }
        }
    }


    public final void updatePotionCooldown() {
        updatePotionCooldown(null);
    }

    public final void updatePotionCooldown(Spell spell) {
        // no potion used i combat or still in combat
        if (lastPotionId == 0 || isInCombat()) {
            return;
        }

        // Call not from spell cast, send cooldown event for item spells if no in combat
        if (!spell) {
            // spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
            var proto = global.getObjectMgr().getItemTemplate(lastPotionId);

            if (proto != null) {
                for (byte idx = 0; idx < proto.getEffects().size(); ++idx) {
                    if (proto.getEffects().get(idx).spellID != 0 && proto.getEffects().get(idx).triggerType == ItemSpelltriggerType.OnUse) {
                        var spellInfo = global.getSpellMgr().getSpellInfo((int) proto.getEffects().get(idx).spellID, Difficulty.NONE);

                        if (spellInfo != null) {
                            getSpellHistory().sendCooldownEvent(spellInfo, lastPotionId);
                        }
                    }
                }
            }
        }
        // from spell cases (m_lastPotionId set in spell.SendSpellCooldown)
        else {
            if (spell.isIgnoringCooldowns()) {
                return;
            } else {
                getSpellHistory().sendCooldownEvent(spell.spellInfo, lastPotionId, spell);
            }
        }

        lastPotionId = 0;
    }

    public final boolean canUseMastery() {
        var chrSpec = CliDB.ChrSpecializationStorage.get(getPrimarySpecialization());

        if (chrSpec != null) {
            return hasSpell(chrSpec.MasterySpellID[0]) || hasSpell(chrSpec.MasterySpellID[1]);
        }

        return false;
    }

    public final boolean hasSkill(SkillType skill) {
        return hasSkill((int) skill.getValue());
    }


    public final boolean hasSkill(int skill) {
        if (skill == 0) {
            return false;
        }

        SkillInfo skillInfoField = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        return skillStatusData != null && skillStatusData.state != SkillState.Deleted && skillInfoField.skillRank.get(skillStatusData.pos) != 0;
    }


    public final void setSkill(SkillType skill, int step, int newVal, int maxVal) {
        setSkill((int) skill.getValue(), step, newVal, maxVal);
    }


    public final void setSkill(int id, int step, int newVal, int maxVal) {
        var skillEntry = CliDB.SkillLineStorage.get(id);

        if (skillEntry == null) {
            Log.outError(LogFilter.misc, String.format("Player.spells.SetSkill: Skillid: %1$s not found in SkillLineStorage for player %2$s (%3$s)", id, getName(), getGUID()));

            return;
        }

        short currVal;
        var skillStatusData = skillStatus.get(id);
        SkillInfo skillInfoField = getActivePlayerData().skill;

// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		void refreshSkillBonusAuras()
//			{
//				// Temporary bonuses
//				foreach (var effect in getAuraEffectsByType(AuraType.ModSkill))
//					if (effect.miscValue == id)
//						effect.handleEffect(this, AuraEffectHandleModes.skill, true);
//
//				foreach (var effect in getAuraEffectsByType(AuraType.ModSkill2))
//					if (effect.miscValue == id)
//						effect.handleEffect(this, AuraEffectHandleModes.skill, true);
//
//				// Permanent bonuses
//				foreach (var effect in getAuraEffectsByType(AuraType.ModSkillTalent))
//					if (effect.miscValue == id)
//						effect.handleEffect(this, AuraEffectHandleModes.skill, true);
//			}

        // Handle already stored skills
        if (skillStatusData != null) {
            currVal = skillInfoField.skillRank.get(skillStatusData.pos);

            // Activate and update skill line
            if (newVal != 0) {
                // if skill second is going down, update enchantments before setting the new second
                if (newVal < currVal) {
                    updateSkillEnchantments(id, currVal, (short) newVal);
                }

                // update step
                setSkillStep(skillStatusData.pos, (short) step);
                // update second
                setSkillRank(skillStatusData.pos, (short) newVal);
                setSkillMaxRank(skillStatusData.pos, (short) maxVal);

                learnSkillRewardedSpells(id, newVal, getRace());

                // if skill second is going up, update enchantments after setting the new second
                if (newVal > currVal) {
                    updateSkillEnchantments(id, currVal, (short) newVal);

                    if (id == (int) SkillType.Riding.getValue()) {
                        updateMountCapability();
                    }
                }

                updateCriteria(CriteriaType.SkillRaised, id);
                updateCriteria(CriteriaType.AchieveSkillStep, id);

                // update skill state
                if (skillStatusData.state == SkillState.Unchanged || skillStatusData.state == SkillState.Deleted) {
                    if (currVal == 0) // activated skill, mark as new to save into database
                    {
                        skillStatusData.state = SkillState.New;

                        // Set profession line
                        var freeProfessionSlot = findEmptyProfessionSlotFor(id);

                        if (freeProfessionSlot != -1) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
                            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().professionSkillLine, freeProfessionSlot), id);
                        }

                        refreshSkillBonusAuras();
                    } else // updated skill, mark as changed to save into database
                    {
                        skillStatusData.state = SkillState.changed;
                    }
                }
            } else if (currVal != 0 && newVal == 0) // Deactivate skill line
            {
                // Try to store profession tools and accessories into the bag
                // If we can't, we can't unlearn the profession
                var professionSlot = getProfessionSlotFor(id);

                if (professionSlot != -1) {
                    var professionSlotStart = (byte) (ProfessionSlots.Profession1Tool + professionSlot * ProfessionSlots.maxCount);

                    // Get all profession items equipped
                    for (byte slotOffset = 0; slotOffset < ProfessionSlots.maxCount; ++slotOffset) {
                        var professionItem = getItemByPos(InventorySlots.Bag0, (byte) (professionSlotStart + slotOffset));

                        if (professionItem != null) {
                            // Store item in bag
                            ArrayList<ItemPosCount> professionItemDest = new ArrayList<>();

                            if (canStoreItem(ItemConst.NullBag, ItemConst.NullSlot, professionItemDest, professionItem, false) != InventoryResult.Ok) {
                                sendPacket(new DisplayGameError(GameError.InvFull));

                                return;
                            }

                            removeItem(InventorySlots.Bag0, professionItem.getSlot(), true);
                            storeItem(professionItemDest, professionItem, true);
                        }
                    }

                    // Clear profession lines
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
                    setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().professionSkillLine, professionSlot), 0);
                }

                //remove enchantments needing this skill
                updateSkillEnchantments(id, currVal, (short) 0);
                // clear skill fields
                setSkillStep(skillStatusData.pos, (short) 0);
                setSkillRank(skillStatusData.pos, (short) 0);
                setSkillStartingRank(skillStatusData.pos, (short) 1);
                setSkillMaxRank(skillStatusData.pos, (short) 0);
                setSkillTempBonus(skillStatusData.pos, (short) 0);
                setSkillPermBonus(skillStatusData.pos, (short) 0);

                // mark as deleted so the next save will delete the data from the database
                skillStatusData.state = SkillState.Deleted;


                // remove all spells that related to this skill
                var skillLineAbilities = global.getDB2Mgr().GetSkillLineAbilitiesBySkill(id);

                for (var skillLineAbility : skillLineAbilities) {
                    removeSpell(global.getSpellMgr().getFirstSpellInChain(skillLineAbility.spell));
                }

                var childSkillLines = global.getDB2Mgr().GetSkillLinesForParentSkill(id);

                if (childSkillLines != null) {
                    for (var childSkillLine : childSkillLines) {
                        if (childSkillLine.ParentSkillLineID == id) {
                            setSkill(childSkillLine.id, 0, 0, 0);
                        }
                    }
                }
            }
        } else {
            // We are about to learn a skill that has been added outside of normal circumstances (Game Master command, scripts etc.)
            byte skillSlot = 0;

            // Find a free skill slot
            for (var i = 0; i < SkillConst.MaxPlayerSkills; ++i) {
                if (((SkillInfo) getActivePlayerData().skill).skillLineID.get(i) == 0) {
                    skillSlot = (byte) i;

                    break;
                }
            }

            if (skillSlot == 0) {
                Log.outError(LogFilter.misc, String.format("Tried to add skill %1$s but player %2$s (%3$s) cannot have additional skills", id, getName(), getGUID()));

                return;
            }

            if (skillEntry.ParentSkillLineID != 0) {
                if (skillEntry.ParentTierIndex > 0) {
                    var rcEntry = global.getDB2Mgr().GetSkillRaceClassInfo(skillEntry.ParentSkillLineID, getRace(), getClass());

                    if (rcEntry != null) {
                        var tier = global.getObjectMgr().getSkillTier(rcEntry.SkillTierID);

                        if (tier != null) {
                            var skillval = getPureSkillValue(SkillType.forValue(skillEntry.ParentSkillLineID));
                            setSkill(skillEntry.ParentSkillLineID, (int) skillEntry.ParentTierIndex, Math.max(skillval, (short) 1), tier.Value[skillEntry.ParentTierIndex - 1]);
                        }
                    }
                }
            } else {
                // also learn missing child skills at 0 second
                var childSkillLines = global.getDB2Mgr().GetSkillLinesForParentSkill(id);

                if (childSkillLines != null) {
                    for (var childSkillLine : childSkillLines) {
                        if (!hasSkill(SkillType.forValue(childSkillLine.id))) {
                            setSkill(childSkillLine.id, 0, 0, 0);
                        }
                    }
                }

                var freeProfessionSlot = findEmptyProfessionSlotFor(id);

                if (freeProfessionSlot != -1) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
                    setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().professionSkillLine, freeProfessionSlot), id);
                }
            }

            if (skillStatusData == null) {
                setSkillLineId(skillSlot, (short) id);
            }

            setSkillStep(skillSlot, (short) step);
            setSkillRank(skillSlot, (short) newVal);
            setSkillStartingRank(skillSlot, (short) 1);
            setSkillMaxRank(skillSlot, (short) maxVal);

            // apply skill bonuses
            setSkillTempBonus(skillSlot, (short) 0);
            setSkillPermBonus(skillSlot, (short) 0);

            updateSkillEnchantments(id, (short) 0, (short) newVal);

            skillStatus.put(id, new SkillStatusData(skillSlot, SkillState.New));

            if (newVal != 0) {
                refreshSkillBonusAuras();

                // Learn all spells for skill
                learnSkillRewardedSpells(id, newVal, getRace());
                updateCriteria(CriteriaType.SkillRaised, id);
                updateCriteria(CriteriaType.AchieveSkillStep, id);
            }
        }
    }

    public final boolean updateCraftSkill(SpellInfo spellInfo) {
        if (spellInfo.hasAttribute(SpellAttr1.NoSkillIncrease)) {
            return false;
        }

        Log.outDebug(LogFilter.player, "UpdateCraftSkill spellid {0}", spellInfo.getId());

        var bounds = global.getSpellMgr().getSkillLineAbilityMapBounds(spellInfo.getId());

        for (var _spell_idx : bounds) {
            if (_spell_idx.SkillupSkillLineID != 0) {
                int SkillValue = getPureSkillValue(SkillType.forValue(_spell_idx.SkillupSkillLineID));

                // Alchemy Discoveries here
                if (spellInfo.getMechanic() == mechanics.Discovery) {
                    var discoveredSpell = SkillDiscovery.getSkillDiscoverySpell(_spell_idx.SkillupSkillLineID, spellInfo.getId(), this);

                    if (discoveredSpell != 0) {
                        learnSpell(discoveredSpell, false);
                    }
                }

                var craft_skill_gain = _spell_idx.NumSkillUps * WorldConfig.getUIntValue(WorldCfg.SkillGainCrafting);

                return updateSkillPro(_spell_idx.SkillupSkillLineID, skillGainChance(SkillValue, _spell_idx.TrivialSkillLineRankHigh, (int) (_spell_idx.TrivialSkillLineRankHigh + _spell_idx.TrivialSkillLineRankLow) / 2, _spell_idx.TrivialSkillLineRankLow), craft_skill_gain);
            }
        }

        return false;
    }


    public final boolean updateGatherSkill(int skillId, int SkillValue, int RedLevel, int multiplicator) {
        return updateGatherSkill(skillId, SkillValue, RedLevel, multiplicator, null);
    }

    public final boolean updateGatherSkill(int skillId, int SkillValue, int RedLevel) {
        return updateGatherSkill(skillId, SkillValue, RedLevel, 1, null);
    }

    public final boolean updateGatherSkill(int skillId, int SkillValue, int RedLevel, int multiplicator, WorldObject obj) {
        return updateGatherSkill(SkillType.forValue(skillId), SkillValue, RedLevel, multiplicator, obj);
    }


    public final boolean updateGatherSkill(SkillType skillId, int SkillValue, int RedLevel, int multiplicator) {
        return updateGatherSkill(skillId, SkillValue, RedLevel, multiplicator, null);
    }

    public final boolean updateGatherSkill(SkillType skillId, int SkillValue, int RedLevel) {
        return updateGatherSkill(skillId, SkillValue, RedLevel, 1, null);
    }

    public final boolean updateGatherSkill(SkillType skillId, int SkillValue, int RedLevel, int multiplicator, WorldObject obj) {
        Log.outDebug(LogFilter.player, "UpdateGatherSkill(SkillId {0} SkillLevel {1} RedLevel {2})", skillId, SkillValue, RedLevel);

        var gathering_skill_gain = WorldConfig.getUIntValue(WorldCfg.SkillGainGathering);

        var grayLevel = RedLevel + 100;
        var greenLevel = RedLevel + 50;
        var yellowLevel = RedLevel + 25;

        var go = obj == null ? null : obj.toGameObject();

        if (go != null) {
            if (go.getTemplate().getTrivialSkillLow() != 0) {
                yellowLevel = go.getTemplate().getTrivialSkillLow();
            }

            if (go.getTemplate().getTrivialSkillHigh() != 0) {
                grayLevel = go.getTemplate().getTrivialSkillHigh();
            }

            greenLevel = (yellowLevel + grayLevel) / 2;
        }

        // For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
        switch (skillId) {
            case Herbalism:
            case ClassicHerbalism:
            case OutlandHerbalism:
            case NorthrendHerbalism:
            case CataclysmHerbalism:
            case PandariaHerbalism:
            case DraenorHerbalism:
            case LegionHerbalism:
            case KulTiranHerbalism:
            case Jewelcrafting:
            case Inscription:
            case DragonIslesHerbalism:
            case DragonIslesInscription:
            case DragonIslesJewelcrafting:
                return updateSkillPro(skillId, skillGainChance(SkillValue, grayLevel, greenLevel, yellowLevel) * multiplicator, gathering_skill_gain);
            case Skinning:
            case ClassicSkinning:
            case OutlandSkinning:
            case NorthrendSkinning:
            case CataclysmSkinning:
            case PandariaSkinning:
            case DraenorSkinning:
            case LegionSkinning:
            case KulTiranSkinning:
            case DragonIslesSkinning:
                if (WorldConfig.getIntValue(WorldCfg.SkillChanceSkinningSteps) == 0) {
                    return updateSkillPro(skillId, skillGainChance(SkillValue, grayLevel, greenLevel, yellowLevel) * multiplicator, gathering_skill_gain);
                } else {
                    return updateSkillPro(skillId, (skillGainChance(SkillValue, grayLevel, greenLevel, yellowLevel) * multiplicator) >> (SkillValue / WorldConfig.getIntValue(WorldCfg.SkillChanceSkinningSteps)), gathering_skill_gain);
                }
            case Mining:
            case ClassicMining:
            case OutlandMining:
            case NorthrendMining:
            case CataclysmMining:
            case PandariaMining:
            case DraenorMining:
            case LegionMining:
            case KulTiranMining:
            case DragonIslesMining:
                if (WorldConfig.getIntValue(WorldCfg.SkillChanceMiningSteps) == 0) {
                    return updateSkillPro(skillId, skillGainChance(SkillValue, grayLevel, greenLevel, yellowLevel) * multiplicator, gathering_skill_gain);
                } else {
                    return updateSkillPro(skillId, (skillGainChance(SkillValue, grayLevel, greenLevel, yellowLevel) * multiplicator) >> (SkillValue / WorldConfig.getIntValue(WorldCfg.SkillChanceMiningSteps)), gathering_skill_gain);
                }
        }

        return false;
    }

    public final boolean updateFishingSkill() {
        Log.outDebug(LogFilter.player, "UpdateFishingSkill");

        int SkillValue = getPureSkillValue(SkillType.ClassicFishing);

        if (SkillValue >= getMaxSkillValue(SkillType.ClassicFishing)) {
            return false;
        }

        var stepsNeededToLevelUp = getFishingStepsNeededToLevelUp(SkillValue);
        ++fishingSteps;

        if (fishingSteps >= stepsNeededToLevelUp) {
            fishingSteps = 0;

            var gathering_skill_gain = WorldConfig.getUIntValue(WorldCfg.SkillGainGathering);

            return updateSkillPro(SkillType.ClassicFishing, 100 * 10, gathering_skill_gain);
        }

        return false;
    }


    public final void castItemUseSpell(Item item, SpellCastTargets targets, ObjectGuid castCount, int[] misc) {
        if (!item.getTemplate().hasFlag(ItemFlags.legacy)) {
            // item spells casted at use
            for (var effectData : item.getEffects()) {
                // wrong triggering type
                if (effectData.triggerType != ItemSpelltriggerType.OnUse) {
                    continue;
                }

                var spellInfo = global.getSpellMgr().getSpellInfo((int) effectData.spellID, Difficulty.NONE);

                if (spellInfo == null) {
                    Log.outError(LogFilter.player, "Player.CastItemUseSpell: item (Entry: {0}) in have wrong spell id {1}, ignoring", item.getEntry(), effectData.spellID);

                    continue;
                }

                Spell spell = new spell(this, spellInfo, TriggerCastFlags.NONE);

                SpellPrepare spellPrepare = new SpellPrepare();
                spellPrepare.clientCastID = castCount;
                spellPrepare.serverCastID = spell.castId;
                sendPacket(spellPrepare);

                spell.fromClient = true;
                spell.castItem = item;
                spell.spellMisc.data0 = misc[0];
                spell.spellMisc.data1 = misc[1];
                spell.prepare(targets);

                return;
            }
        }

        // Item enchantments spells casted at use
        for (EnchantmentSlot e_slot = 0; e_slot.getValue() < EnchantmentSlot.max.getValue(); ++e_slot) {
            var enchant_id = item.getEnchantmentId(e_slot);
            var pEnchant = CliDB.SpellItemEnchantmentStorage.get(enchant_id);

            if (pEnchant == null) {
                continue;
            }

            for (byte s = 0; s < ItemConst.MaxItemEnchantmentEffects; ++s) {
                if (pEnchant.Effect[s] != ItemEnchantmentType.UseSpell) {
                    continue;
                }

                var spellInfo = global.getSpellMgr().getSpellInfo(pEnchant.EffectArg[s], Difficulty.NONE);

                if (spellInfo == null) {
                    Log.outError(LogFilter.player, "Player.CastItemUseSpell Enchant {0}, cast unknown spell {1}", enchant_id, pEnchant.EffectArg[s]);

                    continue;
                }

                Spell spell = new spell(this, spellInfo, TriggerCastFlags.NONE);

                SpellPrepare spellPrepare = new SpellPrepare();
                spellPrepare.clientCastID = castCount;
                spellPrepare.serverCastID = spell.castId;
                sendPacket(spellPrepare);

                spell.fromClient = true;
                spell.castItem = item;
                spell.spellMisc.data0 = misc[0];
                spell.spellMisc.data1 = misc[1];
                spell.prepare(targets);

                return;
            }
        }
    }


    public final int getLastPotionId() {
        return lastPotionId;
    }


    public final void setLastPotionId(int item_id) {
        lastPotionId = item_id;
    }


    public final void learnSkillRewardedSpells(int skillId, int skillValue, Race race) {
        var raceMask = SharedConst.GetMaskForRace(race);
        var classMask = getClassMask();

        var skillLineAbilities = global.getDB2Mgr().GetSkillLineAbilitiesBySkill(skillId);

        for (var ability : skillLineAbilities) {
            if (ability.skillLine != skillId) {
                continue;
            }

            var spellInfo = global.getSpellMgr().getSpellInfo(ability.spell, Difficulty.NONE);

            if (spellInfo == null) {
                continue;
            }

            switch (ability.AcquireMethod) {
                case OnSkillValue:
                case OnSkillLearn:
                    break;
                case RewardedFromQuest:
                    if (!ability.flags.hasFlag(SkillLineAbilityFlags.CanFallbackToLearnedOnSkillLearn) || !spellInfo.meetsFutureSpellPlayerCondition(this)) {
                        continue;
                    }

                    break;
                default:
                    continue;
            }

            // AcquireMethod == 2 && numSkillUps == 1 -. automatically learn riding skill spell, else we skip it (client shows riding in spellbook as trainable).
            if (skillId == (int) SkillType.Riding.getValue() && (ability.AcquireMethod != AbilityLearnType.OnSkillLearn || ability.numSkillUps != 1)) {
                continue;
            }

            // Check race if set
            if (ability.raceMask != 0 && !(boolean) (ability.raceMask & raceMask)) {
                continue;
            }

            // Check class if set
            if (ability.ClassMask != 0 && !(boolean) (ability.ClassMask & classMask)) {
                continue;
            }

            // check level, skip class spells if not high enough
            if (getLevel() < spellInfo.getSpellLevel()) {
                continue;
            }

            // need unlearn spell
            if (skillValue < ability.MinSkillLineRank && ability.AcquireMethod == AbilityLearnType.OnSkillValue) {
                removeSpell(ability.spell);
            }
            // need learn
            else if (!isInWorld()) {
                addSpell(ability.spell, true, true, true, false, false, ability.skillLine);
            } else {
                learnSpell(ability.spell, true, ability.skillLine);
            }
        }
    }


    public final int getProfessionSlotFor(int skillId) {
        var skillEntry = CliDB.SkillLineStorage.get(skillId);

        if (skillEntry == null) {
            return -1;
        }

        if (skillEntry.ParentSkillLineID == 0 || skillEntry.categoryID != SkillCategory.profession) {
            return -1;
        }

        var slot = 0;

        for (var bit : getActivePlayerData().professionSkillLine) {
            if (bit == skillId) {
                return slot;
            }

            slot++;
        }

        return -1;
    }


    public final boolean hasItemFitToSpellRequirements(SpellInfo spellInfo) {
        return hasItemFitToSpellRequirements(spellInfo, null);
    }

    public final boolean hasItemFitToSpellRequirements(SpellInfo spellInfo, Item ignoreItem) {
        if (spellInfo.getEquippedItemClass().getValue() < 0) {
            return true;
        }

        // scan other equipped items for same requirements (mostly 2 daggers/etc)
        // for optimize check 2 used cases only
        switch (spellInfo.getEquippedItemClass()) {
            case Weapon: {
                var item = getUseableItemByPos(InventorySlots.Bag0, EquipmentSlot.MainHand);

                if (item) {
                    if (item != ignoreItem && item.isFitToSpellRequirements(spellInfo)) {
                        return true;
                    }
                }

                item = getUseableItemByPos(InventorySlots.Bag0, EquipmentSlot.OffHand);

                if (item) {
                    if (item != ignoreItem && item.isFitToSpellRequirements(spellInfo)) {
                        return true;
                    }
                }

                break;
            }
            case Armor: {
                if (!spellInfo.hasAttribute(SpellAttr8.ArmorSpecialization)) {
                    // most used check: shield only
                    if ((spellInfo.getEquippedItemSubClassMask() & (1 << ItemSubClassArmor.Shield.getValue())) != 0) {
                        var item = getUseableItemByPos(InventorySlots.Bag0, EquipmentSlot.OffHand);

                        if (item != null) {
                            if (item != ignoreItem && item.isFitToSpellRequirements(spellInfo)) {
                                return true;
                            }
                        }

                        // special check to filter things like Shield Wall, the aura is not permanent and must stay even without required item
                        if (!spellInfo.isPassive()) {
                            for (var spellEffectInfo : spellInfo.getEffects()) {
                                if (spellEffectInfo.isAura()) {
                                    return true;
                                }
                            }
                        }
                    }

                    // tabard not have dependent spells
                    for (var i = EquipmentSlot.start; i < EquipmentSlot.MainHand; ++i) {
                        var item = getUseableItemByPos(InventorySlots.Bag0, i);

                        if (item) {
                            if (item != ignoreItem && item.isFitToSpellRequirements(spellInfo)) {
                                return true;
                            }
                        }
                    }
                } else {
                    // requires item equipped in all armor slots
                    for (var i : new byte[]{EquipmentSlot.Head, EquipmentSlot.Shoulders, EquipmentSlot.chest, EquipmentSlot.Waist, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Wrist, EquipmentSlot.Hands}) {
                        var item = getUseableItemByPos(InventorySlots.Bag0, i);

                        if (!item || item == ignoreItem || !item.isFitToSpellRequirements(spellInfo)) {
                            return false;
                        }
                    }

                    return true;
                }

                break;
            }
            default:
                Log.outError(LogFilter.player, "HasItemFitToSpellRequirements: Not handled spell requirement for item class {0}", spellInfo.getEquippedItemClass());

                break;
        }

        return false;
    }


    public final HashMap<Integer, PlayerSpell> getSpellMap() {
        return spells;
    }


    @Override
    public SpellSchoolMask getMeleeDamageSchoolMask() {
        return getMeleeDamageSchoolMask(WeaponAttackType.BaseAttack);
    }

    @Override
    public SpellSchoolMask getMeleeDamageSchoolMask(WeaponAttackType attackType) {
        var weapon = getWeaponForAttack(attackType, true);

        if (weapon != null) {
            return spellSchoolMask.forValue(1 << weapon.getTemplate().getDamageType());
        }

        return spellSchoolMask.NORMAL;
    }

    public final void updateAllWeaponDependentCritAuras() {
        for (var attackType = WeaponAttackType.BaseAttack; attackType.getValue() < WeaponAttackType.max.getValue(); ++attackType) {
            updateWeaponDependentCritAuras(attackType);
        }
    }

    public final void updateWeaponDependentAuras(WeaponAttackType attackType) {
        updateWeaponDependentCritAuras(attackType);
        updateDamageDoneMods(attackType);
        updateDamagePctDoneMods(attackType);
    }

    public final void applyItemDependentAuras(Item item, boolean apply) {
        if (apply) {
            var spells = getSpellMap();

            for (var pair : spells.entrySet()) {
                if (pair.getValue().state == PlayerSpellState.removed || pair.getValue().disabled) {
                    continue;
                }

                var spellInfo = global.getSpellMgr().getSpellInfo(pair.getKey(), Difficulty.NONE);

                if (spellInfo == null || !spellInfo.isPassive || spellInfo.equippedItemClass < 0) {
                    continue;
                }

                if (!hasAura(pair.getKey()) && hasItemFitToSpellRequirements(spellInfo)) {
                    addAura(pair.getKey(), this); // no SMSG_SPELL_GO in sniff found
                }
            }
        } else {
            removeItemDependentAurasAndCasts(item);
        }
    }

    @Override
    public boolean checkAttackFitToAuraRequirement(WeaponAttackType attackType, AuraEffect aurEff) {
        var spellInfo = aurEff.getSpellInfo();

        if (spellInfo.getEquippedItemClass() == itemClass.NONE) {
            return true;
        }

        var item = getWeaponForAttack(attackType, true);

        return item != null && item.isFitToSpellRequirements(spellInfo);
    }


    public final void addTemporarySpell(int spellId) {
        var spell = spells.get(spellId);

        // spell already added - do not do anything
        if (spell != null) {
            return;
        }

        PlayerSpell newspell = new PlayerSpell();
        newspell.state = PlayerSpellState.Temporary;
        newspell.active = true;
        newspell.dependent = false;
        newspell.disabled = false;

        spells.put(spellId, newspell);
    }


    public final void removeTemporarySpell(int spellId) {
        var spell = spells.get(spellId);

        // spell already not in list - do not do anything
        if (spell == null) {
            return;
        }

        // spell has other state than temporary - do not change it
        if (spell.state != PlayerSpellState.Temporary) {
            return;
        }

        spells.remove(spellId);
    }


    public final void updateZoneDependentAuras(int newZone) {
        // Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone.area update
        var saBounds = global.getSpellMgr().getSpellAreaForAreaMapBounds(newZone);

        for (var spell : saBounds) {
            if (spell.flags.hasFlag(SpellAreaFlag.AutoCast) && spell.isFitToRequirements(this, newZone, 0)) {
                if (!hasAura(spell.spellId)) {
                    castSpell(this, spell.spellId, true);
                }
            }
        }
    }


    public final void updateAreaDependentAuras(int newArea) {
        // remove auras from spells with area limitations
        // use m_zoneUpdateId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneUpdateId up-to-date
        getOwnedAurasList().CallOnMatch((aura) -> aura.spellInfo.checkLocation(getLocation().getMapId(), zoneUpdateId, newArea, this) != SpellCastResult.SpellCastOk, (pair) -> removeOwnedAura(pair.spellInfo.id, pair));

        // some auras applied at subzone enter
        var saBounds = global.getSpellMgr().getSpellAreaForAreaMapBounds(newArea);

        for (var spell : saBounds) {
            if (spell.flags.hasFlag(SpellAreaFlag.AutoCast) && spell.isFitToRequirements(this, zoneUpdateId, newArea)) {
                if (!hasAura(spell.spellId)) {
                    castSpell(this, spell.spellId, true);
                }
            }
        }
    }

    public final void applyModToSpell(SpellModifier mod, Spell spell) {
        if (spell == null) {
            return;
        }

        // don't do anything with no charges
        if (mod.getOwnerAura().isUsingCharges() && mod.getOwnerAura().getCharges() == 0) {
            return;
        }

        // register inside spell, proc system uses this to drop charges
        spell.appliedMods.add(mod.getOwnerAura());
    }

    public final void learnCustomSpells() {
        //if (!WorldConfig.getBoolValue(WorldCfg.StartAllSpells)) // this is not all spells, just custom ones.
        //    return;

        // learn default race/class spells
        var info = global.getObjectMgr().getPlayerInfo(getRace(), getClass());

        for (var tspell : info.getCustomSpells()) {
            Log.outDebug(LogFilter.player, "PLAYER (Class: {0} Race: {1}): Adding initial spell, id = {2}", getClass(), getRace(), tspell);

            if (!isInWorld()) // will send in INITIAL_SPELLS in list anyway at map add
            {
                addSpell(tspell, true, true, true, false);
            } else // but send in normal spell in game learn case
            {
                learnSpell(tspell, true);
            }
        }
    }

    public final void learnDefaultSkills() {
        // learn default race/class skills
        var info = global.getObjectMgr().getPlayerInfo(getRace(), getClass());

        for (var rcInfo : info.getSkills()) {
            if (hasSkill(SkillType.forValue(rcInfo.SkillID))) {
                continue;
            }

            if (rcInfo.minLevel > getLevel()) {
                continue;
            }

            learnDefaultSkill(rcInfo);
        }
    }

    public final void learnDefaultSkill(SkillRaceClassInfoRecord rcInfo) {
        var skillId = SkillType.forValue(rcInfo.SkillID);

        switch (global.getSpellMgr().getSkillRangeType(rcInfo)) {
            case Language:
                setSkill(skillId, 0, 300, 300);

                break;
            case Level: {
                short skillValue = 1;
                var maxValue = getMaxSkillValueForLevel();

                if (rcInfo.flags.hasFlag(SkillRaceClassInfoFlags.AlwaysMaxValue)) {
                    skillValue = maxValue;
                } else if (getClass() == playerClass.Deathknight) {
                    skillValue = (short) Math.min(Math.max(1, (getLevel() - 1) * 5), maxValue);
                }

                setSkill(skillId, 0, skillValue, maxValue);

                break;
            }
            case Mono:
                setSkill(skillId, 0, 1, 1);

                break;
            case Rank: {
                var tier = global.getObjectMgr().getSkillTier(rcInfo.SkillTierID);
                var maxValue = (short) tier.Value[0];
                short skillValue = 1;

                if (rcInfo.flags.hasFlag(SkillRaceClassInfoFlags.AlwaysMaxValue)) {
                    skillValue = maxValue;
                } else if (getClass() == playerClass.Deathknight) {
                    skillValue = (short) Math.min(Math.max(1, (getLevel() - 1) * 5), maxValue);
                }

                setSkill(skillId, 1, skillValue, maxValue);

                break;
            }
            default:
                break;
        }
    }


    public final <T extends Enum> void learnSpell(T spellId, boolean dependent, int fromSkill, boolean suppressMessaging) {
        learnSpell(spellId, dependent, fromSkill, suppressMessaging, null);
    }

    public final <T extends Enum> void learnSpell(T spellId, boolean dependent, int fromSkill) {
        learnSpell(spellId, dependent, fromSkill, false, null);
    }

    public final <T extends Enum> void learnSpell(T spellId, boolean dependent) {
        learnSpell(spellId, dependent, 0, false, null);
    }

    // C# TO JAVA CONVERTER TASK: The C# 'struct' constraint has no equivalent in Java:
    public final <T extends Enum> void learnSpell(T spellId, boolean dependent, int fromSkill, boolean suppressMessaging, Integer traitDefinitionId) {
        learnSpell((int) spellId, dependent, fromSkill, suppressMessaging, traitDefinitionId);
    }


    public final void learnSpell(int spellId, boolean dependent, int fromSkill, boolean suppressMessaging) {
        learnSpell(spellId, dependent, fromSkill, suppressMessaging, null);
    }

    public final void learnSpell(int spellId, boolean dependent, int fromSkill) {
        learnSpell(spellId, dependent, fromSkill, false, null);
    }

    public final void learnSpell(int spellId, boolean dependent) {
        learnSpell(spellId, dependent, 0, false, null);
    }

    public final void learnSpell(int spellId, boolean dependent, int fromSkill, boolean suppressMessaging, Integer traitDefinitionId) {
        var spell = spells.get(spellId);

        var disabled = (spell != null) && spell.disabled;
        var active = !disabled || spell.active;
        var favorite = spell != null ? spell.Favorite : false;

        var learning = addSpell(spellId, active, true, dependent, false, false, fromSkill, favorite, traitDefinitionId);

        // prevent duplicated entires in spell book, also not send if not in world (loading)
        if (learning && isInWorld()) {
            LearnedSpells learnedSpells = new LearnedSpells();
            LearnedSpellInfo learnedSpellInfo = new LearnedSpellInfo();
            learnedSpellInfo.spellID = spellId;
            learnedSpellInfo.isFavorite = favorite;
            learnedSpellInfo.traitDefinitionID = traitDefinitionId;
            learnedSpells.suppressMessaging = suppressMessaging;
            learnedSpells.clientLearnedSpellData.add(learnedSpellInfo);
            sendPacket(learnedSpells);
        }

        // learn all disabled higher ranks and required spells (recursive)
        if (disabled) {
            var nextSpell = global.getSpellMgr().getNextSpellInChain(spellId);

            if (nextSpell != 0) {
                var spell = spells.get(nextSpell);

                if (spellId != 0 && spell.disabled) {
                    learnSpell(nextSpell, false, fromSkill);
                }
            }

            var spellsRequiringSpell = global.getSpellMgr().getSpellsRequiringSpellBounds(spellId);

            for (var id : spellsRequiringSpell) {
                var spell1 = spells.get(id);

                if (spell1 != null && spell1.disabled) {
                    learnSpell(id, false, fromSkill);
                }
            }
        } else {
            updateQuestObjectiveProgress(QuestObjectiveType.LearnSpell, (int) spellId, 1);
        }
    }


    public final <T extends Enum> void removeSpell(T spellId, boolean disabled, boolean learnLowRank) {
        removeSpell(spellId, disabled, learnLowRank, false);
    }

    public final <T extends Enum> void removeSpell(T spellId, boolean disabled) {
        removeSpell(spellId, disabled, true, false);
    }

    public final <T extends Enum> void removeSpell(T spellId) {
        removeSpell(spellId, false, true, false);
    }

    // C# TO JAVA CONVERTER TASK: The C# 'struct' constraint has no equivalent in Java:
    public final <T extends Enum> void removeSpell(T spellId, boolean disabled, boolean learnLowRank, boolean suppressMessaging) {
        removeSpell((int) spellId, disabled, learnLowRank, suppressMessaging);
    }


    public final void removeSpell(int spellId, boolean disabled, boolean learnLowRank) {
        removeSpell(spellId, disabled, learnLowRank, false);
    }

    public final void removeSpell(int spellId, boolean disabled) {
        removeSpell(spellId, disabled, true, false);
    }

    public final void removeSpell(int spellId) {
        removeSpell(spellId, false, true, false);
    }

    public final void removeSpell(int spellId, boolean disabled, boolean learnLowRank, boolean suppressMessaging) {
        var pSpell = spells.get(spellId);

        if (pSpell == null) {
            return;
        }

        if (pSpell.state == PlayerSpellState.removed || (disabled && pSpell.disabled) || pSpell.state == PlayerSpellState.Temporary) {
            return;
        }

        // unlearn non talent higher ranks (recursive)
        var nextSpell = global.getSpellMgr().getNextSpellInChain(spellId);

        if (nextSpell != 0) {
            var spellInfo1 = global.getSpellMgr().getSpellInfo(nextSpell, Difficulty.NONE);

            if (hasSpell(nextSpell) && !spellInfo1.hasAttribute(SpellCustomAttributes.IsTalent)) {
                removeSpell(nextSpell, disabled, false);
            }
        }

        //unlearn spells dependent from recently removed spells
        var spellsRequiringSpell = global.getSpellMgr().getSpellsRequiringSpellBounds(spellId);

        for (var id : spellsRequiringSpell) {
            removeSpell(id, disabled);
        }

        // re-search, it can be corrupted in prev loop
        pSpell = spells.get(spellId);

        if (pSpell == null) {
            return; // already unleared
        }

        var cur_active = pSpell.active;
        var cur_dependent = pSpell.dependent;

        if (disabled) {
            pSpell.disabled = disabled;

            if (pSpell.state != PlayerSpellState.New) {
                pSpell.state = PlayerSpellState.changed;
            }
        } else {
            if (pSpell.state == PlayerSpellState.New) {
                spells.remove(spellId);
            } else {
                pSpell.state = PlayerSpellState.removed;
            }
        }

        removeOwnedAura(spellId, getGUID());

        // remove pet auras
        for (var petAur : (global.getSpellMgr().getPetAuras(spellId) == null ? null : global.getSpellMgr().getPetAuras(spellId).values())) {
            removePetAura(petAur);
        }

        // update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
        var spellInfo = global.getSpellMgr().getSpellInfo(spellId, Difficulty.NONE);

        if (spellInfo != null && spellInfo.isPrimaryProfessionFirstRank()) {
            var freeProfs = getFreePrimaryProfessionPoints() + 1;

            if (freeProfs <= WorldConfig.getIntValue(WorldCfg.MaxPrimaryTradeSkill)) {
                setFreePrimaryProfessions(freeProfs);
            }
        }

        // remove dependent skill
        var spellLearnSkill = global.getSpellMgr().getSpellLearnSkill(spellId);

        if (spellLearnSkill != null) {
            var prev_spell = global.getSpellMgr().getPrevSpellInChain(spellId);

            if (prev_spell == 0) // first rank, remove skill
            {
                setSkill(spellLearnSkill.skill, 0, 0, 0);
            } else {
                // search prev. skill setting by spell ranks chain
                var prevSkill = global.getSpellMgr().getSpellLearnSkill(prev_spell);

                while (prevSkill == null && prev_spell != 0) {
                    prev_spell = global.getSpellMgr().getPrevSpellInChain(prev_spell);
                    prevSkill = global.getSpellMgr().getSpellLearnSkill(global.getSpellMgr().getFirstSpellInChain(prev_spell));
                }

                if (prevSkill == null) // not found prev skill setting, remove skill
                {
                    setSkill(spellLearnSkill.skill, 0, 0, 0);
                } else // set to prev. skill setting values
                {
                    int skill_value = getPureSkillValue(prevSkill.skill);
                    int skill_max_value = getPureMaxSkillValue(prevSkill.skill);

                    if (skill_value > prevSkill.value) {
                        skill_value = prevSkill.value;
                    }

                    int new_skill_max_value = prevSkill.maxvalue == 0 ? getMaxSkillValueForLevel() : prevSkill.maxvalue;

                    if (skill_max_value > new_skill_max_value) {
                        skill_max_value = new_skill_max_value;
                    }

                    setSkill(prevSkill.skill, prevSkill.step, skill_value, skill_max_value);
                }
            }
        }

        // remove dependent spells
        var spell_bounds = global.getSpellMgr().getSpellLearnSpellMapBounds(spellId);

        for (var spellNode : spell_bounds) {
            removeSpell(spellNode.spell, disabled);

            if (spellNode.overridesSpell != 0) {
                removeOverrideSpell(spellNode.overridesSpell, spellNode.spell);
            }
        }

        // activate lesser rank in spellbook/action bar, and cast it if need
        var prev_activate = false;

        var prev_id = global.getSpellMgr().getPrevSpellInChain(spellId);

        if (prev_id != 0) {
            // if ranked non-stackable spell: need activate lesser rank and update dendence state
            // No need to check for spellInfo != NULL here because if cur_active is true, then that means that the spell was already in m_spells, and only valid spells can be pushed there.
            if (cur_active && spellInfo.isRanked()) {
                // need manually update dependence state (learn spell ignore like attempts)
                var prevSpell = spells.get(prev_id);

                if (prevSpell != null) {
                    if (prevSpell.dependent != cur_dependent) {
                        prevSpell.dependent = cur_dependent;

                        if (prevSpell.state != PlayerSpellState.New) {
                            prevSpell.state = PlayerSpellState.changed;
                        }
                    }

                    // now re-learn if need re-activate
                    if (!prevSpell.active && learnLowRank) {
                        if (addSpell(prev_id, true, false, prevSpell.dependent, prevSpell.disabled)) {
                            // downgrade spell ranks in spellbook and action bar
                            sendSupercededSpell(spellId, prev_id);
                            prev_activate = true;
                        }
                    }
                }
            }
        }

        overrideSpells.remove(spellId);

        if (canTitanGrip) {
            if (spellInfo != null && spellInfo.isPassive() && spellInfo.hasEffect(SpellEffectName.TitanGrip)) {
                removeAura(titanGripPenaltySpellId);
                setCanTitanGrip(false);
            }
        }

        if (canDualWield) {
            if (spellInfo != null && spellInfo.isPassive() && spellInfo.hasEffect(SpellEffectName.DualWield)) {
                setCanDualWield(false);
            }
        }

        if (WorldConfig.getBoolValue(WorldCfg.OffhandCheckAtSpellUnlearn)) {
            autoUnequipOffhandIfNeed();
        }

        // remove from spell book if not replaced by lesser rank
        if (!prev_activate) {
            UnlearnedSpells unlearnedSpells = new UnlearnedSpells();
            unlearnedSpells.spellID.add(spellId);
            unlearnedSpells.suppressMessaging = suppressMessaging;
            sendPacket(unlearnedSpells);
        }
    }


    public final void setSpellFavorite(int spellId, boolean favorite) {
        var spell = spells.get(spellId);

        if (spell == null) {
            return;
        }

        spell.favorite = favorite;

        if (spell.state == PlayerSpellState.Unchanged) {
            spell.state = PlayerSpellState.changed;
        }
    }


    public final void addStoredAuraTeleportLocation(int spellId) {
        StoredAuraTeleportLocation storedLocation = new StoredAuraTeleportLocation();
        storedLocation.setLoc(new worldLocation(getLocation()));
        storedLocation.setCurrentState(StoredAuraTeleportLocation.state.changed);

        storedAuraTeleportLocations.put(spellId, storedLocation);
    }


    public final void removeStoredAuraTeleportLocation(int spellId) {
        var storedLocation = storedAuraTeleportLocations.get(spellId);

        if (storedLocation != null) {
            storedLocation.currentState = StoredAuraTeleportLocation.state.Deleted;
        }
    }


    public final WorldLocation getStoredAuraTeleportLocation(int spellId) {
        var auraLocation = storedAuraTeleportLocations.get(spellId);

        if (auraLocation != null) {
            return auraLocation.loc;
        }

        return null;
    }


    @Override
    public boolean hasSpell(int spellId) {
        var spell = spells.get(spellId);

        if (spell != null) {
            return spell.state != PlayerSpellState.removed && !spell.disabled;
        }

        return false;
    }


    public final boolean hasActiveSpell(int spellId) {
        var spell = spells.get(spellId);

        if (spell != null) {
            return spell.state != PlayerSpellState.removed && spell.active && !spell.disabled;
        }

        return false;
    }

    public final void addSpellMod(SpellModifier mod, boolean apply) {
        Log.outDebug(LogFilter.spells, "Player.AddSpellMod {0}", mod.getSpellId());

        // first, manipulate our spellmodifier container
        if (apply) {
            spellModifiers[mod.getOp().ordinal()][mod.getType().ordinal()].add(mod);
        } else {
            spellModifiers[mod.getOp().ordinal()][mod.getType().ordinal()].remove(mod);
        }

        // Now, send spellmodifier packet
        switch (mod.getType()) {
            case FLAT:
            case PCT:
                if (!isLoading()) {
                    var opcode = (mod.getType() == SpellModType.FLAT ? ServerOpCode.SetFlatSpellModifier : ServerOpcode.SetPctSpellModifier);
                    SetSpellModifier packet = new SetSpellModifier(opcode);

                    // @todo Implement sending of bulk modifiers instead of single
                    SpellModifierInfo spellMod = new SpellModifierInfo();

                    spellMod.modIndex = (byte) mod.getOp().ordinal();

                    for (var eff = 0; eff < 128; ++eff) {
                        FlagArray128 mask = new flagArray128();
                        mask.set(eff / 32, 1 << (eff % 32));

                        if ((mod instanceof SpellModifierByClassMask ? (SpellModifierByClassMask) mod : null).mask & mask) {
                            SpellModifierData modData = new SpellModifierData();

                            if (mod.getType() == SpellModType.Flat) {
                                modData.modifierValue = 0.0f;

                                for (SpellModifierByClassMask spell : spellModifiers[mod.getOp().ordinal()][SpellModType.Flat.getValue()]) {
                                    if (spell.mask & mask) {
                                        modData.modifierValue += spell.value;
                                    }
                                }
                            } else {
                                modData.modifierValue = 1.0f;

                                for (SpellModifierByClassMask spell : spellModifiers[mod.getOp().ordinal()][SpellModType.Pct.getValue()]) {
                                    if (spell.mask & mask) {
                                        modData.ModifierValue *= 1.0f + MathUtil.CalculatePct(1.0f, spell.value);
                                    }
                                }
                            }

                            modData.classIndex = (byte) eff;

                            spellMod.modifierData.add(modData);
                        }
                    }

                    packet.modifiers.add(spellMod);

                    sendPacket(packet);
                }

                break;
            case LABEL_FLAT:
                if (apply) {
                    addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().spellFlatModByLabel), (mod instanceof SpellFlatModifierByLabel ? (SpellFlatModifierByLabel) mod : null).value);
                } else {
                    var firstIndex = getActivePlayerData().spellFlatModByLabel.FindIndex((mod instanceof SpellFlatModifierByLabel ? (SpellFlatModifierByLabel) mod : null).value);

                    if (firstIndex >= 0) {
                        removeDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().spellFlatModByLabel), firstIndex);
                    }
                }

                break;
            case LABEL_PCT:
                if (apply) {
                    addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().spellPctModByLabel), (mod instanceof SpellPctModifierByLabel ? (SpellPctModifierByLabel) mod : null).value);
                } else {
                    var firstIndex = getActivePlayerData().spellPctModByLabel.FindIndex((mod instanceof SpellPctModifierByLabel ? (SpellPctModifierByLabel) mod : null).value);

                    if (firstIndex >= 0) {
                        removeDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().spellPctModByLabel), firstIndex);
                    }
                }

                break;
        }
    }


    public final int applySpellMod(SpellInfo spellInfo, SpellModOp op, int basevalue) {
        return applySpellMod(spellInfo, op, basevalue, null);
    }

    public final int applySpellMod(SpellInfo spellInfo, SpellModOp op, int baseValue, Spell spell) {
        double val = applySpellMod(spellInfo, op, (double) baseValue, spell);
        return (int) Math.round(val);
    }

    public final double applySpellMod(SpellInfo spellInfo, SpellModOp op, double baseValue) {
        return applySpellMod(spellInfo, op, baseValue, null);
    }

    public final double applySpellMod(SpellInfo spellInfo, SpellModOp op, double baseValue, Spell spell) {
        SpellModValue values = getSpellModValues(spellInfo, op, spell, baseValue);
        return (baseValue + values.flat()) * values.pct();
    }

    public final SpellModValue getSpellModValues(SpellInfo spellInfo, SpellModOp op, Spell spell, double baseValue) {

        double flat = 0;
        double pct = 1.0;

        // Drop charges for triggering spells instead of triggered ones
        if (this.spellModTakingSpell != null) {
            spell = this.spellModTakingSpell;
        }

        switch (op) {
            // special case, if a mod makes spell instant, only consume that mod
            case ChangeCastTime: {
                SpellModifier modInstantSpell = null;

                for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.PCT.ordinal()]) {
                    SpellModifierByClassMask mod = (SpellModifierByClassMask) item;
                    if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                        continue;
                    }

                    if (baseValue - 10000d < 0 && mod.value <= -100) {
                        modInstantSpell = mod;

                        break;
                    }
                }

                if (modInstantSpell == null) {
                    for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.LABEL_PCT.ordinal()]) {
                        SpellPctModifierByLabel mod = (SpellPctModifierByLabel) item;
                        if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                            continue;
                        }

                        if (baseValue - 10000d < 0 && mod.value.modifierValue <= -1.0f) {
                            modInstantSpell = mod;

                            break;
                        }
                    }
                }

                if (modInstantSpell != null) {
                    applyModToSpell(modInstantSpell, spell);
                    pct = 0.0f;

                    return new SpellModValue(flat, pct);
                }

                break;
            }
            // special case if two mods apply 100% critical chance, only consume one
            case CritChance: {
                SpellModifier modCritical = null;

                for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.FLAT.ordinal()]) {
                    SpellModifierByClassMask mod = (SpellModifierByClassMask) item;
                    if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                        continue;
                    }

                    if (mod.value >= 100) {
                        modCritical = mod;

                        break;
                    }
                }

                if (modCritical == null) {
                    for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.LABEL_FLAT.ordinal()]) {
                        SpellPctModifierByLabel mod = (SpellPctModifierByLabel) item;
                        if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                            continue;
                        }

                        if (mod.value.modifierValue >= 100) {
                            modCritical = mod;

                            break;
                        }
                    }
                }

                if (modCritical != null) {
                    applyModToSpell(modCritical, spell);
                    flat = 100;

                    return new SpellModValue(flat, pct);
                }

                break;
            }
            default:
                break;
        }

        for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.FLAT.ordinal()]) {
            SpellModifierByClassMask mod = (SpellModifierByClassMask) item;
            if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                continue;
            }

            var value = mod.value;

            if (value == 0) {
                continue;
            }

            flat += value;
            applyModToSpell(mod, spell);
        }

        for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.LABEL_FLAT.ordinal()]) {
            SpellPctModifierByLabel mod = (SpellPctModifierByLabel) item;
            if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                continue;
            }

            var value = mod.value.modifierValue;

            if (value == 0) {
                continue;
            }

            flat += value;
            applyModToSpell(mod, spell);
        }

        for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.PCT.ordinal()]) {
            SpellModifierByClassMask mod = (SpellModifierByClassMask) item;
            if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                continue;
            }

            // skip percent mods for null basevalue (most important for spell mods with charges)
            if (baseValue + flat == 0) {
                continue;
            }

            var value = mod.value;

            if (value == 0) {
                continue;
            }

            // special case (skip > 10sec spell casts for instant cast setting)
            if (op == SpellModOp.ChangeCastTime) {
                if (baseValue - 10000d > 0 && value <= -100) {
                    continue;
                }
            }

            pct *= 1.0f + MathUtil.calculatePct(1.0f, value);
            applyModToSpell(mod, spell);
        }

        for (SpellModifier item : spellModifiers[op.ordinal()][SpellModType.LABEL_PCT.ordinal()]) {
            SpellPctModifierByLabel mod = (SpellPctModifierByLabel) item;
            if (!isAffectedBySpellmod(spellInfo, mod, spell)) {
                continue;
            }

            // skip percent mods for null basevalue (most important for spell mods with charges)
            if (baseValue + flat == 0) {
                continue;
            }

            double value = mod.value.modifierValue;

            if (value == 1.0d) {
                continue;
            }

            // special case (skip > 10sec spell casts for instant cast setting)
            if (op == SpellModOp.ChangeCastTime) {
                if (baseValue - 10000d > 0 && value <= -1.0f) {
                    continue;
                }
            }

            pct *= value;
            applyModToSpell(mod, spell);
        }
        return new SpellModValue(flat, pct);
    }

    public final void setSpellModTakingSpell(Spell spell, boolean apply) {
        if (apply && getSpellModTakingSpell() != null) {
            return;
        }

        if (!apply && (getSpellModTakingSpell() == null || getSpellModTakingSpell() != spell)) {
            return;
        }

        setSpellModTakingSpell(apply ? spell : null);
    }

    public final void updateEquipSpellsAtFormChange() {
        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] && !_items[i].isBroken() && canUseAttackType(getAttackBySlot(i, _items[i].getTemplate().getInventoryType()))) {
                applyItemEquipSpell(_items[i], false, true); // remove spells that not fit to form
                applyItemEquipSpell(_items[i], true, true); // add spells that fit form but not active
            }
        }

        updateItemSetAuras(true);
    }

    public final int getSpellPenetrationItemMod() {
        return spellPenetrationItemMod;
    }

    public final void removeArenaSpellCooldowns(boolean removeActivePetCooldowns) {
        // remove cooldowns on spells that have < 10 min CD
        getSpellHistory().resetCooldowns(p ->
        {
            var spellInfo = global.getSpellMgr().getSpellInfo(p.key, Difficulty.NONE);

            return spellInfo.recoveryTime < 10 * time.Minute * time.InMilliseconds && spellInfo.categoryRecoveryTime < 10 * time.Minute * time.InMilliseconds && !spellInfo.hasAttribute(SpellAttr6.DoNotResetCooldownInArena);
        }, true);

        // pet cooldowns
        if (removeActivePetCooldowns) {
            var pet = getCurrentPet();

            if (pet) {
                pet.getSpellHistory().resetAllCooldowns();
            }
        }
    }

    /**********************************/
    /*************Runes****************/
    /**********************************/
    public final void setRuneCooldown(byte index, int cooldown) {
        runes.getCooldown()[index] = cooldown;
        runes.setRuneState(index, (cooldown == 0));
        var activeRunes = runes.getCooldown().count(p -> p == 0);

        if (activeRunes != getPower(powerType.runes)) {
            setPower(powerType.runes, activeRunes);
        }
    }


    public final byte getRunesState() {
        return (byte) (runes.getRuneState() & ((1 << getMaxPower(powerType.runes)) - 1));
    }


    public final int getRuneBaseCooldown() {
        double cooldown = RuneCooldowns.base;

        var regenAura = getAuraEffectsByType(AuraType.ModPowerRegenPercent);

        for (var i : regenAura) {
            if (i.getMiscValue() == powerType.runes.getValue()) {
                cooldown *= 1.0f - i.getAmount() / 100.0f;
            }
        }

        // Runes cooldown are now affected by player's haste from equipment ...
        var hastePct = getRatingBonusValue(CombatRating.HasteMelee);

        // ... and some auras.
        hastePct += getTotalAuraModifier(AuraType.ModMeleeHaste);
        hastePct += getTotalAuraModifier(AuraType.ModMeleeHaste2);
        hastePct += getTotalAuraModifier(AuraType.ModMeleeHaste3);

        cooldown *= 1.0f - (hastePct / 100.0f);

        return (int) cooldown;
    }

    public final void resyncRunes() {
        var maxRunes = getMaxPower(powerType.runes);

        ResyncRunes data = new resyncRunes();
        data.runes.start = (byte) ((1 << maxRunes) - 1);
        data.runes.count = getRunesState();

        float baseCd = getRuneBaseCooldown();

        for (byte i = 0; i < maxRunes; ++i) {
            data.runes.cooldowns.add((byte) ((baseCd - getRuneCooldown(i)) / baseCd * 255));
        }

        sendPacket(data);
    }

    public final void initRunes() {
        if (getClass() != playerClass.Deathknight) {
            return;
        }

        var runeIndex = getPowerIndex(powerType.runes);

        if (runeIndex == powerType.max.getValue()) {
            return;
        }

        runes = new runes();
        runes.setRuneState(0);

        for (byte i = 0; i < PlayerConst.MaxRunes; ++i) {
            setRuneCooldown(i, 0); // reset cooldowns
        }

        // set a base regen timer equal to 10 sec
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().powerRegenFlatModifier, (int) runeIndex), 0.0f);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().powerRegenInterruptedFlatModifier, (int) runeIndex), 0.0f);
    }

    public final void updateAllRunesRegen() {
        if (getClass() != playerClass.Deathknight) {
            return;
        }

        var runeIndex = getPowerIndex(powerType.runes);

        if (runeIndex == powerType.max.getValue()) {
            return;
        }

        var runeEntry = global.getDB2Mgr().GetPowerTypeEntry(powerType.runes);

        var cooldown = getRuneBaseCooldown();
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().powerRegenFlatModifier, (int) runeIndex), (float) (1 * time.InMilliseconds) / cooldown - runeEntry.RegenPeace);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().powerRegenInterruptedFlatModifier, (int) runeIndex), (float) (1 * time.InMilliseconds) / cooldown - runeEntry.RegenCombat);
    }


    public final int getRuneCooldown(byte index) {
        return runes.getCooldown()[index];
    }

    public final boolean canNoReagentCast(SpellInfo spellInfo) {
        // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
        if (spellInfo.hasAttribute(SpellAttr5.NoReagentCostWithAura) && hasUnitFlag(UnitFlag.preparation)) {
            return true;
        }

        // Check no reagent use mask
        FlagArray128 noReagentMask = new flagArray128();
        noReagentMask.set(0, getActivePlayerData().noReagentCostMask.get(0));
        noReagentMask.set(1, getActivePlayerData().noReagentCostMask.get(1));
        noReagentMask.set(2, getActivePlayerData().noReagentCostMask.get(2));
        noReagentMask.set(3, getActivePlayerData().noReagentCostMask.get(3));

        return spellInfo.getSpellFamilyFlags() & noReagentMask;
    }

    public final void setNoRegentCostMask(FlagArray128 mask) {
        for (byte i = 0; i < 4; ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().noReagentCostMask, i), mask.get(i));
        }
    }

    public final void castItemCombatSpell(DamageInfo damageInfo) {
        var target = damageInfo.getVictim();

        if (target == null || !target.isAlive() || target == this) {
            return;
        }

        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
            // If usable, try to cast item spell
            var item = getItemByPos(InventorySlots.Bag0, i);

            if (item != null) {
                if (!item.isBroken() && canUseAttackType(damageInfo.getAttackType())) {
                    var proto = item.getTemplate();

                    if (proto != null) {
                        // Additional check for weapons
                        if (proto.getClass() == itemClass.Weapon) {
                            // offhand item cannot proc from main hand hit etc
                            byte slot;

                            switch (damageInfo.getAttackType()) {
                                case BaseAttack:
                                case RangedAttack:
                                    slot = EquipmentSlot.MainHand;

                                    break;
                                case OffAttack:
                                    slot = EquipmentSlot.OffHand;

                                    break;
                                default:
                                    slot = EquipmentSlot.End;

                                    break;
                            }

                            if (slot != i) {
                                continue;
                            }

                            // Check if item is useable (forms or disarm)
                            if (damageInfo.getAttackType() == WeaponAttackType.BaseAttack) {
                                if (!isUseEquipedWeapon(true) && !isInFeralForm()) {
                                    continue;
                                }
                            }
                        }

                        castItemCombatSpell(damageInfo, item, proto);
                    }
                }
            }
        }
    }

    public final void castItemCombatSpell(DamageInfo damageInfo, Item item, ItemTemplate proto) {
        // Can do effect if any damage done to target
        // for done procs allow normal + critical + absorbs by default
        var canTrigger = damageInfo.getHitMask().hasFlag(ProcFlagsHit.NORMAL.getValue() | ProcFlagsHit.critical.getValue().getValue() | ProcFlagsHit.absorb.getValue().getValue());

        if (canTrigger) {
            if (!item.getTemplate().hasFlag(ItemFlags.legacy)) {
                for (var effectData : item.getEffects()) {
                    // wrong triggering type
                    if (effectData.triggerType != ItemSpelltriggerType.OnProc) {
                        continue;
                    }

                    var spellInfo = global.getSpellMgr().getSpellInfo((int) effectData.spellID, Difficulty.NONE);

                    if (spellInfo == null) {
                        Log.outError(LogFilter.player, "WORLD: unknown Item spellid {0}", effectData.spellID);

                        continue;
                    }

                    float chance = spellInfo.getProcChance();

                    if (proto.getSpellPPMRate() != 0) {
                        var WeaponSpeed = getBaseAttackTime(damageInfo.getAttackType());
                        chance = getPPMProcChance(WeaponSpeed, proto.getSpellPPMRate(), spellInfo);
                    } else if (chance > 100.0f) {
                        chance = getWeaponProcChance();
                    }

                    if (RandomUtil.randChance(chance) && global.getScriptMgr().<IItemOnCastItemCombatSpell>RunScriptRet(tmpscript -> tmpscript.OnCastItemCombatSpell(this, damageInfo.getVictim(), spellInfo, item), item.getScriptId())) {
                        castSpell(damageInfo.getVictim(), spellInfo.getId(), item);
                    }
                }
            }
        }

        // item combat enchantments
        for (byte e_slot = 0; e_slot < (byte) EnchantmentSlot.max.getValue(); ++e_slot) {
            var enchant_id = item.getEnchantmentId(EnchantmentSlot.forValue(e_slot));
            var pEnchant = CliDB.SpellItemEnchantmentStorage.get(enchant_id);

            if (pEnchant == null) {
                continue;
            }

            for (byte s = 0; s < ItemConst.MaxItemEnchantmentEffects; ++s) {
                if (pEnchant.Effect[s] != ItemEnchantmentType.CombatSpell) {
                    continue;
                }

                var entry = global.getSpellMgr().getSpellEnchantProcEvent(enchant_id);

                if (entry != null && entry.hitMask != 0) {
                    // Check hit/crit/dodge/parry requirement
                    if ((entry.hitMask & (int) damageInfo.getHitMask().getValue()) == 0) {
                        continue;
                    }
                } else {
                    // for done procs allow normal + critical + absorbs by default
                    if (!canTrigger) {
                        continue;
                    }
                }

                // check if enchant procs only on white hits
                if (entry != null && entry.attributesMask.hasFlag(EnchantProcAttributes.WhiteHit) && damageInfo.getSpellInfo() != null) {
                    continue;
                }

                var spellInfo = global.getSpellMgr().getSpellInfo(pEnchant.EffectArg[s], Difficulty.NONE);

                if (spellInfo == null) {
                    Log.outError(LogFilter.player, "Player.castItemCombatSpell(GUID: {0}, name: {1}, enchant: {2}): unknown spell {3} is casted, ignoring...", getGUID().toString(), getName(), enchant_id, pEnchant.EffectArg[s]);

                    continue;
                }

                var chance = pEnchant.EffectPointsMin[s] != 0 ? pEnchant.EffectPointsMin[s] : getWeaponProcChance();

                if (entry != null) {
                    if (entry.procsPerMinute != 0) {
                        chance = getPPMProcChance(proto.getDelay(), entry.procsPerMinute, spellInfo);
                    } else if (entry.chance != 0) {
                        chance = entry.chance;
                    }
                }

                // Apply spell mods
                tangible.RefObject<Float> tempRef_chance = new tangible.RefObject<Float>(chance);
                applySpellMod(spellInfo, SpellModOp.procChance, tempRef_chance);
                chance = tempRef_chance.refArgValue;

                // Shiv has 100% chance to apply the poison
                if (findCurrentSpellBySpellId(5938) != null && e_slot == (byte) EnchantmentSlot.Temp.getValue()) {
                    chance = 100.0f;
                }

                if (RandomUtil.randChance(chance)) {
                    if (spellInfo.IsPositive) {
                        castSpell(this, spellInfo.id, item);
                    } else {
                        castSpell(damageInfo.getVictim(), spellInfo.id, item);
                    }
                }

                if (RandomUtil.randChance(chance)) {
                    var target = spellInfo.IsPositive ? this : damageInfo.getVictim();

                    CastSpellExtraArgs args = new CastSpellExtraArgs(item);

                    // reduce effect values if enchant is limited
                    if (entry != null && entry.attributesMask.hasFlag(EnchantProcAttributes.Limit60) && target.getLevelForTarget(this) > 60) {
                        var lvlDifference = target.getLevelForTarget(this) - 60;
                        var lvlPenaltyFactor = 4; // 4% lost effectiveness per level

                        var effectPct = Math.max(0, 100 - (lvlDifference * lvlPenaltyFactor));

                        for (var spellEffectInfo : spellInfo.effects) {
                            if (spellEffectInfo.isEffect()) {
                                args.addSpellMod(SpellValueMod.BasePoint0 + spellEffectInfo.effectIndex, MathUtil.CalculatePct(spellEffectInfo.calcValue(this), effectPct));
                            }
                        }
                    }

                    castSpell(target, spellInfo.id, args);
                }
            }
        }
    }


    public final void resetSpells() {
        resetSpells(false);
    }

    public final void resetSpells(boolean myClassOnly) {
        // not need after this call
        if (hasAtLoginFlag(AtLoginFlags.ResetSpells)) {
            removeAtLoginFlag(AtLoginFlags.ResetSpells, true);
        }

        // make full copy of map (spells removed and marked as deleted at another spell remove
        // and we can't use original map for safe iterative with visit each spell at loop end
        var smap = getSpellMap();

        int family;

        if (myClassOnly) {
            var clsEntry = CliDB.ChrClassesStorage.get(getClass());

            if (clsEntry == null) {
                return;
            }

            family = clsEntry.SpellClassSet;

            for (var spellId : smap.keySet()) {
                var spellInfo = global.getSpellMgr().getSpellInfo(spellId, Difficulty.NONE);

                if (spellInfo == null) {
                    continue;
                }

                // skip server-side/triggered spells
                if (spellInfo.spellLevel == 0) {
                    continue;
                }

                // skip wrong class/race skills
                if (!isSpellFitByClassAndRace(spellInfo.id)) {
                    continue;
                }

                // skip other spell families
                if ((int) spellInfo.spellFamilyName != family) {
                    continue;
                }

                // skip broken spells
                if (!global.getSpellMgr().isSpellValid(spellInfo, this, false)) {
                    continue;
                }
            }
        } else {
            for (var spellId : smap.keySet()) {
                removeSpell(spellId, false, false); // only iter.first can be accessed, object by iter.second can be deleted already
            }
        }

        learnDefaultSkills();
        learnCustomSpells();
        learnQuestRewardedSpells();
    }


    public final void setPetSpellPower(int spellPower) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().petSpellPower), spellPower);
    }


    public final void setSkillLineId(int pos, short skillLineId) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillLineID, (int) pos), skillLineId);
    }


    public final void setSkillStep(int pos, short step) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillStep, (int) pos), step);
    }


    public final void setSkillRank(int pos, short rank) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillRank, (int) pos), rank);
    }


    public final void setSkillStartingRank(int pos, short starting) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillStartingRank, (int) pos), starting);
    }


    public final void setSkillMaxRank(int pos, short max) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillMaxRank, (int) pos), max);
    }


    public final void setSkillTempBonus(int pos, short bonus) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillTempBonus, (int) pos), bonus);
    }


    public final void setSkillPermBonus(int pos, short bonus) {
        SkillInfo skillInfo = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().skill);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref skillInfo.modifyValue(skillInfo.skillPermBonus, (int) pos), bonus);
    }


    private short getMaxSkillValue(SkillType skill) {
        if (skill == 0) {
            return 0;
        }

        SkillInfo skillInfo = getActivePlayerData().skill;

        var skillStatusData = skillStatus.get(skill);

        if (skillStatusData == null || skillStatusData.state == SkillState.Deleted || skillInfo.skillRank.get(skillStatusData.pos) == 0) {
            return 0;
        }

        int result = skillInfo.skillMaxRank.get(skillStatusData.pos);
        result += skillInfo.skillTempBonus.get(skillStatusData.pos);
        result += skillInfo.skillPermBonus.get(skillStatusData.pos);

        return (short) (result < 0 ? 0 : result);
    }

    private void initializeSelfResurrectionSpells() {
        clearSelfResSpell();

        var spells = new int[3];

        var dummyAuras = getAuraEffectsByType(AuraType.DUMMY);

        for (var auraEffect : dummyAuras) {
            // Soulstone Resurrection                           // prio: 3 (max, non death persistent)
            if (auraEffect.getSpellInfo().getSpellFamilyName() == SpellFamilyNames.Warlock && auraEffect.getSpellInfo().getSpellFamilyFlags().get(1).hasFlag(0x1000000)) {
                spells[0] = 3026;
            }
            // Twisting Nether                                  // prio: 2 (max)
            else if (auraEffect.getId() == 23701 && RandomUtil.randChance(10)) {
                spells[1] = 23700;
            }
        }

        // Reincarnation (passive spell)  // prio: 1
        if (hasSpell(20608) && !getSpellHistory().hasCooldown(21169)) {
            spells[2] = 21169;
        }

        for (var selfResSpell : spells) {
            if (selfResSpell != 0) {
                addSelfResSpell(selfResSpell);
            }
        }
    }

    private void removeSpecializationSpells() {
        for (int i = 0; i < PlayerConst.MaxSpecializations; ++i) {
            var specialization = global.getDB2Mgr().GetChrSpecializationByIndex(getClass(), i);

            if (specialization != null) {
                var specSpells = global.getDB2Mgr().GetSpecializationSpells(specialization.id);

                if (specSpells != null) {
                    for (var j = 0; j < specSpells.size(); ++j) {
                        var specSpell = specSpells.get(j);
                        removeSpell(specSpell.spellID, true);

                        if (specSpell.OverridesSpellID != 0) {
                            removeOverrideSpell(specSpell.OverridesSpellID, specSpell.spellID);
                        }
                    }
                }

                for (int j = 0; j < PlayerConst.MaxMasterySpells; ++j) {
                    var mastery = specialization.MasterySpellID[j];

                    if (mastery != 0) {
                        removeAura(mastery);
                    }
                }
            }
        }
    }

    private void initializeSkillFields() {
        int i = 0;

        for (var skillLine : CliDB.SkillLineStorage.values()) {
            var rcEntry = global.getDB2Mgr().GetSkillRaceClassInfo(skillLine.id, getRace(), getClass());

            if (rcEntry != null) {
                setSkillLineId(i, (short) skillLine.id);
                setSkillStartingRank(i, (short) 1);
                skillStatus.put(skillLine.id, new SkillStatusData(i, SkillState.Unchanged));

                if (++i >= SkillConst.MaxPlayerSkills) {
                    break;
                }
            }
        }
    }


    private void updateSkillEnchantments(int skill_id, short curr_value, short new_value) {
        for (byte i = 0; i < InventorySlots.BagEnd; ++i) {
            if (_items[i] != null) {
                for (EnchantmentSlot slot = 0; slot.getValue() < EnchantmentSlot.max.getValue(); ++slot) {
                    var ench_id = _items[i].getEnchantmentId(slot);

                    if (ench_id == 0) {
                        continue;
                    }

                    var Enchant = CliDB.SpellItemEnchantmentStorage.get(ench_id);

                    if (Enchant == null) {
                        return;
                    }

                    if (Enchant.RequiredSkillID == skill_id) {
                        // Checks if the enchantment needs to be applied or removed
                        if (curr_value < Enchant.RequiredSkillRank && new_value >= Enchant.RequiredSkillRank) {
                            applyEnchantment(_items[i], slot, true);
                        } else if (new_value < Enchant.RequiredSkillRank && curr_value >= Enchant.RequiredSkillRank) {
                            applyEnchantment(_items[i], slot, false);
                        }
                    }

                    // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
                    // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
                    if ((slot == EnchantmentSlot.Sock1 || slot == EnchantmentSlot.Sock2 || slot == EnchantmentSlot.Sock3) && _items[i].getSocketColor((int) (slot - EnchantmentSlot.Sock1)) == 0) {
                        var pPrismaticEnchant = CliDB.SpellItemEnchantmentStorage.get(_items[i].getEnchantmentId(EnchantmentSlot.Prismatic));

                        if (pPrismaticEnchant != null && pPrismaticEnchant.RequiredSkillID == skill_id) {
                            if (curr_value < pPrismaticEnchant.RequiredSkillRank && new_value >= pPrismaticEnchant.RequiredSkillRank) {
                                applyEnchantment(_items[i], slot, true);
                            } else if (new_value < pPrismaticEnchant.RequiredSkillRank && curr_value >= pPrismaticEnchant.RequiredSkillRank) {
                                applyEnchantment(_items[i], slot, false);
                            }
                        }
                    }
                }
            }
        }
    }


    private void updateEnchantTime(int time) {
        for (var i = 0; i < enchantDurations.size(); ++i) {
            var enchantDuration = enchantDurations.get(i);

            if (enchantDuration.getItem().getEnchantmentId(enchantDuration.getSlot()) == 0) {
                enchantDurations.remove(enchantDuration);
            } else if (enchantDuration.getLeftduration() <= time) {
                applyEnchantment(enchantDuration.getItem(), enchantDuration.getSlot(), false, false);
                enchantDuration.getItem().clearEnchantment(enchantDuration.getSlot());
                enchantDurations.remove(enchantDuration);
            } else if (enchantDuration.getLeftduration() > time) {
                enchantDuration.setLeftduration(enchantDuration.getLeftduration() - time);
            }
        }
    }

    private void applyEnchantment(Item item, boolean apply) {
        for (EnchantmentSlot slot = 0; slot.getValue() < EnchantmentSlot.max.getValue(); ++slot) {
            applyEnchantment(item, slot, apply);
        }
    }

    private void addEnchantmentDurations(Item item) {
        for (EnchantmentSlot x = 0; x.getValue() < EnchantmentSlot.max.getValue(); ++x) {
            if (item.getEnchantmentId(x) == 0) {
                continue;
            }

            var duration = item.getEnchantmentDuration(x);

            if (duration > 0) {
                addEnchantmentDuration(item, x, duration);
            }
        }
    }


    private void addEnchantmentDuration(Item item, EnchantmentSlot slot, int duration) {
        if (item == null) {
            return;
        }

        if (slot.getValue() >= EnchantmentSlot.max.getValue()) {
            return;
        }

        for (var i = 0; i < enchantDurations.size(); ++i) {
            var enchantDuration = enchantDurations.get(i);

            if (enchantDuration.getItem() == item && enchantDuration.getSlot() == slot) {
                enchantDuration.getItem().setEnchantmentDuration(enchantDuration.getSlot(), enchantDuration.getLeftduration(), this);
                enchantDurations.remove(enchantDuration);

                break;
            }
        }

        if (duration > 0) {
            getSession().sendItemEnchantTimeUpdate(getGUID(), item.getGUID(), (int) slot.getValue(), duration / 1000);
            enchantDurations.add(new EnchantDuration(item, slot, duration));
        }
    }

    private void removeEnchantmentDurations(Item item) {
        for (var i = 0; i < enchantDurations.size(); ++i) {
            var enchantDuration = enchantDurations.get(i);

            if (enchantDuration.getItem() == item) {
                // save duration in item
                item.setEnchantmentDuration(enchantDuration.getSlot(), enchantDuration.getLeftduration(), this);
                enchantDurations.remove(enchantDuration);
            }
        }
    }

    private void removeEnchantmentDurationsReferences(Item item) {
        for (var i = 0; i < enchantDurations.size(); ++i) {
            var enchantDuration = enchantDurations.get(i);

            if (enchantDuration.getItem() == item) {
                enchantDurations.remove(enchantDuration);
            }
        }
    }


    private byte getFishingStepsNeededToLevelUp(int SkillValue) {
        // These formulas are guessed to be as close as possible to how the skill difficulty curve for fishing was on Retail.
        if (SkillValue < 75) {
            return 1;
        }

        if (SkillValue <= 300) {
            return (byte) (SkillValue / 44);
        }

        return (byte) (SkillValue / 31);
    }


    private int skillGainChance(int SkillValue, int GrayLevel, int GreenLevel, int YellowLevel) {
        if (SkillValue >= GrayLevel) {
            return WorldConfig.getIntValue(WorldCfg.SkillChanceGrey) * 10;
        }

        if (SkillValue >= GreenLevel) {
            return WorldConfig.getIntValue(WorldCfg.SkillChanceGreen) * 10;
        }

        if (SkillValue >= YellowLevel) {
            return WorldConfig.getIntValue(WorldCfg.SkillChanceYellow) * 10;
        }

        return WorldConfig.getIntValue(WorldCfg.SkillChanceOrange) * 10;
    }


    private boolean enchantmentFitsRequirements(int enchantmentcondition, byte slot) {
        if (enchantmentcondition == 0) {
            return true;
        }

        var condition = CliDB.SpellItemEnchantmentConditionStorage.get(enchantmentcondition);

        if (condition == null) {
            return true;
        }

        byte[] curcount = {0, 0, 0, 0};

        //counting current equipped gem colors
        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
            if (i == slot) {
                continue;
            }

            var pItem2 = getItemByPos(InventorySlots.Bag0, i);

            if (pItem2 != null && !pItem2.isBroken()) {
                for (var gemData : pItem2.getItemData().gems) {
                    var gemProto = global.getObjectMgr().getItemTemplate(gemData.itemId);

                    if (gemProto == null) {
                        continue;
                    }

                    var gemProperty = CliDB.GemPropertiesStorage.get(gemProto.getGemProperties());

                    if (gemProperty == null) {
                        continue;
                    }

                    var GemColor = (int) gemProperty.type;

                    for (byte b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1) {
                        if ((boolean) (tmpcolormask & GemColor)) {
                            ++curcount[b];
                        }
                    }
                }
            }
        }

        var activate = true;

        for (byte i = 0; i < 5; i++) {
            if (condition.LtOperandType[i] == 0) {
                continue;
            }

            int _cur_gem = curcount[Condition.LtOperandType[i] - 1];

            // if have <CompareColor> use them as count, else use <second> from Condition
            int _cmp_gem = condition.RtOperandType[i] != 0 ? curcount[Condition.RtOperandType[i] - 1] : condition.RtOperand[i];

            switch (condition.Operator[i]) {
                case 2: // requires less <color> than (<second> || <comparecolor>) gems
                    activate &= (_cur_gem < _cmp_gem);

                    break;
                case 3: // requires more <color> than (<second> || <comparecolor>) gems
                    activate &= (_cur_gem > _cmp_gem);

                    break;
                case 5: // requires at least <color> than (<second> || <comparecolor>) gems
                    activate &= (_cur_gem >= _cmp_gem);

                    break;
            }
        }

        Log.outDebug(LogFilter.player, "Checking Condition {0}, there are {1} Meta gems, {2} Red gems, {3} Yellow Gems and {4} Blue gems, Activate:{5}", enchantmentcondition, curcount[0], curcount[1], curcount[2], curcount[3], activate ? "yes" : "no");

        return activate;
    }


    private void correctMetaGemEnchants(byte exceptslot, boolean apply) {
        //cycle all equipped items
        for (var slot = EquipmentSlot.start; slot < EquipmentSlot.End; ++slot) {
            //enchants for the slot being socketed are handled by player.ApplyItemMods
            if (slot == exceptslot) {
                continue;
            }

            var pItem = getItemByPos(InventorySlots.Bag0, slot);

            if (pItem == null || pItem.getSocketColor(0) == 0) {
                continue;
            }

            for (var enchant_slot = EnchantmentSlot.Sock1; enchant_slot.getValue() < EnchantmentSlot.Sock3.getValue(); ++enchant_slot) {
                var enchant_id = pItem.getEnchantmentId(enchant_slot);

                if (enchant_id == 0) {
                    continue;
                }

                var enchantEntry = CliDB.SpellItemEnchantmentStorage.get(enchant_id);

                if (enchantEntry == null) {
                    continue;
                }

                int condition = enchantEntry.ConditionID;

                if (condition != 0) {
                    //was enchant active with/without item?
                    var wasactive = enchantmentFitsRequirements(condition, apply ? exceptslot : -1);

                    //should it now be?
                    if (wasactive ^ enchantmentFitsRequirements(condition, apply ? -1 : exceptslot)) {
                        // ignore item gem conditions
                        //if state changed, (dis)apply enchant
                        applyEnchantment(pItem, enchant_slot, !wasactive, true, true);
                    }
                }
            }
        }
    }


    private int findEmptyProfessionSlotFor(int skillId) {
        var skillEntry = CliDB.SkillLineStorage.get(skillId);

        if (skillEntry == null) {
            return -1;
        }

        if (skillEntry.ParentSkillLineID != 0 || skillEntry.categoryID != SkillCategory.profession) {
            return -1;
        }

        var index = 0;

        // if there is no same profession, find any free slot
        for (var b : getActivePlayerData().professionSkillLine) {
            if (b == 0) {
                return index;
            }

            index++;
        }

        return -1;
    }

    private void removeItemDependentAurasAndCasts(Item pItem) {
        getOwnedAurasList().CallOnMatch((aura) ->
        {
            // skip not self applied auras
            var spellInfo = aura.spellInfo;

            if (ObjectGuid.opNotEquals(aura.casterGuid, getGUID())) {
                return false;
            }

            // skip if not item dependent or have alternative item
            if (hasItemFitToSpellRequirements(spellInfo, pItem)) {
                return false;
            }

            // no alt item, remove aura, restart check
            return true;
        }, (pair) -> removeOwnedAura(pair));

        // currently casted spells can be dependent from item
        for (CurrentSpellTypes i = 0; i.getValue() < CurrentSpellTypes.max.getValue(); ++i) {
            var spell = getCurrentSpell(i);

            if (spell != null) {
                if (spell.getState() != SpellState.Delayed && !hasItemFitToSpellRequirements(spell.spellInfo, pItem)) {
                    interruptSpell(i);
                }
            }
        }
    }

    private void castAllObtainSpells() {
        var inventoryEnd = InventorySlots.ItemStart + getInventorySlotCount();

        for (var slot = InventorySlots.ItemStart; slot < inventoryEnd; ++slot) {
            var item = getItemByPos(InventorySlots.Bag0, slot);

            if (item) {
                applyItemObtainSpells(item, true);
            }
        }

        for (var i = InventorySlots.BagStart; i < InventorySlots.BagEnd; ++i) {
            var bag = getBagByPos(i);

            if (!bag) {
                continue;
            }

            for (byte slot = 0; slot < bag.getBagSize(); ++slot) {
                var item = bag.getItemByPos(slot);

                if (item) {
                    applyItemObtainSpells(item, true);
                }
            }
        }
    }

    private void applyItemObtainSpells(Item item, boolean apply) {
        if (item.getTemplate().hasFlag(ItemFlags.legacy)) {
            return;
        }

        for (var effect : item.getEffects()) {
            if (effect.triggerType != ItemSpelltriggerType.OnPickup) // On obtain trigger
            {
                continue;
            }

            var spellId = effect.spellID;

            if (spellId <= 0) {
                continue;
            }

            if (apply) {
                if (!hasAura((int) spellId)) {
                    castSpell(this, (int) spellId, (new CastSpellExtraArgs()).setCastItem(item));
                }
            } else {
                removeAura((int) spellId);
            }
        }
    }

    // this one rechecks weapon auras and stores them in BaseModGroup container
    // needed for things like axe specialization applying only to axe weapons in case of dual-wield
    private void updateWeaponDependentCritAuras(WeaponAttackType attackType) {
        BaseModGroup modGroup;

        switch (attackType) {
            case BaseAttack:
                modGroup = BaseModGroup.critPercentage;

                break;
            case OffAttack:
                modGroup = BaseModGroup.offhandCritPercentage;

                break;
            case RangedAttack:
                modGroup = BaseModGroup.rangedCritPercentage;

                break;
            default:
                return;
        }

        double amount = 0.0f;
        amount += getTotalAuraModifier(AuraType.ModWeaponCritPercent, auraEffect -> checkAttackFitToAuraRequirement(attackType, auraEffect));

        // these auras don't have item requirement (only Combat Expertise in 3.3.5a)
        amount += getTotalAuraModifier(AuraType.ModCritPct);

        setBaseModFlatValue(modGroup, amount);
    }

    private void sendKnownSpells() {
        SendKnownSpells knownSpells = new sendKnownSpells();
        knownSpells.initialLogin = isLoading();

        for (var spell : spells.ToList()) {
            if (spell.value.state == PlayerSpellState.removed) {
                continue;
            }

            if (!spell.value.active || spell.value.disabled) {
                continue;
            }

            knownSpells.knownSpells.add(spell.key);

            if (spell.value.favorite) {
                knownSpells.favoriteSpells.add(spell.key);
            }
        }

        sendPacket(knownSpells);
    }

    private void sendUnlearnSpells() {
        sendPacket(new sendUnlearnSpells());
    }

    private boolean handlePassiveSpellLearn(SpellInfo spellInfo) {
        // note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
        // talent dependent passives activated at form apply have proper stance data
        var form = getShapeshiftForm();

        var need_cast = (spellInfo.getStances() == 0 || (form != 0 && (boolean) (spellInfo.getStances() & (1L << (form.getValue() - 1)))) || (form == 0 && spellInfo.hasAttribute(SpellAttr2.AllowWhileNotShapeshiftedCasterForm)));

        // Check EquippedItemClass
        // passive spells which apply aura and have an item requirement are to be added manually, instead of casted
        if (spellInfo.getEquippedItemClass().getValue() >= 0) {
            for (var spellEffectInfo : spellInfo.getEffects()) {
                if (spellEffectInfo.isAura()) {
                    if (!hasAura(spellInfo.getId()) && hasItemFitToSpellRequirements(spellInfo)) {
                        addAura(spellInfo.getId(), this);
                    }

                    return false;
                }
            }
        }

        //Check CasterAuraStates
        return need_cast && (spellInfo.getCasterAuraState() == 0 || hasAuraState(spellInfo.getCasterAuraState()));
    }


    private boolean addSpell(int spellId, boolean active, boolean learning, boolean dependent, boolean disabled, boolean loading, int fromSkill, boolean favorite) {
        return addSpell(spellId, active, learning, dependent, disabled, loading, fromSkill, favorite, null);
    }

    private boolean addSpell(int spellId, boolean active, boolean learning, boolean dependent, boolean disabled, boolean loading, int fromSkill) {
        return addSpell(spellId, active, learning, dependent, disabled, loading, fromSkill, false, null);
    }

    private boolean addSpell(int spellId, boolean active, boolean learning, boolean dependent, boolean disabled, boolean loading) {
        return addSpell(spellId, active, learning, dependent, disabled, loading, 0, false, null);
    }

    private boolean addSpell(int spellId, boolean active, boolean learning, boolean dependent, boolean disabled) {
        return addSpell(spellId, active, learning, dependent, disabled, false, 0, false, null);
    }

    private boolean addSpell(int spellId, boolean active, boolean learning, boolean dependent, boolean disabled, boolean loading, int fromSkill, boolean favorite, Integer traitDefinitionId) {
        var spellInfo = global.getSpellMgr().getSpellInfo(spellId, Difficulty.NONE);

        if (spellInfo == null) {
            // do character spell book cleanup (all character)
            if (!isInWorld() && !learning) {
                Log.outError(LogFilter.spells, "Player.AddSpell: spell (ID: {0}) does not exist. deleting for all character in `character_spell`.", spellId);

                deleteSpellFromAllPlayers(spellId);
            } else {
                Log.outError(LogFilter.spells, "Player.AddSpell: spell (ID: {0}) does not exist", spellId);
            }

            return false;
        }

        if (!global.getSpellMgr().isSpellValid(spellInfo, this, false)) {
            // do character spell book cleanup (all character)
            if (!isInWorld() && !learning) {
                Log.outError(LogFilter.spells, "Player.AddSpell: spell (ID: {0}) is invalid. deleting for all character in `character_spell`.", spellId);

                deleteSpellFromAllPlayers(spellId);
            } else {
                Log.outError(LogFilter.spells, "Player.AddSpell: spell (ID: {0}) is invalid", spellId);
            }

            return false;
        }

        var state = learning ? PlayerSpellState.New : PlayerSpellState.Unchanged;

        var dependent_set = false;
        var disabled_case = false;
        var superceded_old = false;

        var spell = spells.get(spellId);

        if (spell != null && spell.state == PlayerSpellState.Temporary) {
            removeTemporarySpell(spellId);
        }

        if (spell != null) {
            int next_active_spell_id = 0;

            // fix activate state for non-stackable low rank (and find next spell for !active case)
            if (spellInfo.isRanked()) {
                var next = global.getSpellMgr().getNextSpellInChain(spellId);

                if (next != 0) {
                    if (hasSpell(next)) {
                        // high rank already known so this must !active
                        active = false;
                        next_active_spell_id = next;
                    }
                }
            }

            // not do anything if already known in expected state
            if (spell.state != PlayerSpellState.removed && spell.active == active && spell.dependent == dependent && spell.disabled == disabled) {
                if (!isInWorld() && !learning) {
                    spell.state = PlayerSpellState.Unchanged;
                }

                return false;
            }

            // dependent spell known as not dependent, overwrite state
            if (spell.state != PlayerSpellState.removed && !spell.dependent && dependent) {
                spell.dependent = dependent;

                if (spell.state != PlayerSpellState.New) {
                    spell.state = PlayerSpellState.changed;
                }

                dependent_set = true;
            }

            if (!traitDefinitionId.equals(spell.traitDefinitionId)) {
                if (spell.traitDefinitionId.HasValue) {
                    var traitDefinition = CliDB.TraitDefinitionStorage.get(spell.traitDefinitionId.value);

                    if (traitDefinition != null) {
                        removeOverrideSpell((int) traitDefinition.OverridesSpellID, spellId);
                    }
                }

                spell.traitDefinitionId = traitDefinitionId;
            }

            spell.favorite = favorite;

            // update active state for known spell
            if (spell.active != active && spell.state != PlayerSpellState.removed && !spell.disabled) {
                spell.active = active;

                if (!isInWorld() && !learning && !dependent_set) // explicitly load from DB and then exist in it already and set correctly
                {
                    spell.state = PlayerSpellState.Unchanged;
                } else if (spell.state != PlayerSpellState.New) {
                    spell.state = PlayerSpellState.changed;
                }

                if (active) {
                    if (spellInfo.isPassive() && handlePassiveSpellLearn(spellInfo)) {
                        castSpell(this, spellId, true);
                    }
                } else if (isInWorld()) {
                    if (next_active_spell_id != 0) {
                        sendSupercededSpell(spellId, next_active_spell_id);
                    } else {
                        UnlearnedSpells removedSpells = new UnlearnedSpells();
                        removedSpells.spellID.add(spellId);
                        sendPacket(removedSpells);
                    }
                }

                return active;
            }

            if (spell.disabled != disabled && spell.state != PlayerSpellState.removed) {
                if (spell.state != PlayerSpellState.New) {
                    spell.state = PlayerSpellState.changed;
                }

                spell.disabled = disabled;

                if (disabled) {
                    return false;
                }

                disabled_case = true;
            } else {
                switch (spell.state) {
                    case PlayerSpellState.Unchanged:
                        return false;
                    case PlayerSpellState.Removed: {
                        spells.remove(spellId);
                        state = PlayerSpellState.changed;

                        break;
                    }
                    default: {
                        // can be in case spell loading but learned at some previous spell loading
                        if (!isInWorld() && !learning && !dependent_set) {
                            spell.state = PlayerSpellState.Unchanged;
                        }

                        return false;
                    }
                }
            }
        }

        if (!disabled_case) // skip new spell adding if spell already known (disabled spells case)
        {
            // non talent spell: learn low ranks (recursive call)
            var prev_spell = global.getSpellMgr().getPrevSpellInChain(spellId);

            if (prev_spell != 0) {
                if (!isInWorld() || disabled) // at spells loading, no output, but allow save
                {
                    addSpell(prev_spell, active, true, true, disabled, false, fromSkill);
                } else // at normal learning
                {
                    learnSpell(prev_spell, true, fromSkill);
                }
            }

            PlayerSpell newspell = new PlayerSpell();
            newspell.state = state;
            newspell.active = active;
            newspell.dependent = dependent;
            newspell.disabled = disabled;
            newspell.favorite = favorite;

            if (traitDefinitionId != null) {
                newspell.traitDefinitionId = traitDefinitionId.intValue();
            }

            // replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
            if (newspell.active && !newspell.disabled && spellInfo.isRanked()) {
                for (var _spell : spells.entrySet()) {
                    if (spell.getValue().state == PlayerSpellState.removed) {
                        continue;
                    }

                    var i_spellInfo = global.getSpellMgr().getSpellInfo(spell.getKey(), Difficulty.NONE);

                    if (i_spellInfo == null) {
                        continue;
                    }

                    if (spellInfo.isDifferentRankOf(i_spellInfo)) {
                        if (spell.getValue().active) {
                            if (spellInfo.isHighRankOf(i_spellInfo)) {
                                if (isInWorld()) // not send spell (re-/over-)learn packets at loading
                                {
                                    sendSupercededSpell(spell.getKey(), spellId);
                                }

                                // mark old spell as disable (SMSG_SUPERCEDED_SPELL replace it in client by new)
                                spell.getValue().active = false;

                                if (spell.getValue().state != PlayerSpellState.New) {
                                    spell.getValue().state = PlayerSpellState.changed;
                                }

                                superceded_old = true; // new spell replace old in action bars and spell book.
                            } else {
                                if (isInWorld()) // not send spell (re-/over-)learn packets at loading
                                {
                                    sendSupercededSpell(spellId, spell.getKey());
                                }

                                // mark new spell as disable (not learned yet for client and will not learned)
                                newspell.active = false;

                                if (newspell.state != PlayerSpellState.New) {
                                    newspell.state = PlayerSpellState.changed;
                                }
                            }
                        }
                    }
                }
            }

            spells.put(spellId, newspell);

            // return false if spell disabled
            if (newspell.disabled) {
                return false;
            }
        }

        var castSpell = false;

        // cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
        // note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
        if (!loading && spellInfo.hasAttribute(SpellCustomAttributes.IsTalent) && spellInfo.hasEffect(SpellEffectName.LearnSpell)) {
            // ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
            castSpell = true;
        }
        // also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
        else if (spellInfo.isPassive()) {
            castSpell = handlePassiveSpellLearn(spellInfo);
        } else if (spellInfo.hasEffect(SpellEffectName.skillStep)) {
            castSpell = true;
        } else if (spellInfo.hasAttribute(SpellAttr1.CastWhenLearned)) {
            castSpell = true;
        }

        if (castSpell) {
            CastSpellExtraArgs args = new CastSpellExtraArgs(TriggerCastFlags.FullMask);

            if (traitDefinitionId != null) {
                var traitConfig = getTraitConfig((int) getActivePlayerData().activeCombatTraitConfigID);

                if (traitConfig != null) {
                    var traitEntryIndex = traitConfig.entries.FindIndexIf(traitEntry ->
                    {
                        return traitDefinitionId.equals((CliDB.TraitNodeEntryStorage.get(traitEntry.traitNodeEntryID) == null ? null : CliDB.TraitNodeEntryStorage.get(traitEntry.traitNodeEntryID).traitDefinitionID));
                    });

                    var rank = 0;

                    if (traitEntryIndex >= 0) {
                        rank = traitConfig.entries.get(traitEntryIndex).rank + traitConfig.entries.get(traitEntryIndex).grantedRanks;
                    }

                    if (rank > 0) {
                        var traitDefinitionEffectPoints = TraitMgr.getTraitDefinitionEffectPointModifiers(traitDefinitionId.intValue());

                        if (traitDefinitionEffectPoints != null) {
                            for (var traitDefinitionEffectPoint : traitDefinitionEffectPoints) {
                                if (traitDefinitionEffectPoint.effectIndex >= spellInfo.getEffects().size()) {
                                    continue;
                                }

                                double basePoints = global.getDB2Mgr().GetCurveValueAt((int) traitDefinitionEffectPoint.CurveID, rank);

                                if (traitDefinitionEffectPoint.GetOperationType() == TraitPointsOperationType.Multiply) {
                                    basePoints *= spellInfo.getEffect(traitDefinitionEffectPoint.effectIndex).calcBaseValue(this, null, 0, -1);
                                }

                                args.addSpellMod(SpellValueMod.BasePoint0 + traitDefinitionEffectPoint.effectIndex, basePoints);
                            }
                        }
                    }
                }
            }

            castSpell(this, spellId, args);

            if (spellInfo.hasEffect(SpellEffectName.skillStep)) {
                return false;
            }
        }

        if (traitDefinitionId != null) {
            var traitDefinition = CliDB.TraitDefinitionStorage.get(traitDefinitionId.intValue());

            if (traitDefinition != null) {
                addOverrideSpell(traitDefinition.OverridesSpellID, spellId);
            }
        }

        // update free primary prof.points (if any, can be none in case GM .learn prof. learning)
        var freeProfs = getFreePrimaryProfessionPoints();

        if (freeProfs != 0) {
            if (spellInfo.isPrimaryProfessionFirstRank()) {
                setFreePrimaryProfessions(freeProfs - 1);
            }
        }

        var skill_bounds = global.getSpellMgr().getSkillLineAbilityMapBounds(spellId);

        var spellLearnSkill = global.getSpellMgr().getSpellLearnSkill(spellId);

        if (spellLearnSkill != null) {
            // add dependent skills if this spell is not learned from adding skill already
            if ((int) spellLearnSkill.skill.getValue() != fromSkill) {
                var skill_value = getPureSkillValue(spellLearnSkill.skill);
                var skill_max_value = getPureMaxSkillValue(spellLearnSkill.skill);

                if (skill_value < spellLearnSkill.value) {
                    skill_value = spellLearnSkill.value;
                }

                var new_skill_max_value = spellLearnSkill.maxvalue == 0 ? getMaxSkillValueForLevel() : spellLearnSkill.maxvalue;

                if (skill_max_value < new_skill_max_value) {
                    skill_max_value = new_skill_max_value;
                }

                setSkill(spellLearnSkill.skill, spellLearnSkill.step, skill_value, skill_max_value);
            }
        } else {
            // not ranked skills
            for (var _spell_idx : skill_bounds) {
                var pSkill = CliDB.SkillLineStorage.get(_spell_idx.skillLine);

                if (pSkill == null) {
                    continue;
                }

                if (_spell_idx.skillLine == fromSkill) {
                    continue;
                }

                // Runeforging special case
                if ((_spell_idx.AcquireMethod == AbilityLearnType.OnSkillLearn && !hasSkill(SkillType.forValue(_spell_idx.skillLine))) || ((_spell_idx.skillLine == SkillType.Runeforging.getValue()) && _spell_idx.TrivialSkillLineRankHigh == 0)) {
                    var rcInfo = global.getDB2Mgr().GetSkillRaceClassInfo(_spell_idx.skillLine, getRace(), getClass());

                    if (rcInfo != null) {
                        learnDefaultSkill(rcInfo);
                    }
                }
            }
        }


        // learn dependent spells
        var spell_bounds = global.getSpellMgr().getSpellLearnSpellMapBounds(spellId);

        for (var spellNode : spell_bounds) {
            if (!spellNode.autoLearned) {
                if (!isInWorld() || !spellNode.active) // at spells loading, no output, but allow save
                {
                    addSpell(spellNode.spell, spellNode.active, true, true, false);
                } else // at normal learning
                {
                    learnSpell(spellNode.spell, true);
                }
            }

            if (spellNode.overridesSpell != 0 && spellNode.active) {
                addOverrideSpell(spellNode.overridesSpell, spellNode.spell);
            }
        }

        if (!getSession().getPlayerLoading()) {
            // not ranked skills
            for (var _spell_idx : skill_bounds) {
                updateCriteria(CriteriaType.LearnTradeskillSkillLine, _spell_idx.skillLine);
                updateCriteria(CriteriaType.LearnSpellFromSkillLine, _spell_idx.skillLine);
            }

            updateCriteria(CriteriaType.LearnOrKnowSpell, spellId);
        }

        // needs to be when spell is already learned, to prevent infinite recursion crashes
        if (global.getDB2Mgr().GetMount(spellId) != null) {
            getSession().getCollectionMgr().addMount(spellId, MountStatusFlags.NONE, false, !isInWorld());
        }

        // return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
        return active && !disabled && !superceded_old;
    }

    private boolean isAffectedBySpellmod(SpellInfo spellInfo, SpellModifier mod, Spell spell) {
        if (mod == null || spellInfo == null) {
            return false;
        }

        // First time this aura applies a mod to us and is out of charges
        if (spell && mod.getOwnerAura().isUsingCharges() && mod.getOwnerAura().getCharges() == 0 && !spell.appliedMods.contains(mod.getOwnerAura())) {
            return false;
        }

        switch (mod.getOp()) {
            case Duration: // +duration to infinite duration spells making them limited
                if (spellInfo.getDuration() == -1) {
                    return false;
                }

                break;
            case CritChance: // mod crit to spells that can't crit
                if (!spellInfo.hasAttribute(SpellCustomAttributes.CanCrit)) {
                    return false;
                }

                break;
            case PointsIndex0: // check if spell has any effect at that index
            case Points:
                if (spellInfo.getEffects().size() <= 0) {
                    return false;
                }

                break;
            case PointsIndex1: // check if spell has any effect at that index
                if (spellInfo.getEffects().size() <= 1) {
                    return false;
                }

                break;
            case PointsIndex2: // check if spell has any effect at that index
                if (spellInfo.getEffects().size() <= 2) {
                    return false;
                }

                break;
            case PointsIndex3: // check if spell has any effect at that index
                if (spellInfo.getEffects().size() <= 3) {
                    return false;
                }

                break;
            case PointsIndex4: // check if spell has any effect at that index
                if (spellInfo.getEffects().size() <= 4) {
                    return false;
                }

                break;
            default:
                break;
        }

        return spellInfo.isAffectedBySpellMod(mod);
    }

    private void sendSpellModifiers() {
        SetSpellModifier flatMods = new SetSpellModifier(ServerOpcode.SetFlatSpellModifier);
        SetSpellModifier pctMods = new SetSpellModifier(ServerOpcode.SetPctSpellModifier);

        for (var i = 0; i < SpellModOp.max.getValue(); ++i) {
            SpellModifierInfo flatMod = new SpellModifierInfo();
            SpellModifierInfo pctMod = new SpellModifierInfo();
            flatMod.modIndex = pctMod.modIndex = (byte) i;

            for (byte j = 0; j < 128; ++j) {
                FlagArray128 mask = new flagArray128();
                mask.set(j / 32, 1 << (j % 32));

                SpellModifierData flatData = new SpellModifierData();
                SpellModifierData pctData = new SpellModifierData();

                flatData.classIndex = j;
                flatData.modifierValue = 0.0f;
                pctData.classIndex = j;
                pctData.modifierValue = 1.0f;

                for (SpellModifierByClassMask mod : spellModifiers[i][SpellModType.Flat.getValue()]) {
                    if (mod.mask & mask) {
                        flatData.modifierValue += mod.value;
                    }
                }

                for (SpellModifierByClassMask mod : spellModifiers[i][SpellModType.Pct.getValue()]) {
                    if (mod.mask & mask) {
                        pctData.ModifierValue *= 1.0f + MathUtil.CalculatePct(1.0f, mod.value);
                    }
                }

                flatMod.modifierData.add(flatData);
                pctMod.modifierData.add(pctData);
            }

            tangible.ListHelper.removeAll(flatMod.modifierData, mod -> MathUtil.fuzzyEq(mod.modifierValue, 0.0f));

            tangible.ListHelper.removeAll(pctMod.modifierData, mod -> MathUtil.fuzzyEq(mod.modifierValue, 1.0f));

            flatMods.modifiers.add(flatMod);
            pctMods.modifiers.add(pctMod);
        }

        if (!flatMods.modifiers.isEmpty()) {
            sendPacket(flatMods);
        }

        if (!pctMods.modifiers.isEmpty()) {
            sendPacket(pctMods);
        }
    }


    private void sendSupercededSpell(int oldSpell, int newSpell) {
        SupercededSpells supercededSpells = new SupercededSpells();
        LearnedSpellInfo learnedSpellInfo = new LearnedSpellInfo();
        learnedSpellInfo.spellID = newSpell;
        learnedSpellInfo.superceded = oldSpell;
        supercededSpells.clientLearnedSpellData.add(learnedSpellInfo);
        sendPacket(supercededSpells);
    }


    private void updateItemSetAuras() {
        updateItemSetAuras(false);
    }

    private void updateItemSetAuras(boolean formChange) {
        // item set bonuses not dependent from item broken state
        for (var setindex = 0; setindex < getItemSetEff().size(); ++setindex) {
            var eff = getItemSetEff().get(setindex);

            if (eff == null) {
                continue;
            }

            for (var itemSetSpell : eff.getSetBonuses()) {
                var spellInfo = global.getSpellMgr().getSpellInfo(itemSetSpell.spellID, Difficulty.NONE);

                if (itemSetSpell.ChrSpecID != 0 && itemSetSpell.ChrSpecID != getPrimarySpecialization()) {
                    applyEquipSpell(spellInfo, null, false, false); // item set aura is not for current spec
                } else {
                    applyEquipSpell(spellInfo, null, false, formChange); // remove spells that not fit to form - removal is skipped if shapeshift condition is satisfied
                    applyEquipSpell(spellInfo, null, true, formChange); // add spells that fit form but not active
                }
            }
        }
    }

    private float getWeaponProcChance() {
        // normalized proc chance for weapon attack speed
        // (odd formula...)
        if (isAttackReady(WeaponAttackType.BaseAttack)) {
            return (getBaseAttackTime(WeaponAttackType.BaseAttack) * 1.8f / 1000.0f);
        } else if (haveOffhandWeapon() && isAttackReady(WeaponAttackType.OffAttack)) {
            return (getBaseAttackTime(WeaponAttackType.OffAttack) * 1.6f / 1000.0f);
        }

        return 0;
    }

    @Override
    public boolean updateAllStats() {
        for (var i = stats.Strength; i.getValue() < stats.max.getValue(); ++i) {
            var value = getTotalStatValue(i);
            setStat(i, (int) value);
        }

        updateArmor();
        // calls updateAttackPowerAndDamage() in UpdateArmor for SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR
        updateAttackPowerAndDamage(true);
        updateMaxHealth();

        for (var i = powerType.mana; i.getValue() < powerType.max.getValue(); ++i) {
            updateMaxPower(i);
        }

        updateAllRatings();
        updateAllCritPercentages();
        updateSpellCritChance();
        updateBlockPercentage();
        updateParryPercentage();
        updateDodgePercentage();
        updateSpellDamageAndHealingBonus();
        updateManaRegen();
        updateExpertise(WeaponAttackType.BaseAttack);
        updateExpertise(WeaponAttackType.OffAttack);
        recalculateRating(CombatRating.ArmorPenetration);
        updateAllResistances();

        return true;
    }

    @Override
    public boolean updateStats(Stats stat) {
        // second = ((base_value * base_pct) + total_value) * total_pct
        var value = getTotalStatValue(stat);

        setStat(stat, (int) value);

        if (stat == stats.Stamina || stat == stats.Intellect || stat == stats.Strength) {
            var pet = getCurrentPet();

            if (pet != null) {
                pet.updateStats(stat);
            }
        }

        switch (stat) {
            case Agility:
                updateAllCritPercentages();
                updateDodgePercentage();

                break;
            case Stamina:
                updateMaxHealth();

                break;
            case Intellect:
                updateSpellCritChance();

                break;
            default:
                break;
        }

        if (stat == stats.Strength) {
            updateAttackPowerAndDamage(false);
        } else if (stat == stats.Agility) {
            updateAttackPowerAndDamage(false);
            updateAttackPowerAndDamage(true);
        }

        updateArmor();
        updateSpellDamageAndHealingBonus();
        updateManaRegen();

        return true;
    }

    @Override
    public void updateResistances(SpellSchools school) {
        if (school.getValue() > SpellSchools.NORMAL.getValue()) {
            super.updateResistances(school);

            var pet = getCurrentPet();

            if (pet != null) {
                pet.updateResistances(school);
            }
        } else {
            updateArmor();
        }
    }

    public final void applyModTargetResistance(int mod, boolean apply) {
        applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modTargetResistance), mod, apply);
    }

    public final void applyModTargetPhysicalResistance(int mod, boolean apply) {
        applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modTargetPhysicalResistance), mod, apply);
    }

    public final void recalculateRating(CombatRating cr) {
        applyRatingMod(cr, 0, true);
    }

    public final void applyModDamageDonePos(SpellSchools school, int mod, boolean apply) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        applyModUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDonePos, school.getValue()), mod, apply);
    }

    public final void applyModDamageDoneNeg(SpellSchools school, int mod, boolean apply) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        applyModUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDoneNeg, school.getValue()), mod, apply);
    }

    public final void applyModDamageDonePercent(SpellSchools school, float pct, boolean apply) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        applyPercentModUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDonePercent, school.getValue()), pct, apply);
    }

    public final void setModDamageDonePercent(SpellSchools school, float pct) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDonePercent, school.getValue()), pct);
    }

    public final void applyRatingMod(CombatRating combatRating, int value, boolean apply) {
        _baseRatingValue[combatRating.getValue()] += (apply ? value : -value);

        updateRating(combatRating);
    }

    @Override
    public void calculateMinMaxDamage(WeaponAttackType attType, boolean normalized, boolean addTotalPct, tangible.OutObject<Double> min_damage, tangible.OutObject<Double> max_damage) {
        UnitMods unitMod;

        switch (attType) {
            case BaseAttack:
            default:
                unitMod = UnitMods.DamageMainHand;

                break;
            case OffAttack:
                unitMod = UnitMods.DamageOffHand;

                break;
            case RangedAttack:
                unitMod = UnitMods.DamageRanged;

                break;
        }

        var attackPowerMod = Math.max(getAPMultiplier(attType, normalized), 0.25f);

        var baseValue = getFlatModifierValue(unitMod, UnitModifierFlatType.base) + getTotalAttackPowerValue(attType, false) / 3.5f * attackPowerMod;
        var basePct = getPctModifierValue(unitMod, UnitModifierPctType.base);
        var totalValue = getFlatModifierValue(unitMod, UnitModifierFlatType.Total);
        var totalPct = addTotalPct ? getPctModifierValue(unitMod, UnitModifierPctType.Total) : 1.0f;

        var weaponMinDamage = getWeaponDamageRange(attType, WeaponDamageRange.minDamage);
        var weaponMaxDamage = getWeaponDamageRange(attType, WeaponDamageRange.maxDamage);

        double versaDmgMod = 1.0f;

        tangible.RefObject<Double> tempRef_versaDmgMod = new tangible.RefObject<Double>(versaDmgMod);
        MathUtil.AddPct(tempRef_versaDmgMod, getRatingBonusValue(CombatRating.VersatilityDamageDone) + (float) getTotalAuraModifier(AuraType.ModVersatility));
        versaDmgMod = tempRef_versaDmgMod.refArgValue;

        var shapeshift = CliDB.SpellShapeshiftFormStorage.get(getShapeshiftForm());

        if (shapeshift != null && shapeshift.CombatRoundTime != 0) {
            weaponMinDamage = weaponMinDamage * shapeshift.CombatRoundTime / 1000.0f / attackPowerMod;
            weaponMaxDamage = weaponMaxDamage * shapeshift.CombatRoundTime / 1000.0f / attackPowerMod;
        } else if (!canUseAttackType(attType)) //check if player not in form but still can't use (disarm case)
        {
            //cannot use ranged/off attack, set values to 0
            if (attType != WeaponAttackType.BaseAttack) {
                min_damage.outArgValue = 0;
                max_damage.outArgValue = 0;

                return;
            }

            weaponMinDamage = SharedConst.BaseMinDamage;
            weaponMaxDamage = SharedConst.BaseMaxDamage;
        }

        min_damage.outArgValue = ((baseValue + weaponMinDamage) * basePct + totalValue) * totalPct * versaDmgMod;
        max_damage.outArgValue = ((baseValue + weaponMaxDamage) * basePct + totalValue) * totalPct * versaDmgMod;
    }

    public final void updateAllCritPercentages() {
        var value = 5.0f;

        setBaseModPctValue(BaseModGroup.critPercentage, value);
        setBaseModPctValue(BaseModGroup.offhandCritPercentage, value);
        setBaseModPctValue(BaseModGroup.rangedCritPercentage, value);

        updateCritPercentage(WeaponAttackType.BaseAttack);
        updateCritPercentage(WeaponAttackType.OffAttack);
        updateCritPercentage(WeaponAttackType.RangedAttack);
    }

    public final void updateManaRegen() {
        var manaIndex = getPowerIndex(powerType.mana);

        if (manaIndex == powerType.max.getValue()) {
            return;
        }

        // Get base of Mana Pool in sBaseMPGameTable
        int basemana;
        tangible.OutObject<Integer> tempOut_basemana = new tangible.OutObject<Integer>();
        global.getObjectMgr().getPlayerClassLevelInfo(getClass(), getLevel(), tempOut_basemana);
        basemana = tempOut_basemana.outArgValue;
        double base_regen = basemana / 100.0f;

        base_regen += getTotalAuraModifierByMiscValue(AuraType.ModPowerRegen, powerType.mana.getValue());

        // Apply PCT bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT
        base_regen *= getTotalAuraMultiplierByMiscValue(AuraType.ModPowerRegenPercent, powerType.mana.getValue());

        // Apply PCT bonus from SPELL_AURA_MOD_MANA_REGEN_PCT
        base_regen *= getTotalAuraMultiplierByMiscValue(AuraType.ModManaRegenPct, powerType.mana.getValue());

// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().powerRegenFlatModifier, (int) manaIndex), (float) base_regen);
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getUnitData()).modifyValue(getUnitData().powerRegenInterruptedFlatModifier, (int) manaIndex), (float) base_regen);
    }

    public final void updateSpellDamageAndHealingBonus() {
        // Magic damage modifiers implemented in unit.SpellDamageBonusDone
        // This information for client side use only
        // Get healing bonus for all schools
        setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modHealingDonePos), (int) spellBaseHealingBonusDone(spellSchoolMask.All));
        // Get damage bonus for all schools
        var modDamageAuras = getAuraEffectsByType(AuraType.ModDamageDone);

        for (var i = SpellSchools.Holy.getValue(); i < SpellSchools.max.getValue(); ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDoneNeg, i), (int) modDamageAuras.Aggregate(0f, (negativeMod, aurEff) ->
            {
                if (aurEff.amount < 0 && (boolean) (aurEff.miscValue & (1 << i))) {
                    negativeMod += (Float) aurEff.amount;
                }

                return negativeMod;
            }));

// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldStatValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modDamageDonePos, i), (int) (spellBaseDamageBonusDone(spellSchoolMask.forValue(1 << i)) - getActivePlayerData().modDamageDoneNeg.get(i)));
        }

        if (hasAuraType(AuraType.OverrideAttackPowerBySpPct)) {
            updateAttackPowerAndDamage();
            updateAttackPowerAndDamage(true);
        }
    }


    public final int getBaseSpellPowerBonus() {
        return baseSpellPower;
    }

    @Override
    public void updateAttackPowerAndDamage() {
        updateAttackPowerAndDamage(false);
    }

    @Override
    public void updateAttackPowerAndDamage(boolean ranged) {
        float val2;
        float level = getLevel();

        var entry = CliDB.ChrClassesStorage.get(getClass());
        var unitMod = ranged ? UnitMods.AttackPowerRanged : UnitMods.attackPower;

        if (!hasAuraType(AuraType.OverrideAttackPowerBySpPct)) {
            if (!ranged) {
                var strengthValue = Math.max((getStat(stats.Strength)) * entry.AttackPowerPerStrength, 0.0f);
                var agilityValue = Math.max((getStat(stats.Agility)) * entry.AttackPowerPerAgility, 0.0f);

                var form = CliDB.SpellShapeshiftFormStorage.get((int) getShapeshiftForm().getValue());

                // Directly taken from client, SHAPESHIFT_FLAG_AP_FROM_STRENGTH ?
                if (form != null && (boolean) ((int) form.flags & 0x20)) {
                    agilityValue += Math.max(getStat(stats.Agility) * entry.AttackPowerPerStrength, 0.0f);
                }

                val2 = strengthValue + agilityValue;
            } else {
                val2 = (level + Math.max(getStat(stats.Agility), 0.0f)) * entry.RangedAttackPowerPerAgility;
            }
        } else {
            int minSpellPower = getActivePlayerData().modHealingDonePos;

            for (var i = SpellSchools.Holy; i.getValue() < SpellSchools.max.getValue(); ++i) {
                minSpellPower = Math.min(minSpellPower, getActivePlayerData().modDamageDonePos.get(i.getValue()));
            }

            val2 = MathUtil.CalculatePct(minSpellPower, getActivePlayerData().overrideAPBySpellPowerPercent);
        }

        setStatFlatModifier(unitMod, UnitModifierFlatType.base, val2);

        var base_attPower = getFlatModifierValue(unitMod, UnitModifierFlatType.base) * getPctModifierValue(unitMod, UnitModifierPctType.base);
        var attPowerMod = getFlatModifierValue(unitMod, UnitModifierFlatType.Total);
        var attPowerMultiplier = getPctModifierValue(unitMod, UnitModifierPctType.Total) - 1.0f;

        if (ranged) {
            setRangedAttackPower((int) base_attPower);
            setRangedAttackPowerModPos((int) attPowerMod);
            setRangedAttackPowerMultiplier((int) attPowerMultiplier);
        } else {
            setAttackPower((int) base_attPower);
            setAttackPowerModPos((int) attPowerMod);
            setAttackPowerMultiplier((int) attPowerMultiplier);
        }

        var pet = getCurrentPet(); //update pet's AP
        var guardian = getGuardianPet();

        //automatically update weapon damage after attack power modification
        if (ranged) {
            updateDamagePhysical(WeaponAttackType.RangedAttack);

            if (pet != null && pet.isHunterPet()) // At ranged attack change for hunter pet
            {
                pet.updateAttackPowerAndDamage();
            }
        } else {
            updateDamagePhysical(WeaponAttackType.BaseAttack);
            var offhand = getWeaponForAttack(WeaponAttackType.OffAttack, true);

            if (offhand) {
                if (canDualWield || offhand.getTemplate().hasFlag(ItemFlags3.AlwaysAllowDualWield)) {
                    updateDamagePhysical(WeaponAttackType.OffAttack);
                }
            }

            if (hasAuraType(AuraType.OverrideSpellPowerByApPct)) {
                updateSpellDamageAndHealingBonus();
            }

            if (pet != null && pet.isPetGhoul()) // At melee attack power change for DK pet
            {
                pet.updateAttackPowerAndDamage();
            }

            if (guardian != null && guardian.isSpiritWolf()) // At melee attack power change for Shaman feral spirit
            {
                guardian.updateAttackPowerAndDamage();
            }
        }
    }

    @Override
    public void updateArmor() {
        var unitMod = UnitMods.armor;

        var value = getFlatModifierValue(unitMod, UnitModifierFlatType.base); // base armor
        value *= getPctModifierValue(unitMod, UnitModifierPctType.base); // armor percent

        // SPELL_AURA_MOD_ARMOR_PCT_FROM_STAT counts as base armor
        getTotalAuraModifier(AuraType.ModArmorPctFromStat, aurEff ->
        {
            var miscValue = aurEff.miscValue;
            var stat = (miscValue != -2) ? stats.forValue(miscValue) : getPrimaryStat();

            value += MathUtil.CalculatePct((float) getStat(stat), aurEff.amount);

            return true;
        });

        var baseValue = value;

        value += getFlatModifierValue(unitMod, UnitModifierFlatType.Total); // bonus armor from auras and items
        value *= getPctModifierValue(unitMod, UnitModifierPctType.Total);
        value *= getTotalAuraMultiplier(AuraType.ModBonusArmorPct);

        setArmor((int) value, (int) (value - baseValue));

        var pet = getCurrentPet();

        if (pet) {
            pet.updateArmor();
        }

        updateAttackPowerAndDamage(); // armor dependent auras update for SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR
    }

    public final void updateRating(CombatRating cr) {
        var amount = _baseRatingValue[cr.getValue()];

        for (var aurEff : getAuraEffectsByType(AuraType.ModCombatRatingFromCombatRating)) {
            if ((aurEff.getMiscValueB() & (1 << cr.getValue())) != 0) {
                Short highestRating = null;

                for (byte dependentRating = 0; dependentRating < CombatRating.max.getValue(); ++dependentRating) {
                    if ((aurEff.getMiscValue() & (1 << dependentRating)) != 0) {
                        highestRating = (short) Math.max(highestRating != null ? highestRating.shortValue() : _baseRatingValue[dependentRating], _baseRatingValue[dependentRating]);
                    }
                }

                if (!highestRating.equals(0)) {
                    amount += MathUtil.CalculatePct(highestRating.shortValue(), aurEff.getAmount());
                }
            }
        }

        for (var aurEff : getAuraEffectsByType(AuraType.ModRatingPct)) {
            if ((boolean) (aurEff.getMiscValue() & (1 << cr.getValue()))) {
                amount += MathUtil.CalculatePct(amount, aurEff.getAmount());
            }
        }

        if (amount < 0) {
            amount = 0;
        }

        var oldRating = getActivePlayerData().combatRatings.get(cr.getValue());
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().combatRatings, cr.getValue()), (int) amount);

        var affectStats = canModifyStats();

        switch (cr) {
            case Amplify:
            case DefenseSkill:
                break;
            case Dodge:
                updateDodgePercentage();

                break;
            case Parry:
                updateParryPercentage();

                break;
            case Block:
                updateBlockPercentage();

                break;
            case HitMelee:
                updateMeleeHitChances();

                break;
            case HitRanged:
                updateRangedHitChances();

                break;
            case HitSpell:
                updateSpellHitChances();

                break;
            case CritMelee:
                if (affectStats) {
                    updateCritPercentage(WeaponAttackType.BaseAttack);
                    updateCritPercentage(WeaponAttackType.OffAttack);
                }

                break;
            case CritRanged:
                if (affectStats) {
                    updateCritPercentage(WeaponAttackType.RangedAttack);
                }

                break;
            case CritSpell:
                if (affectStats) {
                    updateSpellCritChance();
                }

                break;
            case Corruption:
            case CorruptionResistance:
                updateCorruption();

                break;
            case HasteMelee:
            case HasteRanged:
            case HasteSpell: {
                // explicit affected values
                var multiplier = getRatingMultiplier(cr);
                var oldVal = applyRatingDiminishing(cr, oldRating * multiplier);
                var newVal = applyRatingDiminishing(cr, amount * multiplier);

                switch (cr) {
                    case HasteMelee:
                        applyAttackTimePercentMod(WeaponAttackType.BaseAttack, oldVal, false);
                        applyAttackTimePercentMod(WeaponAttackType.OffAttack, oldVal, false);
                        applyAttackTimePercentMod(WeaponAttackType.BaseAttack, newVal, true);
                        applyAttackTimePercentMod(WeaponAttackType.OffAttack, newVal, true);

                        if (getClass() == playerClass.Deathknight) {
                            updateAllRunesRegen();
                        }

                        break;
                    case HasteRanged:
                        applyAttackTimePercentMod(WeaponAttackType.RangedAttack, oldVal, false);
                        applyAttackTimePercentMod(WeaponAttackType.RangedAttack, newVal, true);

                        break;
                    case HasteSpell:
                        applyCastTimePercentMod(oldVal, false);
                        applyCastTimePercentMod(newVal, true);

                        break;
                    default:
                        break;
                }

                break;
            }
            case Expertise:
                if (affectStats) {
                    updateExpertise(WeaponAttackType.BaseAttack);
                    updateExpertise(WeaponAttackType.OffAttack);
                }

                break;
            case ArmorPenetration:
                if (affectStats) {
                    updateArmorPenetration(amount);
                }

                break;
            case Mastery:
                updateMastery();

                break;
            case VersatilityDamageDone:
                updateVersatilityDamageDone();

                break;
            case VersatilityHealingDone:
                updateHealingDonePercentMod();

                break;
        }
    }

    public final void updateMastery() {
        if (!canUseMastery()) {
            setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().mastery), 0.0f);

            return;
        }

        var value = getTotalAuraModifier(AuraType.mastery);
        value += getRatingBonusValue(CombatRating.mastery);
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().mastery), (float) value);

        var chrSpec = CliDB.ChrSpecializationStorage.get(getPrimarySpecialization());

        if (chrSpec == null) {
            return;
        }

        for (var masterySpellId : chrSpec.MasterySpellID) {
            var aura = getAura(masterySpellId);

            if (aura != null) {
                for (var spellEffectInfo : aura.spellInfo.effects) {
                    var mult = spellEffectInfo.bonusCoefficient;

                    if (MathUtil.fuzzyEq(mult, 0.0f)) {
                        continue;
                    }

                    aura.getEffect(spellEffectInfo.effectIndex).changeAmount(value * mult);
                }
            }
        }
    }

    public final void updateVersatilityDamageDone() {
        // No proof that CR_VERSATILITY_DAMAGE_DONE is allways = ActivePlayerData::Versatility
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().versatility), getActivePlayerData().combatRatings.get(CombatRating.VersatilityDamageDone.getValue()));

        if (getClass() == playerClass.Hunter) {
            updateDamagePhysical(WeaponAttackType.RangedAttack);
        } else {
            updateDamagePhysical(WeaponAttackType.BaseAttack);
        }
    }

    public final void updateHealingDonePercentMod() {
        double value = 1.0f;

        tangible.RefObject<Double> tempRef_value = new tangible.RefObject<Double>(value);
        MathUtil.AddPct(tempRef_value, getRatingBonusValue(CombatRating.VersatilityHealingDone) + getTotalAuraModifier(AuraType.ModVersatility));
        value = tempRef_value.refArgValue;

        for (var auraEffect : getAuraEffectsByType(AuraType.modHealingDonePercent)) {
            tangible.RefObject<Double> tempRef_value2 = new tangible.RefObject<Double>(value);
            MathUtil.AddPct(tempRef_value2, auraEffect.getAmount());
            value = tempRef_value2.refArgValue;
        }

        var val = (float) value;

        for (var i = 0; i < SpellSchools.max.getValue(); ++i) {
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
            setUpdateFieldStatValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modHealingDonePercent, i), val);
        }
    }

    public final void updateParryPercentage() {
        // No parry
        double value = 0.0f;
        var pclass = getClass().getValue() - 1;

        if (getCanParry() && parry_cap[pclass] > 0.0f) {
            double nondiminishing = 5.0f;
            // Parry from rating
            var diminishing = getRatingBonusValue(CombatRating.Parry);
            // Parry from SPELL_AURA_MOD_PARRY_PERCENT aura
            nondiminishing += getTotalAuraModifier(AuraType.ModParryPercent);

            // apply diminishing formula to diminishing parry chance
            value = calculateDiminishingReturns(parry_cap, getClass(), nondiminishing, diminishing);

            if (WorldConfig.getBoolValue(WorldCfg.StatsLimitsEnable)) {
                value = value > WorldConfig.getFloatValue(WorldCfg.StatsLimitsParry) ? WorldConfig.getFloatValue(WorldCfg.StatsLimitsParry) : value;
            }
        }

        setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().parryPercentage), (float) value);
    }

    public final void updateDodgePercentage() {
        double diminishing = 0.0f, nondiminishing = 0.0f;
        getDodgeFromAgility(diminishing, nondiminishing);
        // Dodge from SPELL_AURA_MOD_DODGE_PERCENT aura
        nondiminishing += getTotalAuraModifier(AuraType.ModDodgePercent);
        // Dodge from rating
        diminishing += getRatingBonusValue(CombatRating.Dodge);
        // apply diminishing formula to diminishing dodge chance
        var value = calculateDiminishingReturns(dodge_cap, getClass(), nondiminishing, diminishing);

        if (WorldConfig.getBoolValue(WorldCfg.StatsLimitsEnable)) {
            value = value > WorldConfig.getFloatValue(WorldCfg.StatsLimitsDodge) ? WorldConfig.getFloatValue(WorldCfg.StatsLimitsDodge) : value;
        }

        setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().dodgePercentage), (float) value);
    }

    public final void updateBlockPercentage() {
        // No block
        double value = 0.0f;

        if (getCanBlock()) {
            // Base second
            value = 5.0f;
            // Increase from SPELL_AURA_MOD_BLOCK_PERCENT aura
            value += getTotalAuraModifier(AuraType.ModBlockPercent);
            // Increase from rating
            value += getRatingBonusValue(CombatRating.Block);

            if (WorldConfig.getBoolValue(WorldCfg.StatsLimitsEnable)) {
                value = value > WorldConfig.getFloatValue(WorldCfg.StatsLimitsBlock) ? WorldConfig.getFloatValue(WorldCfg.StatsLimitsBlock) : value;
            }
        }

        setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().blockPercentage), (float) value);
    }

    public final void updateCritPercentage(WeaponAttackType attType) {
// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		static float applyCritLimit(double second)
//			{
//				if (WorldConfig.getBoolValue(WorldCfg.StatsLimitsEnable))
//					second = second > WorldConfig.getFloatValue(WorldCfg.StatsLimitsCrit) ? WorldConfig.getFloatValue(WorldCfg.StatsLimitsCrit) : second;
//
//				return (float)second;
//			}

        switch (attType) {
            case OffAttack:
                setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().offhandCritPercentage), applyCritLimit(getBaseModValue(BaseModGroup.offhandCritPercentage, BaseModType.flatMod) + getBaseModValue(BaseModGroup.offhandCritPercentage, BaseModType.pctMod) + getRatingBonusValue(CombatRating.CritMelee)));

                break;
            case RangedAttack:
                setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().rangedCritPercentage), applyCritLimit(getBaseModValue(BaseModGroup.rangedCritPercentage, BaseModType.flatMod) + getBaseModValue(BaseModGroup.rangedCritPercentage, BaseModType.pctMod) + getRatingBonusValue(CombatRating.CritRanged)));

                break;
            case BaseAttack:
            default:
                setUpdateFieldStatValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().critPercentage), applyCritLimit(getBaseModValue(BaseModGroup.critPercentage, BaseModType.flatMod) + getBaseModValue(BaseModGroup.critPercentage, BaseModType.pctMod) + getRatingBonusValue(CombatRating.CritMelee)));

                break;
        }
    }

    public final void updateExpertise(WeaponAttackType attack) {
        if (attack == WeaponAttackType.RangedAttack) {
            return;
        }

        var expertise = (int) getRatingBonusValue(CombatRating.Expertise);

        var weapon = getWeaponForAttack(attack, true);

        expertise += (int) getTotalAuraModifier(AuraType.ModExpertise, aurEff -> aurEff.spellInfo.isItemFitToSpellRequirements(weapon));

        if (expertise < 0) {
            expertise = 0;
        }

        switch (attack) {
            case BaseAttack:
                setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().mainhandExpertise), expertise);

                break;
            case OffAttack:
                setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().offhandExpertise), expertise);

                break;
            default:
                break;
        }
    }

    public final void updateSpellCritChance() {
        // For others recalculate it from:
        double crit = 5.0f;
        // Increase crit from SPELL_AURA_MOD_SPELL_CRIT_CHANCE
        crit += getTotalAuraModifier(AuraType.ModSpellCritChance);
        // Increase crit from SPELL_AURA_MOD_CRIT_PCT
        crit += getTotalAuraModifier(AuraType.ModCritPct);
        // Increase crit from spell crit ratings
        crit += getRatingBonusValue(CombatRating.CritSpell);

        // Store crit second
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().spellCritPercentage), (float) crit);
    }

    public final void updateMeleeHitChances() {
        setModMeleeHitChance(7.5f + getRatingBonusValue(CombatRating.HitMelee));
    }

    public final void updateRangedHitChances() {
        setModRangedHitChance(7.5f + getRatingBonusValue(CombatRating.HitRanged));
    }

    public final void updateSpellHitChances() {
        setModSpellHitChance(15.0f + getTotalAuraModifier(AuraType.modSpellHitChance));
        setModSpellHitChance(getModSpellHitChance() + getRatingBonusValue(CombatRating.HitSpell));
    }

    @Override
    public void updateMaxHealth() {
        var unitMod = UnitMods.health;

        var value = getFlatModifierValue(unitMod, UnitModifierFlatType.base) + getCreateHealth();
        value *= getPctModifierValue(unitMod, UnitModifierPctType.base);
        value += getFlatModifierValue(unitMod, UnitModifierFlatType.Total) + getHealthBonusFromStamina();
        value *= getPctModifierValue(unitMod, UnitModifierPctType.Total);

        setMaxHealth(value);
    }


    @Override
    public int getPowerIndex(Power powerType) {
        return global.getDB2Mgr().GetPowerIndexByClass(powerType, getClass());
    }

    @Override
    public void updateMaxPower(Power power) {
        var powerIndex = getPowerIndex(power);

        if (powerIndex == (int) powerType.max.getValue() || powerIndex >= (int) powerType.MaxPerClass.getValue()) {
            return;
        }

        var unitMod = UnitMods.PowerStart + power.getValue();

        var value = getFlatModifierValue(unitMod, UnitModifierFlatType.base) + getCreatePowerValue(power);
        value *= getPctModifierValue(unitMod, UnitModifierPctType.base);
        value += getFlatModifierValue(unitMod, UnitModifierFlatType.Total);
        value *= getPctModifierValue(unitMod, UnitModifierPctType.Total);

        setMaxPower(power, (int) Math.rint(value));
    }

    public final void applySpellPenetrationBonus(int amount, boolean apply) {
        applyModTargetResistance(-amount, apply);
        spellPenetrationItemMod += apply ? amount : -amount;
    }


    public final boolean _ModifyUInt32(boolean apply, tangible.RefObject<Integer> baseValue, tangible.RefObject<Integer> amount) {
        // If amount is negative, change sign and second of apply.
        if (amount.refArgValue < 0) {
            apply = !apply;
            amount.refArgValue = -amount.refArgValue;
        }

        if (apply) {
            baseValue.refArgValue += amount.refArgValue.intValue();
        } else {
            // Make sure we do not get public uint overflow.
            if (amount.refArgValue > baseValue.refArgValue) {
                amount.refArgValue = baseValue.refArgValue.intValue();
            }

            baseValue.refArgValue -= amount.refArgValue.intValue();
        }

        return apply;
    }

    private void _ApplyAllStatBonuses() {
        setCanModifyStats(false);

        _ApplyAllAuraStatMods();
        _ApplyAllItemMods();
        applyAllAzeriteItemMods(true);

        setCanModifyStats(true);

        updateAllStats();
    }

    private void _RemoveAllStatBonuses() {
        setCanModifyStats(false);

        applyAllAzeriteItemMods(false);
        _RemoveAllItemMods();
        _RemoveAllAuraStatMods();

        setCanModifyStats(true);

        updateAllStats();
    }

    private void updateAllRatings() {
        for (CombatRating cr = 0; cr.getValue() < CombatRating.max.getValue(); ++cr) {
            updateRating(cr);
        }
    }

    private void updateCorruption() {
        var effectiveCorruption = getRatingBonusValue(CombatRating.corruption) - getRatingBonusValue(CombatRating.CorruptionResistance);

        for (var corruptionEffect : CliDB.CorruptionEffectsStorage.values()) {
            if ((CorruptionEffectsFlag.forValue(corruptionEffect.flags)).hasFlag(CorruptionEffectsFlag.disabled)) {
                continue;
            }

            if (effectiveCorruption < corruptionEffect.MinCorruption) {
                removeAura(corruptionEffect.aura);

                continue;
            }

            var playerCondition = CliDB.PlayerConditionStorage.get(corruptionEffect.playerConditionID);

            if (playerCondition != null) {
                if (!ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                    removeAura(corruptionEffect.aura);

                    continue;
                }
            }

            castSpell(this, corruptionEffect.aura, true);
        }
    }

    private void updateArmorPenetration(int amount) {
        // Store Rating Value
// C# TO JAVA CONVERTER TASK: The following method call contained an unresolved 'ref' keyword - these cannot be converted using the 'RefObject' helper class unless the method is within the code being modified:
        setUpdateFieldValue(ref getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().combatRatings, CombatRating.ArmorPenetration.getValue()), (int) amount);
    }

    private double calculateDiminishingReturns(float[] capArray, PlayerClass playerClass, double nonDiminishValue, double diminishValue) {
        float[] m_diminishing_k = {0.9560f, 0.9560f, 0.9880f, 0.9880f, 0.9830f, 0.9560f, 0.9880f, 0.9830f, 0.9830f, 0.9830f, 0.9720f, 0.9830f, 0.9880f, 1.0f};

        //  1     1     k              cx
        // --- = --- + --- <=> x' = --------
        //  x'    c     x            x + ck

        // where:
        // k  is m_diminishing_k for that class
        // c  is capArray for that class
        // x  is chance before DR (diminishValue)
        // x' is chance after DR (our result)

        var classIdx = (byte) playerClass.getValue() - 1;

        var k = m_diminishing_k[classIdx];
        var c = capArray[classIdx];

        var result = c * diminishValue / (diminishValue + c * k);
        result += nonDiminishValue;

        return result;
    }

    private float getGameTableColumnForCombatRating(GtCombatRatingsRecord row, CombatRating rating) {
        switch (rating) {
            case Amplify:
                return row.Amplify;
            case DefenseSkill:
                return row.DefenseSkill;
            case Dodge:
                return row.Dodge;
            case Parry:
                return row.Parry;
            case Block:
                return row.Block;
            case HitMelee:
                return row.HitMelee;
            case HitRanged:
                return row.HitRanged;
            case HitSpell:
                return row.HitSpell;
            case CritMelee:
                return row.CritMelee;
            case CritRanged:
                return row.CritRanged;
            case CritSpell:
                return row.CritSpell;
            case Corruption:
                return row.corruption;
            case CorruptionResistance:
                return row.CorruptionResistance;
            case Speed:
                return row.speed;
            case ResilienceCritTaken:
                return row.ResilienceCritTaken;
            case ResiliencePlayerDamage:
                return row.ResiliencePlayerDamage;
            case Lifesteal:
                return row.lifesteal;
            case HasteMelee:
                return row.HasteMelee;
            case HasteRanged:
                return row.HasteRanged;
            case HasteSpell:
                return row.HasteSpell;
            case Avoidance:
                return row.avoidance;
            case Studiness:
                return row.sturdiness;
            case Unused7:
                return row.unused7;
            case Expertise:
                return row.Expertise;
            case ArmorPenetration:
                return row.ArmorPenetration;
            case Mastery:
                return row.mastery;
            case PvpPower:
                return row.PvPPower;
            case Cleave:
                return row.Cleave;
            case VersatilityDamageDone:
                return row.VersatilityDamageDone;
            case VersatilityHealingDone:
                return row.VersatilityHealingDone;
            case VersatilityDamageTaken:
                return row.VersatilityDamageTaken;
            case Unused12:
                return row.Unused12;
            default:
                break;
        }

        return 1.0f;
    }

    private Stats getPrimaryStat() {
        byte primaryStatPriority;
        var specialization = CliDB.ChrSpecializationStorage.get(getPrimarySpecialization());

        if (specialization != null) {
            primaryStatPriority = (byte) specialization.PrimaryStatPriority;
        } else {
            primaryStatPriority = CliDB.ChrClassesStorage.get(getClass()).PrimaryStatPriority;
        }


        if (primaryStatPriority >= 4) {
            return stats.Strength;
        }

        if (primaryStatPriority >= 2) {
            return stats.Agility;
        }

        return stats.Intellect;
    }

    private float getHealthBonusFromStamina() {
        // Taken from PaperDollFrame.lua - 6.0.3.19085
        var ratio = 10.0f;
        var hpBase = CliDB.HpPerStaGameTable.GetRow(getLevel());

        if (hpBase != null) {
            ratio = hpBase.health;
        }

        var stamina = getStat(stats.Stamina);

        return stamina * ratio;
    }

    private void applyManaRegenBonus(int amount, boolean apply) {
        tangible.RefObject<Integer> tempRef__baseManaRegen = new tangible.RefObject<Integer>(baseManaRegen);
        tangible.RefObject<Integer> tempRef_amount = new tangible.RefObject<Integer>(amount);
        _ModifyUInt32(apply, tempRef__baseManaRegen, tempRef_amount);
        amount = tempRef_amount.refArgValue;
        baseManaRegen = tempRef__baseManaRegen.refArgValue;
        updateManaRegen();
    }

    private void applyHealthRegenBonus(int amount, boolean apply) {
        tangible.RefObject<Integer> tempRef__baseHealthRegen = new tangible.RefObject<Integer>(baseHealthRegen);
        tangible.RefObject<Integer> tempRef_amount = new tangible.RefObject<Integer>(amount);
        _ModifyUInt32(apply, tempRef__baseHealthRegen, tempRef_amount);
        amount = tempRef_amount.refArgValue;
        baseHealthRegen = tempRef__baseHealthRegen.refArgValue;
    }

    private void applySpellPowerBonus(int amount, boolean apply) {
        if (hasAuraType(AuraType.OverrideSpellPowerByApPct)) {
            return;
        }

        tangible.RefObject<Integer> tempRef__baseSpellPower = new tangible.RefObject<Integer>(baseSpellPower);
        tangible.RefObject<Integer> tempRef_amount = new tangible.RefObject<Integer>(amount);
        apply = _ModifyUInt32(apply, tempRef__baseSpellPower, tempRef_amount);
        amount = tempRef_amount.refArgValue;
        baseSpellPower = tempRef__baseSpellPower.refArgValue;

        // For speed just update for client
        applyModUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().modHealingDonePos), amount, apply);

        for (var spellSchool = SpellSchools.Holy; spellSchool.getValue() < SpellSchools.max.getValue(); ++spellSchool) {
            applyModDamageDonePos(spellSchool, amount, apply);
        }

        if (hasAuraType(AuraType.OverrideAttackPowerBySpPct)) {
            updateAttackPowerAndDamage();
            updateAttackPowerAndDamage(true);
        }
    }

    public final void initTalentForLevel() {
        var level = getLevel();

        // talents base at level diff (talents = level - 9 but some can be used already)
        if (level < PlayerConst.MinSpecializationLevel) {
            resetTalentSpecialization();
        }

        var talentTiers = global.getDB2Mgr().GetNumTalentsAtLevel(level, getClass());

        if (level < 10) {
            // Remove all talent points
            resetTalents(true);
        } else {
            if (!getSession().hasPermission(RBACPermissions.SkipCheckMoreTalentsThanAllowed)) {
                for (var t = talentTiers; t < PlayerConst.maxTalentTiers; ++t) {
                    for (int c = 0; c < PlayerConst.MaxTalentColumns; ++c) {
                        for (var talent : global.getDB2Mgr().GetTalentsByPosition(getClass(), t, c)) {
                            removeTalent(talent);
                        }
                    }
                }
            }
        }

        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().maxTalentTiers), talentTiers);

        if (!getSession().hasPermission(RBACPermissions.SkipCheckMoreTalentsThanAllowed)) {
            for (byte spec = 0; spec < PlayerConst.MaxSpecializations; ++spec) {
                for (var slot = global.getDB2Mgr().GetPvpTalentNumSlotsAtLevel(level, getClass()); slot < PlayerConst.MaxPvpTalentSlots; ++slot) {
                    var pvpTalent = CliDB.PvpTalentStorage.get(getPvpTalentMap(spec)[slot]);

                    if (pvpTalent != null) {
                        removePvpTalent(pvpTalent, spec);
                    }
                }
            }
        }

        if (!getSession().getPlayerLoading()) {
            sendTalentsInfoData(); // update at client
        }
    }


    public final boolean addTalent(TalentRecord talent, byte spec, boolean learning) {
        var spellInfo = global.getSpellMgr().getSpellInfo(talent.spellID, Difficulty.NONE);

        if (spellInfo == null) {
            Log.outError(LogFilter.spells, "Player.AddTalent: spell (ID: {0}) does not exist.", talent.spellID);

            return false;
        }

        if (!global.getSpellMgr().isSpellValid(spellInfo, this, false)) {
            Log.outError(LogFilter.spells, "Player.AddTalent: spell (ID: {0}) is invalid", talent.spellID);

            return false;
        }

        if (getTalentMap(spec).containsKey(talent.id)) {
            getTalentMap(spec).put(talent.id, PlayerSpellState.Unchanged);
        } else {
            getTalentMap(spec).put(talent.id, learning ? PlayerSpellState.New : PlayerSpellState.Unchanged);
        }

        if (spec == getActiveTalentGroup()) {
            learnSpell(talent.spellID, true);

            if (talent.OverridesSpellID != 0) {
                addOverrideSpell(talent.OverridesSpellID, talent.spellID);
            }
        }

        if (learning) {
            removeAurasWithInterruptFlags(SpellAuraInterruptFlags2.ChangeTalent);
        }

        return true;
    }

    public final void removeTalent(TalentRecord talent) {
        var spellInfo = global.getSpellMgr().getSpellInfo(talent.spellID, Difficulty.NONE);

        if (spellInfo == null) {
            return;
        }

        removeSpell(talent.spellID, true);

        // search for spells that the talent teaches and unlearn them
        for (var spellEffectInfo : spellInfo.getEffects()) {
            if (spellEffectInfo.isEffect(SpellEffectName.LearnSpell) && spellEffectInfo.triggerSpell > 0) {
                removeSpell(spellEffectInfo.triggerSpell, true);
            }
        }

        if (talent.OverridesSpellID != 0) {
            removeOverrideSpell(talent.OverridesSpellID, talent.spellID);
        }

        var talentMap = getTalentMap(getActiveTalentGroup());

        // if this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
        if (talentMap.containsKey(talent.id)) {
            talentMap.put(talent.id, PlayerSpellState.removed);
        }
    }


    public final TalentLearnResult learnTalent(int talentId, tangible.RefObject<Integer> spellOnCooldown) {
        if (isInCombat()) {
            return TalentLearnResult.FailedAffectingCombat;
        }

        if (isDead()) {
            return TalentLearnResult.FailedCantDoThatRightNow;
        }

        if (getPrimarySpecialization() == 0) {
            return TalentLearnResult.FailedNoPrimaryTreeSelected;
        }

        var talentInfo = CliDB.TalentStorage.get(talentId);

        if (talentInfo == null) {
            return TalentLearnResult.FailedUnknown;
        }

        if (talentInfo.specID != 0 && talentInfo.specID != getPrimarySpecialization()) {
            return TalentLearnResult.FailedUnknown;
        }

        // prevent learn talent for different class (cheating)
        if (talentInfo.classID != (byte) getClass().getValue()) {
            return TalentLearnResult.FailedUnknown;
        }

        // check if we have enough talent points
        if (talentInfo.TierID >= getActivePlayerData().maxTalentTiers) {
            return TalentLearnResult.FailedUnknown;
        }

        // TODO: prevent changing talents that are on cooldown

        // Check if there is a different talent for us to learn in selected slot
        // Example situation:
        // Warrior talent row 2 slot 0
        // Talent.dbc has an entry for each specialization
        // but only 2 out of 3 have specID != 0
        // We need to make sure that if player is in one of these defined specs he will not learn the other choice
        TalentRecord bestSlotMatch = null;

        for (var talent : global.getDB2Mgr().GetTalentsByPosition(getClass(), talentInfo.TierID, talentInfo.ColumnIndex)) {
            if (talent.specID == 0) {
                bestSlotMatch = talent;
            } else if (talent.specID == getPrimarySpecialization()) {
                bestSlotMatch = talent;

                break;
            }
        }

        if (talentInfo != bestSlotMatch) {
            return TalentLearnResult.FailedUnknown;
        }

        // Check if player doesn't have any talent in current tier
        for (int c = 0; c < PlayerConst.MaxTalentColumns; ++c) {
            for (var talent : global.getDB2Mgr().GetTalentsByPosition(getClass(), talentInfo.TierID, c)) {
                if (talent.specID != 0 && talent.specID != getPrimarySpecialization()) {
                    continue;
                }

                if (!hasTalent(talent.id, getActiveTalentGroup())) {
                    continue;
                }

                if (!hasPlayerFlag(playerFlags.Resting) && hasUnitFlag2(UnitFlag2.AllowChangingTalents)) {
                    return TalentLearnResult.FailedRestArea;
                }

                if (getSpellHistory().hasCooldown(talent.spellID)) {
                    spellOnCooldown.refArgValue = (int) talent.spellID;

                    return TalentLearnResult.FailedCantRemoveTalent;
                }

                removeTalent(talent);
            }
        }

        // spell not set in talent.dbc
        var spellid = talentInfo.spellID;

        if (spellid == 0) {
            Log.outError(LogFilter.player, "Player.LearnTalent: Talent.dbc has no spellInfo for talent: {0} (spell id = 0)", talentId);

            return TalentLearnResult.FailedUnknown;
        }

        // already known
        if (hasTalent(talentId, getActiveTalentGroup()) || hasSpell(spellid)) {
            return TalentLearnResult.FailedUnknown;
        }

        if (!addTalent(talentInfo, getActiveTalentGroup(), true)) {
            return TalentLearnResult.FailedUnknown;
        }

        Log.outDebug(LogFilter.misc, "Player.LearnTalent: TalentID: {0} Spell: {1} Group: {2}", talentId, spellid, getActiveTalentGroup());

        return TalentLearnResult.LearnOk;
    }

    public final void resetTalentSpecialization() {
        // Reset only talents that have different spells for each spec
        var class_ = getClass();

        for (int t = 0; t < PlayerConst.maxTalentTiers; ++t) {
            for (int c = 0; c < PlayerConst.MaxTalentColumns; ++c) {
                if (global.getDB2Mgr().GetTalentsByPosition(class_, t, c).size() > 1) {
                    for (var talent : global.getDB2Mgr().GetTalentsByPosition(class_, t, c)) {
                        removeTalent(talent);
                    }
                }
            }
        }

        resetPvpTalents();
        removeSpecializationSpells();

        var defaultSpec = global.getDB2Mgr().GetDefaultChrSpecializationForClass(getClass());
        setPrimarySpecialization(defaultSpec.id);
        setActiveTalentGroup(defaultSpec.orderIndex);

        learnSpecializationSpells();

        sendTalentsInfoData();
        updateItemSetAuras(false);
    }


    public final int getPrimarySpecialization() {
        return getPlayerData().currentSpecID;
    }

    private void setPrimarySpecialization(int spec) {
        setUpdateFieldValue(getValues().modifyValue(getPlayerData()).modifyValue(getPlayerData().currentSpecID), spec);
    }

    public final byte getActiveTalentGroup() {
        return specializationInfo.getActiveGroup();
    }

    private void setActiveTalentGroup(byte group) {
        specializationInfo.setActiveGroup(group);
    }

    public final int getLootSpecId() {
        return getActivePlayerData().lootSpecID;
    }

    // Loot Spec
    public final void setLootSpecId(int id) {
        setUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().lootSpecID), (short) id);
    }

    public final int getDefaultSpecId() {
        return global.getDB2Mgr().GetDefaultChrSpecializationForClass(getClass()).id;
    }

    public final void activateTalentGroup(ChrSpecializationRecord spec) {
        if (getActiveTalentGroup() == spec.orderIndex) {
            return;
        }

        if (isNonMeleeSpellCast(false)) {
            interruptNonMeleeSpells(false);
        }

        SQLTransaction trans = new SQLTransaction();
        _SaveActions(trans);
        DB.characters.CommitTransaction(trans);

        // TO-DO: We need more research to know what happens with warlock's reagent
        var pet = getCurrentPet();

        if (pet) {
            removePet(pet, PetSaveMode.NotInSlot);
        }

        clearAllReactives();
        unsummonAllTotems();
        exitVehicle();
        removeAllControlled();

        removeAurasWithInterruptFlags(SpellAuraInterruptFlags2.ChangeSpec);

        // remove single target auras at other targets
        var scAuras = getSingleCastAuras();

        for (var aura : scAuras) {
            if (aura.ownerAsUnit != this) {
                aura.remove();
            }
        }

        // Let client clear his current Actions
        sendActionButtons(2);

        for (var talentInfo : CliDB.TalentStorage.values()) {
            // unlearn only talents for character class
            // some spell learned by one class as normal spells or know at creation but another class learn it as talent,
            // to prevent unexpected lost normal learned spell skip another class talents
            if (talentInfo.classID != getClass().getValue()) {
                continue;
            }

            if (talentInfo.spellID == 0) {
                continue;
            }

            var spellInfo = global.getSpellMgr().getSpellInfo(talentInfo.spellID, Difficulty.NONE);

            if (spellInfo == null) {
                continue;
            }

            removeSpell(talentInfo.spellID, true);

            // search for spells that the talent teaches and unlearn them
            for (var spellEffectInfo : spellInfo.effects) {
                if (spellEffectInfo.isEffect(SpellEffectName.LearnSpell) && spellEffectInfo.triggerSpell > 0) {
                    removeSpell(spellEffectInfo.triggerSpell, true);
                }
            }

            if (talentInfo.OverridesSpellID != 0) {
                removeOverrideSpell(talentInfo.OverridesSpellID, talentInfo.spellID);
            }
        }

        for (var talentInfo : CliDB.PvpTalentStorage.values()) {
            var spellInfo = global.getSpellMgr().getSpellInfo(talentInfo.spellID, Difficulty.NONE);

            if (spellInfo == null) {
                continue;
            }

            removeSpell(talentInfo.spellID, true);

            // search for spells that the talent teaches and unlearn them
            for (var spellEffectInfo : spellInfo.effects) {
                if (spellEffectInfo.isEffect(SpellEffectName.LearnSpell) && spellEffectInfo.triggerSpell > 0) {
                    removeSpell(spellEffectInfo.triggerSpell, true);
                }
            }

            if (talentInfo.OverridesSpellID != 0) {
                removeOverrideSpell(talentInfo.OverridesSpellID, talentInfo.spellID);
            }
        }

        applyTraitConfig((int) getActivePlayerData().activeCombatTraitConfigID, false);

        // Remove spec specific spells
        removeSpecializationSpells();

        for (var glyphId : getGlyphs(getActiveTalentGroup())) {
            removeAura(CliDB.GlyphPropertiesStorage.get(glyphId).spellID);
        }

        setActiveTalentGroup(spec.orderIndex);
        setPrimarySpecialization(spec.id);
        var specTraitConfigIndex = getActivePlayerData().traitConfigs.FindIndexIf(traitConfig ->
        {
            return TraitConfigType.forValue((int) traitConfig.type) == TraitConfigType.Combat && traitConfig.chrSpecializationID == spec.id && (TraitCombatConfigFlags.forValue((int) traitConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) != TraitCombatConfigFlags.NONE.getValue();
        });

        if (specTraitConfigIndex >= 0) {
            setActiveCombatTraitConfigID(getActivePlayerData().traitConfigs.get(specTraitConfigIndex).ID);
        } else {
            setActiveCombatTraitConfigID(0);
        }

        for (var talentInfo : CliDB.TalentStorage.values()) {
            // learn only talents for character class
            if (talentInfo.classID != getClass().getValue()) {
                continue;
            }

            if (talentInfo.spellID == 0) {
                continue;
            }

            if (hasTalent(talentInfo.id, getActiveTalentGroup())) {
                learnSpell(talentInfo.spellID, true); // add the talent to the PlayerSpellMap

                if (talentInfo.OverridesSpellID != 0) {
                    addOverrideSpell(talentInfo.OverridesSpellID, talentInfo.spellID);
                }
            }
        }

        for (byte slot = 0; slot < PlayerConst.MaxPvpTalentSlots; ++slot) {
            var talentInfo = CliDB.PvpTalentStorage.get(getPvpTalentMap(getActiveTalentGroup())[slot]);

            if (talentInfo == null) {
                continue;
            }

            if (talentInfo.spellID == 0) {
                continue;
            }

            addPvpTalent(talentInfo, getActiveTalentGroup(), slot);
        }

        learnSpecializationSpells();

        if (canUseMastery()) {
            for (int i = 0; i < PlayerConst.MaxMasterySpells; ++i) {
                var mastery = spec.MasterySpellID[i];

                if (mastery != 0) {
                    learnSpell(mastery, true);
                }
            }
        }

        applyTraitConfig((int) getActivePlayerData().activeCombatTraitConfigID, true);

        initTalentForLevel();

        startLoadingActionButtons();

        updateDisplayPower();
        var pw = getDisplayPowerType();

        if (pw != powerType.mana) {
            setPower(powerType.mana, 0); // Mana must be 0 even if it isn't the active power type.
        }

        setPower(pw, 0);
        updateItemSetAuras(false);

        // update visible transmog
        for (var i = EquipmentSlot.start; i < EquipmentSlot.End; ++i) {
            var equippedItem = getItemByPos(InventorySlots.Bag0, i);

            if (equippedItem) {
                setVisibleItemSlot(i, equippedItem);
            }
        }

        for (var glyphId : getGlyphs(spec.orderIndex)) {
            castSpell(this, CliDB.GlyphPropertiesStorage.get(glyphId).spellID, true);
        }

        ActiveGlyphs activeGlyphs = new ActiveGlyphs();

        for (var glyphId : getGlyphs(spec.orderIndex)) {
            var bindableSpells = global.getDB2Mgr().GetGlyphBindableSpells(glyphId);

            for (var bindableSpell : bindableSpells) {
                if (hasSpell(bindableSpell) && !overrideSpells.ContainsKey(bindableSpell)) {
                    activeGlyphs.glyphs.add(new GlyphBinding(bindableSpell, (short) glyphId));
                }
            }
        }

        activeGlyphs.isFullUpdate = true;
        sendPacket(activeGlyphs);

        var item = getItemByEntry(PlayerConst.ItemIdHeartOfAzeroth, ItemSearchLocation.Everywhere);

        if (item != null) {
            var azeriteItem = item.getAsAzeriteItem();

            if (azeriteItem != null) {
                if (azeriteItem.isEquipped()) {
                    applyAllAzeriteEmpoweredItemMods(false);
                    applyAzeritePowers(azeriteItem, false);
                }

                azeriteItem.SetSelectedAzeriteEssences(spec.id);

                if (azeriteItem.isEquipped()) {
                    applyAzeritePowers(azeriteItem, true);
                    applyAllAzeriteEmpoweredItemMods(true);
                }

                azeriteItem.setState(ItemUpdateState.changed, this);
            }
        }

        var shapeshiftAuras = getAuraEffectsByType(AuraType.ModShapeshift);

        for (var aurEff : shapeshiftAuras) {
            aurEff.handleShapeshiftBoosts(this, false);
            aurEff.handleShapeshiftBoosts(this, true);
        }
    }

    public final HashMap<Integer, PlayerSpellState> getTalentMap(int spec) {
        return specializationInfo.getTalents()[spec];
    }

    public final ArrayList<Integer> getGlyphs(byte spec) {
        return specializationInfo.getGlyphs()[spec];
    }

    public final int getNextResetTalentsCost() {
        // The first time reset costs 1 gold
        if (getTalentResetCost() < 1 * MoneyConstants.gold) {
            return 1 * MoneyConstants.gold;
        }
        // then 5 gold
        else if (getTalentResetCost() < 5 * MoneyConstants.gold) {
            return 5 * MoneyConstants.gold;
        }
        // After that it increases in increments of 5 gold
        else if (getTalentResetCost() < 10 * MoneyConstants.gold) {
            return 10 * MoneyConstants.gold;
        } else {
            var months = (long) (gameTime.GetGameTime() - getTalentResetTime()) / time.Month;

            if (months > 0) {
                // This cost will be reduced by a rate of 5 gold per month
                var new_cost = (int) (getTalentResetCost() - 5 * MoneyConstants.Gold * months);

                // to a minimum of 10 gold.
                return new_cost < 10 * MoneyConstants.Gold ? 10 * MoneyConstants.Gold : new_cost;
            } else {
                // After that it increases in increments of 5 gold
                var new_cost = getTalentResetCost() + 5 * MoneyConstants.gold;

                // until it hits a cap of 50 gold.
                if (new_cost > 50 * MoneyConstants.gold) {
                    new_cost = 50 * MoneyConstants.gold;
                }

                return new_cost;
            }
        }
    }

    public final boolean resetTalents() {
        return resetTalents(false);
    }

    public final boolean resetTalents(boolean noCost) {
        global.getScriptMgr().<IPlayerOnTalentsReset>ForEach(p -> p.OnTalentsReset(this, noCost));

        // not need after this call
        if (hasAtLoginFlag(AtLoginFlags.ResetTalents)) {
            removeAtLoginFlag(AtLoginFlags.ResetTalents, true);
        }

        int cost = 0;

        if (!noCost && !WorldConfig.getBoolValue(WorldCfg.NoResetTalentCost)) {
            cost = getNextResetTalentsCost();

            if (!hasEnoughMoney(cost)) {
                sendBuyError(BuyResult.NotEnoughtMoney, null, 0);

                return false;
            }
        }

        removePet(null, PetSaveMode.NotInSlot, true);

        for (var talentInfo : CliDB.TalentStorage.values()) {
            // unlearn only talents for character class
            // some spell learned by one class as normal spells or know at creation but another class learn it as talent,
            // to prevent unexpected lost normal learned spell skip another class talents
            if (talentInfo.classID != (int) getClass().getValue()) {
                continue;
            }

            // skip non-existant talent ranks
            if (talentInfo.spellID == 0) {
                continue;
            }

            removeTalent(talentInfo);
        }

        SQLTransaction trans = new SQLTransaction();
        _SaveTalents(trans);
        _SaveSpells(trans);
        DB.characters.CommitTransaction(trans);

        if (!noCost) {
            modifyMoney(-cost);
            updateCriteria(CriteriaType.MoneySpentOnRespecs, cost);
            updateCriteria(CriteriaType.TotalRespecs, 1);

            setTalentResetCost(cost);
            setTalentResetTime(gameTime.GetGameTime());
        }

        return true;
    }

    public final void sendTalentsInfoData() {
        UpdateTalentData packet = new UpdateTalentData();
        packet.info.primarySpecialization = getPrimarySpecialization();

        for (byte i = 0; i < PlayerConst.MaxSpecializations; ++i) {
            var spec = global.getDB2Mgr().GetChrSpecializationByIndex(getClass(), i);

            if (spec == null) {
                continue;
            }

            var talents = getTalentMap(i);
            var pvpTalents = getPvpTalentMap(i);

            UpdateTalentData.TalentGroupInfo groupInfoPkt = new UpdateTalentData.TalentGroupInfo();
            groupInfoPkt.specID = spec.id;

            for (var pair : talents.entrySet()) {
                if (pair.getValue() == PlayerSpellState.removed) {
                    continue;
                }

                var talentInfo = CliDB.TalentStorage.get(pair.getKey());

                if (talentInfo == null) {
                    Log.outError(LogFilter.player, "Player {0} has unknown talent id: {1}", getName(), pair.getKey());

                    continue;
                }

                var spellEntry = global.getSpellMgr().getSpellInfo(talentInfo.spellID, Difficulty.NONE);

                if (spellEntry == null) {
                    Log.outError(LogFilter.player, "Player {0} has unknown talent spell: {1}", getName(), talentInfo.spellID);

                    continue;
                }

                groupInfoPkt.talentIDs.add((short) pair.getKey());
            }

            for (byte slot = 0; slot < PlayerConst.MaxPvpTalentSlots; ++slot) {
                if (pvpTalents[slot] == 0) {
                    continue;
                }

                var talentInfo = CliDB.PvpTalentStorage.get(pvpTalents[slot]);

                if (talentInfo == null) {
                    Log.outError(LogFilter.player, String.format("Player.SendTalentsInfoData: Player '%1$s' (%2$s) has unknown pvp talent id: %3$s", getName(), getGUID(), pvpTalents[slot]));

                    continue;
                }

                var spellEntry = global.getSpellMgr().getSpellInfo(talentInfo.spellID, Difficulty.NONE);

                if (spellEntry == null) {
                    Log.outError(LogFilter.player, String.format("Player.SendTalentsInfoData: Player '%1$s' (%2$s) has unknown pvp talent spell: %3$s", getName(), getGUID(), talentInfo.spellID));

                    continue;
                }

                PvPTalent pvpTalent = new PvPTalent();
                pvpTalent.pvPTalentID = (short) pvpTalents[slot];
                pvpTalent.slot = slot;
                groupInfoPkt.pvPTalents.add(pvpTalent);
            }

            if (i == getActiveTalentGroup()) {
                packet.info.activeGroup = (byte) packet.info.talentGroups.size();
            }

            if (!groupInfoPkt.talentIDs.isEmpty() || !groupInfoPkt.pvPTalents.isEmpty() || i == getActiveTalentGroup()) {
                packet.info.talentGroups.add(groupInfoPkt);
            }
        }

        sendPacket(packet);
    }

    public final void sendRespecWipeConfirm(ObjectGuid guid, int cost, SpecResetType respecType) {
        RespecWipeConfirm respecWipeConfirm = new RespecWipeConfirm();
        respecWipeConfirm.respecMaster = guid;
        respecWipeConfirm.cost = cost;
        respecWipeConfirm.respecType = respecType;
        sendPacket(respecWipeConfirm);
    }

    public final TalentLearnResult learnPvpTalent(int talentID, byte slot, tangible.RefObject<Integer> spellOnCooldown) {
        if (slot >= PlayerConst.MaxPvpTalentSlots) {
            return TalentLearnResult.FailedUnknown;
        }

        if (isInCombat()) {
            return TalentLearnResult.FailedAffectingCombat;
        }

        if (isDead()) {
            return TalentLearnResult.FailedCantDoThatRightNow;
        }

        var talentInfo = CliDB.PvpTalentStorage.get(talentID);

        if (talentInfo == null) {
            return TalentLearnResult.FailedUnknown;
        }

        if (talentInfo.specID != getPrimarySpecialization()) {
            return TalentLearnResult.FailedUnknown;
        }

        if (talentInfo.LevelRequired > getLevel()) {
            return TalentLearnResult.FailedUnknown;
        }

        if (global.getDB2Mgr().GetRequiredLevelForPvpTalentSlot(slot, getClass()) > getLevel()) {
            return TalentLearnResult.FailedUnknown;
        }

        var talentCategory = CliDB.PvpTalentCategoryStorage.get(talentInfo.PvpTalentCategoryID);

        if (talentCategory != null) {
            if (!(boolean) (talentCategory.TalentSlotMask & (1 << slot))) {
                return TalentLearnResult.FailedUnknown;
            }
        }

        // Check if player doesn't have this talent in other slot
        if (hasPvpTalent(talentID, getActiveTalentGroup())) {
            return TalentLearnResult.FailedUnknown;
        }

        var playerCondition = CliDB.PlayerConditionStorage.get(talentInfo.playerConditionID);

        if (playerCondition != null) {
            if (!ConditionManager.isPlayerMeetingCondition(this, playerCondition)) {
                return TalentLearnResult.FailedCantDoThatRightNow;
            }
        }

        var talent = CliDB.PvpTalentStorage.get(getPvpTalentMap(getActiveTalentGroup())[slot]);

        if (talent != null) {
            if (!hasPlayerFlag(playerFlags.Resting) && !hasUnitFlag2(UnitFlag2.AllowChangingTalents)) {
                return TalentLearnResult.FailedRestArea;
            }

            if (getSpellHistory().hasCooldown(talent.spellID)) {
                spellOnCooldown.refArgValue = talent.spellID;

                return TalentLearnResult.FailedCantRemoveTalent;
            }

            removePvpTalent(talent, getActiveTalentGroup());
        }

        if (!addPvpTalent(talentInfo, getActiveTalentGroup(), slot)) {
            return TalentLearnResult.FailedUnknown;
        }

        return TalentLearnResult.LearnOk;
    }

    public final void togglePvpTalents(boolean enable) {
        var pvpTalents = getPvpTalentMap(getActiveTalentGroup());

        for (var pvpTalentId : pvpTalents) {
            var pvpTalentInfo = CliDB.PvpTalentStorage.get(pvpTalentId);

            if (pvpTalentInfo != null) {
                if (enable) {
                    learnSpell(pvpTalentInfo.spellID, false);

                    if (pvpTalentInfo.OverridesSpellID != 0) {
                        addOverrideSpell(pvpTalentInfo.OverridesSpellID, pvpTalentInfo.spellID);
                    }
                } else {
                    if (pvpTalentInfo.OverridesSpellID != 0) {
                        removeOverrideSpell(pvpTalentInfo.OverridesSpellID, pvpTalentInfo.spellID);
                    }

                    removeSpell(pvpTalentInfo.spellID, true);
                }
            }
        }
    }

    //Traits
    public final void createTraitConfig(TraitConfigPacket traitConfig) {
        var configId = TraitMgr.generateNewTraitConfigId();

// C# TO JAVA CONVERTER TASK: Local functions are not converted by C# to Java Converter:
//		bool hasConfigId(int id)
//			{
//				return activePlayerData.traitConfigs.FindIndexIf(config => config.ID == id) >= 0;
//			}

        while (hasConfigId(configId)) {
            configId = TraitMgr.generateNewTraitConfigId();
        }

        traitConfig.ID = configId;

        var traitConfigIndex = getActivePlayerData().traitConfigs.size();
        addTraitConfig(traitConfig);

        for (var grantedEntry : TraitMgr.getGrantedTraitEntriesForConfig(traitConfig, this)) {
            var entryIndex = traitConfig.entries.get(grantedEntry.traitNodeID) == null ? null : traitConfig.entries.get(grantedEntry.traitNodeID).get(grantedEntry.traitNodeEntryID);

            if (entryIndex == null) {
                TraitConfig value = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, traitConfigIndex);
                addDynamicUpdateFieldValue(value.modifyValue(value.entries), grantedEntry);
            }
        }

        traitConfigStates.put((int) configId, PlayerSpellState.changed);
    }

    public final TraitConfig getTraitConfig(int configId) {
        var index = getActivePlayerData().traitConfigs.FindIndexIf(config -> config.ID == configId);

        if (index < 0) {
            return null;
        }

        return getActivePlayerData().traitConfigs.get(index);
    }

    public final void updateTraitConfig(TraitConfigPacket newConfig, int savedConfigId, boolean withCastTime) {
        var index = getActivePlayerData().traitConfigs.FindIndexIf(config -> config.ID == newConfig.ID);

        if (index < 0) {
            return;
        }

        if (withCastTime) {
            castSpell(this, TraitMgr.COMMIT_COMBAT_TRAIT_CONFIG_CHANGES_SPELL_ID, (new CastSpellExtraArgs(SpellValueMod.BasePoint0, savedConfigId)).setCustomArg(newConfig));

            return;
        }

        var isActiveConfig = true;
        var loadActionButtons = false;

        switch (TraitConfigType.forValue((int) getActivePlayerData().traitConfigs.get(index).type)) {
            case Combat:
                isActiveConfig = newConfig.ID == getActivePlayerData().activeCombatTraitConfigID;
                loadActionButtons = getActivePlayerData().traitConfigs.get(index).localIdentifier != newConfig.localIdentifier;

                break;
            case Profession:
                isActiveConfig = hasSkill((int) getActivePlayerData().TraitConfigs[index].skillLineID);

                break;
            default:
                break;
        }

        var finalizeTraitConfigUpdate = () ->
        {
            TraitConfig newTraitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, index);
            setUpdateFieldValue(newTraitConfig.modifyValue(newTraitConfig.localIdentifier), newConfig.localIdentifier);

            applyTraitEntryChanges(newConfig.ID, newConfig, isActiveConfig, true);

            if (savedConfigId != 0) {
                applyTraitEntryChanges(savedConfigId, newConfig, false, false);
            }

            if ((TraitCombatConfigFlags.forValue(newConfig.combatConfigFlags.getValue())).hasFlag(TraitCombatConfigFlags.StarterBuild)) {
                setTraitConfigUseStarterBuild(newConfig.ID, true);
            }
        };

        if (loadActionButtons) {
            var trans = new SQLTransaction();
            _SaveActions(trans);
            DB.characters.CommitTransaction(trans);

            startLoadingActionButtons(finalizeTraitConfigUpdate);
        } else {
            finalizeTraitConfigUpdate();
        }
    }

    public final void renameTraitConfig(int editedConfigId, String newName) {
        var editedIndex = getActivePlayerData().traitConfigs.FindIndexIf(traitConfig ->
        {
            return traitConfig.ID == editedConfigId && TraitConfigType.forValue((int) traitConfig.type) == TraitConfigType.Combat && (TraitCombatConfigFlags.forValue((int) traitConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) == TraitCombatConfigFlags.NONE.getValue();
        });

        if (editedIndex < 0) {
            return;
        }

        TraitConfig traitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, editedIndex);
        setUpdateFieldValue(traitConfig.modifyValue(traitConfig.name), newName);

        traitConfigStates.put(editedConfigId, PlayerSpellState.changed);
    }

    public final void deleteTraitConfig(int deletedConfigId) {
        var deletedIndex = getActivePlayerData().traitConfigs.FindIndexIf(traitConfig ->
        {
            return traitConfig.ID == deletedConfigId && TraitConfigType.forValue((int) traitConfig.type) == TraitConfigType.Combat && (TraitCombatConfigFlags.forValue((int) traitConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) == TraitCombatConfigFlags.NONE.getValue();
        });

        if (deletedIndex < 0) {
            return;
        }

        removeDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs), deletedIndex);

        traitConfigStates.put(deletedConfigId, PlayerSpellState.removed);
    }

    public final void setTraitConfigUseStarterBuild(int traitConfigId, boolean useStarterBuild) {
        var configIndex = getActivePlayerData().traitConfigs.FindIndexIf(traitConfig ->
        {
            return traitConfig.ID == traitConfigId && TraitConfigType.forValue((int) traitConfig.type) == TraitConfigType.Combat && (TraitCombatConfigFlags.forValue((int) traitConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) != TraitCombatConfigFlags.NONE.getValue();
        });

        if (configIndex < 0) {
            return;
        }

        var currentlyUsesStarterBuild = (TraitCombatConfigFlags.forValue((int) getActivePlayerData().traitConfigs.get(configIndex).combatConfigFlags)).hasFlag(TraitCombatConfigFlags.StarterBuild);

        if (currentlyUsesStarterBuild == useStarterBuild) {
            return;
        }

        if (useStarterBuild) {
            TraitConfig traitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, configIndex);
            setUpdateFieldFlagValue(traitConfig.modifyValue(traitConfig.combatConfigFlags), TraitCombatConfigFlags.StarterBuild.getValue());
        } else {
            TraitConfig traitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, configIndex);
            removeUpdateFieldFlagValue(traitConfig.modifyValue(traitConfig.combatConfigFlags), TraitCombatConfigFlags.StarterBuild.getValue());
        }

        traitConfigStates.put((int) traitConfigId, PlayerSpellState.changed);
    }

    public final void setTraitConfigUseSharedActionBars(int traitConfigId, boolean usesSharedActionBars, boolean isLastSelectedSavedConfig) {
        var configIndex = getActivePlayerData().traitConfigs.FindIndexIf(traitConfig ->
        {
            return traitConfig.ID == traitConfigId && TraitConfigType.forValue((int) traitConfig.type) == TraitConfigType.Combat && (TraitCombatConfigFlags.forValue((int) traitConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) == TraitCombatConfigFlags.NONE.getValue();
        });

        if (configIndex < 0) {
            return;
        }

        var currentlyUsesSharedActionBars = (TraitCombatConfigFlags.forValue((int) getActivePlayerData().traitConfigs.get(configIndex).combatConfigFlags)).hasFlag(TraitCombatConfigFlags.SharedActionBars);

        if (currentlyUsesSharedActionBars == usesSharedActionBars) {
            return;
        }

        TraitConfig traitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, configIndex);

        if (usesSharedActionBars) {
            setUpdateFieldFlagValue(traitConfig.modifyValue(traitConfig.combatConfigFlags), TraitCombatConfigFlags.SharedActionBars.getValue());

            var stmt = DB.characters.GetPreparedStatement(CharStatements.DEL_CHAR_ACTION_BY_TRAIT_CONFIG);
            stmt.AddValue(0, getGUID().getCounter());
            stmt.AddValue(1, traitConfigId);
            DB.characters.execute(stmt);

            if (isLastSelectedSavedConfig) {
                startLoadingActionButtons(); // load action buttons that were saved in shared mode
            }
        } else {
            removeUpdateFieldFlagValue(traitConfig.modifyValue(traitConfig.combatConfigFlags), TraitCombatConfigFlags.SharedActionBars.getValue());

            // trigger a save with traitConfigId
// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(_, button) : actionButtons) {
                if (button.UState != ActionButtonUpdateState.Deleted) {
                    button.UState = ActionButtonUpdateState.New;
                }
            }
        }

        traitConfigStates.put(traitConfigId, PlayerSpellState.changed);
    }

    private boolean hasTalent(int talentId, byte group) {
        return getTalentMap(group).containsKey(talentId) && !getTalentMap(group).get(talentId).equals(PlayerSpellState.removed);
    }

    private int getTalentResetCost() {
        return specializationInfo.getResetTalentsCost();
    }

    private void setTalentResetCost(int cost) {
        specializationInfo.setResetTalentsCost(cost);
    }

    private long getTalentResetTime() {
        return specializationInfo.getResetTalentsTime();
    }

    private void setTalentResetTime(long time_) {
        specializationInfo.setResetTalentsTime(time_);
    }

    private void startLoadingActionButtons() {
        startLoadingActionButtons(null);
    }

    private void startLoadingActionButtons(tangible.Action0Param callback) {
        int traitConfigId = 0;

        var traitConfig = getTraitConfig((int) getActivePlayerData().activeCombatTraitConfigID);

        if (traitConfig != null) {
            var usedSavedTraitConfigIndex = getActivePlayerData().traitConfigs.FindIndexIf(savedConfig ->
            {
                return TraitConfigType.forValue((int) savedConfig.type) == TraitConfigType.Combat && (TraitCombatConfigFlags.forValue((int) savedConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.ActiveForSpec.getValue()) == TraitCombatConfigFlags.NONE.getValue() && (TraitCombatConfigFlags.forValue((int) savedConfig.combatConfigFlags).getValue() & TraitCombatConfigFlags.SharedActionBars.getValue()) == TraitCombatConfigFlags.NONE.getValue() && savedConfig.localIdentifier == traitConfig.localIdentifier;
            });

            if (usedSavedTraitConfigIndex >= 0) {
                traitConfigId = (int) (int) getActivePlayerData().TraitConfigs[usedSavedTraitConfigIndex].ID;
            }
        }

        // load them asynchronously
        var stmt = DB.characters.GetPreparedStatement(CharStatements.SEL_CHARACTER_ACTIONS_SPEC);
        stmt.AddValue(0, getGUID().getCounter());
        stmt.AddValue(1, getActiveTalentGroup());
        stmt.AddValue(2, traitConfigId);

        var myGuid = getGUID();

        var mySess = getSession();

        mySess.getQueryProcessor().AddCallback(DB.characters.AsyncQuery(stmt).WithCallback(result ->
        {
            // safe callback, we can't pass this pointer directly
            // in case player logs out before db response (player would be deleted in that case)
            var thisPlayer = mySess.getPlayer();

            if (thisPlayer != null && Objects.equals(thisPlayer.getGUID(), myGuid)) {
                thisPlayer.loadActions(result);
            }

            if (callback != null) {
                callback.invoke();
            }
        }));
    }

    //Pvp
    private void resetPvpTalents() {
        for (byte spec = 0; spec < PlayerConst.MaxSpecializations; ++spec) {
            for (var talentId : getPvpTalentMap(spec)) {
                var talentInfo = CliDB.PvpTalentStorage.get(talentId);

                if (talentInfo != null) {
                    removePvpTalent(talentInfo, spec);
                }
            }
        }
    }


    private boolean addPvpTalent(PvpTalentRecord talent, byte activeTalentGroup, byte slot) {
        //ASSERT(talent);
        var spellInfo = global.getSpellMgr().getSpellInfo(talent.spellID, Difficulty.NONE);

        if (spellInfo == null) {
            Log.outError(LogFilter.spells, String.format("Player.AddPvpTalent: spell (ID: %1$s) does not exist.", talent.spellID));

            return false;
        }

        if (!global.getSpellMgr().isSpellValid(spellInfo, this, false)) {
            Log.outError(LogFilter.spells, String.format("Player.AddPvpTalent: spell (ID: %1$s) is invalid", talent.spellID));

            return false;
        }

        if (activeTalentGroup == getActiveTalentGroup() && hasAuraType(AuraType.pvpTalents)) {
            learnSpell(talent.spellID, true);

            // Move this to toggle ?
            if (talent.OverridesSpellID != 0) {
                addOverrideSpell(talent.OverridesSpellID, talent.spellID);
            }
        }

        getPvpTalentMap(activeTalentGroup)[slot] = talent.id;

        return true;
    }


    private void removePvpTalent(PvpTalentRecord talent, byte activeTalentGroup) {
        var spellInfo = global.getSpellMgr().getSpellInfo(talent.spellID, Difficulty.NONE);

        if (spellInfo == null) {
            return;
        }

        removeSpell(talent.spellID, true);

        // Move this to toggle ?
        if (talent.OverridesSpellID != 0) {
            removeOverrideSpell(talent.OverridesSpellID, talent.spellID);
        }

        // if this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
        var talents = getPvpTalentMap(activeTalentGroup);

        for (var i = 0; i < PlayerConst.MaxPvpTalentSlots; ++i) {
            if (talents[i] == talent.id) {
                talents[i] = 0;
            }
        }
    }


    private boolean hasPvpTalent(int talentID, byte activeTalentGroup) {
        return getPvpTalentMap(activeTalentGroup).contains(talentID);
    }

    private void addTraitConfig(TraitConfigPacket traitConfig) {
        var setter = new TraitConfig();
        setter.modifyValue(setter.ID).setValue(traitConfig.ID);
        setter.modifyValue(setter.name).setValue(traitConfig.name);
        setter.modifyValue(setter.type).setValue(traitConfig.type.getValue());
        setter.modifyValue(setter.skillLineID).setValue(traitConfig.skillLineID);
        setter.modifyValue(setter.chrSpecializationID).setValue(traitConfig.chrSpecializationID);
        setter.modifyValue(setter.combatConfigFlags).setValue(traitConfig.combatConfigFlags.getValue());
        setter.modifyValue(setter.localIdentifier).setValue(traitConfig.localIdentifier);
        setter.modifyValue(setter.traitSystemID).setValue(traitConfig.traitSystemID);

        addDynamicUpdateFieldValue(getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs), setter);

        for (var kvp : traitConfig.entries.values()) {
            for (var traitEntry : kvp.VALUES) {
                TraitEntry newEntry = new TraitEntry();
                newEntry.traitNodeID = traitEntry.traitNodeID;
                newEntry.traitNodeEntryID = traitEntry.traitNodeEntryID;
                newEntry.rank = traitEntry.rank;
                newEntry.grantedRanks = traitEntry.grantedRanks;
                addDynamicUpdateFieldValue(setter.modifyValue(setter.entries), newEntry);
            }
        }
    }

    private void applyTraitEntryChanges(int editedConfigId, TraitConfigPacket newConfig, boolean applyTraits, boolean consumeCurrencies) {
        var editedIndex = getActivePlayerData().traitConfigs.FindIndexIf(config -> config.ID == editedConfigId);

        if (editedIndex < 0) {
            return;
        }

        var editedConfig = getActivePlayerData().traitConfigs.get(editedIndex);

        // remove traits not found in new config
        ArrayList<Integer> entryIndicesToRemove = new ArrayList<>();

        for (var i = 0; i < editedConfig.entries.size(); ++i) {
            var oldEntry = editedConfig.entries.get(i);
            var entryItr = newConfig.entries.get(oldEntry.traitNodeID) == null ? null : newConfig.entries.get(oldEntry.traitNodeID).get(oldEntry.traitNodeEntryID);

            if (entryItr != null) {
                continue;
            }

            if (applyTraits) {
                applyTraitEntry(oldEntry.traitNodeEntryID, 0, 0, false);
            }

            entryIndicesToRemove.add(i);
        }

        for (var indexToRemove : entryIndicesToRemove) {
            TraitConfig traitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, editedIndex);
            removeDynamicUpdateFieldValue(traitConfig.modifyValue(traitConfig.entries), indexToRemove);
        }

        ArrayList<TraitEntryPacket> costEntries = new ArrayList<>();

        // apply new traits
        for (var kvp : newConfig.entries.values()) {
            for (var newEntry : kvp.VALUES) {
                var oldEntryIndex = editedConfig.entries.FindIndexIf(ufEntry -> ufEntry.traitNodeID == newEntry.traitNodeID && ufEntry.traitNodeEntryID == newEntry.traitNodeEntryID);

                if (oldEntryIndex < 0) {
                    if (consumeCurrencies) {
                        costEntries.add(newEntry);
                    }

                    TraitConfig newTraitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, editedIndex);
                    TraitEntry newUfEntry = new TraitEntry();
                    newUfEntry.traitNodeID = newEntry.traitNodeID;
                    newUfEntry.traitNodeEntryID = newEntry.traitNodeEntryID;
                    newUfEntry.rank = newEntry.rank;
                    newUfEntry.grantedRanks = newEntry.grantedRanks;

                    addDynamicUpdateFieldValue(newTraitConfig.modifyValue(newTraitConfig.entries), newUfEntry);

                    if (applyTraits) {
                        applyTraitEntry(newUfEntry.traitNodeEntryID, newUfEntry.rank, 0, true);
                    }
                } else if (newEntry.rank != editedConfig.entries.get(oldEntryIndex).rank || newEntry.grantedRanks != editedConfig.entries.get(oldEntryIndex).grantedRanks) {
                    if (consumeCurrencies && newEntry.rank > editedConfig.entries.get(oldEntryIndex).rank) {
                        TraitEntryPacket costEntry = new TraitEntryPacket();
                        costEntry.Rank -= editedConfig.entries.get(oldEntryIndex).rank;
                        costEntries.add(newEntry);
                    }

                    TraitConfig traitConfig = getValues().modifyValue(getActivePlayerData()).modifyValue(getActivePlayerData().traitConfigs, editedIndex);
                    TraitEntry traitEntry = traitConfig.modifyValue(traitConfig.entries, oldEntryIndex);
                    traitEntry.rank = newEntry.rank;
                    traitEntry.grantedRanks = newEntry.grantedRanks;
                    setUpdateFieldValue(traitConfig.entries, oldEntryIndex, traitEntry);

                    if (applyTraits) {
                        applyTraitEntry(newEntry.traitNodeEntryID, newEntry.rank, newEntry.grantedRanks, true);
                    }
                }
            }
        }

        if (consumeCurrencies) {
            HashMap<Integer, Integer> currencies = new HashMap<Integer, Integer>();

            for (var costEntry : costEntries) {
                TraitMgr.fillSpentCurrenciesMap(costEntry, currencies);
            }

// C# TO JAVA CONVERTER TASK: Java has no equivalent to C# deconstruction declarations:
            for (var(traitCurrencyId, amount) : currencies) {
                var traitCurrency = CliDB.TraitCurrencyStorage.get(traitCurrencyId);

                if (traitCurrency == null) {
                    continue;
                }

                switch (traitCurrency.GetCurrencyType()) {
                    case TraitCurrencyType.Gold:
                        modifyMoney(-amount);

                        break;
                    case TraitCurrencyType.CurrencyTypesBased:
                        removeCurrency((int) traitCurrency.CurrencyTypesID, amount);

                        break;
                    default:
                        break;
                }
            }
        }

        traitConfigStates.put((int) editedConfigId, PlayerSpellState.changed);
    }

    private void applyTraitConfig(int configId, boolean apply) {
        var traitConfig = getTraitConfig(configId);

        if (traitConfig == null) {
            return;
        }

        for (var traitEntry : traitConfig.entries) {
            applyTraitEntry(traitEntry.traitNodeEntryID, traitEntry.rank, traitEntry.grantedRanks, apply);
        }
    }

    private void applyTraitEntry(int traitNodeEntryId, int rank, int grantedRanks, boolean apply) {
        var traitNodeEntry = CliDB.TraitNodeEntryStorage.get(traitNodeEntryId);

        if (traitNodeEntry == null) {
            return;
        }

        var traitDefinition = CliDB.TraitDefinitionStorage.get(traitNodeEntry.traitDefinitionID);

        if (traitDefinition == null) {
            return;
        }

        if (traitDefinition.spellID != 0) {
            if (apply) {
                learnSpell(traitDefinition.spellID, true, 0, false, traitNodeEntry.traitDefinitionID);
            } else {
                removeSpell(traitDefinition.spellID);
            }
        }
    }

    // C# TO JAVA CONVERTER TASK: Java does not allow delegate parameter default values:
    @FunctionalInterface
    private interface EquipmentSlotDelegate {
        void invoke(byte equipmentSlot, boolean checkDuplicateGuid);
    }

    private static class ValuesUpdateForPlayerWithMaskSender implements IDoWork<Player> {
        private final Player owner;
        private final objectFieldData objectMask = new objectFieldData();
        private final unitData unitMask = new unitData();
        private final PlayerData playerMask = new playerData();
        private final ActivePlayerData activePlayerMask = new activePlayerData();

        public ValuesUpdateForPlayerWithMaskSender(Player owner) {
            owner = owner;
        }

        public final void invoke(Player player) {
            UpdateData udata = new UpdateData(owner.getLocation().getMapId());

            owner.buildValuesUpdateForPlayerWithMask(udata, objectMask.getUpdateMask(), unitMask.getUpdateMask(), playerMask.getUpdateMask(), activePlayerMask.getUpdateMask(), player);

            UpdateObject packet;
            tangible.OutObject<UpdateObject> tempOut_packet = new tangible.OutObject<UpdateObject>();
            udata.buildPacket(tempOut_packet);
            packet = tempOut_packet.outArgValue;
            player.sendPacket(packet);
        }
    }
}
